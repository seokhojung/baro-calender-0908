# Story 1.4: ìŠ¤ì¼€ì¤„ CRUD ë° ì´ë²¤íŠ¸ ê´€ë¦¬ ì‹œìŠ¤í…œ

## Status
Ready for Development

## Priority & Dependencies
- **Priority**: P1 (High)
- **Story Points**: 8
- **Dependencies**: [1.2, 1.3]
- **Blocked By**: None
- **Backend Dependencies**: 
  - Events CRUD API (`POST/PATCH/DELETE /v1/events`) - âœ… Implemented
  - Event Tags API - âœ… Implemented
  - Event Reminders API (`/v1/events/:id/reminders`) - âœ… Implemented
  - Event Attachments support - âœ… Database ready

## Success Metrics
- **Business KPI**: 
  - ì¼ì • ìƒì„± ì‹œê°„ 15ì´ˆ ì´ë‚´
  - ì¼ì • ìˆ˜ì • ì™„ë£Œìœ¨ 98% ì´ìƒ
  - ì¼ì • ì¶©ëŒ ìë™ ê°ì§€ìœ¨ 100%
- **Technical KPI**:
  - ì´ë²¤íŠ¸ CRUD ì‘ë‹µ ì‹œê°„ 150ms ì´ë‚´
  - ë“œë˜ê·¸ì•¤ë“œë¡­ í”„ë ˆì„ìœ¨ 60fps ìœ ì§€
  - ë™ì‹œ í¸ì§‘ ì¶©ëŒ í•´ê²° ì‹œê°„ 500ms ì´ë‚´
- **Definition of Success**: ëª¨ë“  CRUD ì‘ì—… ì •ìƒ ë™ì‘, ì‹¤ì‹œê°„ í˜‘ì—… ê¸°ëŠ¥ í™•ì¸

---

## ğŸ¯ **ìŠ¤í† ë¦¬ ëª©í‘œ**

**ê³ ì„±ëŠ¥ ìŠ¤ì¼€ì¤„ ê´€ë¦¬ ì‹œìŠ¤í…œ êµ¬ì¶•**
- í”„ë¡œì íŠ¸ ì—°ë™ ìŠ¤ì¼€ì¤„ ìƒì„±/ìˆ˜ì •/ì‚­ì œ ì‹œìŠ¤í…œ
- ë“œë˜ê·¸ ì•¤ ë“œë¡­ ê¸°ë°˜ ì§ê´€ì  ì¼ì • ê´€ë¦¬
- ì‹¤ì‹œê°„ í˜‘ì—… ë° ì¶©ëŒ ë°©ì§€ ì‹œìŠ¤í…œ
- ì„±ëŠ¥ ìµœì í™”ëœ ëŒ€ìš©ëŸ‰ ì¼ì • ì²˜ë¦¬
- WCAG 2.2 AA ì ‘ê·¼ì„± ë° ëª¨ë°”ì¼ ìµœì í™”

---

## Story
**As a** ì¼ì • ê´€ë¦¬ì,
**I want** í”„ë¡œì íŠ¸ì™€ ì—°ë™ëœ ì¼ì •ì„ ìƒì„±, ìˆ˜ì •, ì‚­ì œí•˜ê³  ë“œë˜ê·¸ì•¤ë“œë¡­ìœ¼ë¡œ ê´€ë¦¬í•  ìˆ˜ ìˆëŠ” ì‹œìŠ¤í…œì„ ì‚¬ìš©í•˜ì—¬,
**so that** íŒ€ì˜ ëª¨ë“  ì¼ì •ì„ íš¨ìœ¨ì ìœ¼ë¡œ ê´€ë¦¬í•˜ê³  ì¶©ëŒì„ ë°©ì§€í•  ìˆ˜ ìˆë‹¤.

## Acceptance Criteria
1. í”„ë¡œì íŠ¸ì™€ ì—°ë™ë˜ëŠ” ì»¬ëŸ¬ ì½”ë”©ëœ ì¼ì •ì„ ìƒì„±í•˜ê³  ê´€ë¦¬í•˜ê³  ì‹¶ë‹¤
2. ë“œë˜ê·¸ ì•¤ ë“œë¡­ìœ¼ë¡œ ì¼ì • ì‹œê°„ì„ ì‰½ê²Œ ë³€ê²½í•˜ê³  ì‹¶ë‹¤
3. íŒ€ì›ë“¤ê³¼ ì‹¤ì‹œê°„ìœ¼ë¡œ ì¼ì • ë³€ê²½ì‚¬í•­ì„ ê³µìœ í•˜ê³  ì‹¶ë‹¤
4. ì¼ì • ì¶©ëŒì„ ë°©ì§€í•˜ê³  ìë™ìœ¼ë¡œ ëŒ€ì•ˆì„ ì œì‹œë°›ê³  ì‹¶ë‹¤
5. ëª¨ë°”ì¼ì—ì„œë„ ì™„ë²½í•˜ê²Œ ì¼ì •ì„ ê´€ë¦¬í•˜ê³  ì‹¶ë‹¤

---

## ğŸ—ï¸ **ê¸°ìˆ ì  êµ¬í˜„ ìš”êµ¬ì‚¬í•­**

### **1. ShadCN UI + MCP Server ì»´í¬ë„ŒíŠ¸ ì‹œìŠ¤í…œ**

**í•µì‹¬ ë¸”ë¡ ë° ì»´í¬ë„ŒíŠ¸**
```typescript
// í•„ìˆ˜ MCP ì„œë²„ ëª…ë ¹ì–´ ì‹œí€€ìŠ¤
// 1. ìº˜ë¦°ë” ì´ë²¤íŠ¸ í¼
npx shadcn@latest add forms-01
npx shadcn@latest add calendar-01

// 2. ì´ë²¤íŠ¸ ë¦¬ìŠ¤íŠ¸ ë° í…Œì´ë¸”
npx shadcn@latest add table-01
npx shadcn@latest add cards-01

// 3. ë‹¤ì´ì–¼ë¡œê·¸ ë° ì‹œíŠ¸
npx shadcn@latest add sheet
npx shadcn@latest add dialog

// ê°œë³„ ì»´í¬ë„ŒíŠ¸
npx shadcn@latest add form
npx shadcn@latest add calendar
npx shadcn@latest add date-picker
npx shadcn@latest add time-picker
npx shadcn@latest add textarea
npx shadcn@latest add select
npx shadcn@latest add checkbox
npx shadcn@latest add label
npx shadcn@latest add popover
npx shadcn@latest add tooltip
npx shadcn@latest add badge
npx shadcn@latest add alert
```

### **2. ìŠ¤ì¼€ì¤„ ë°ì´í„° ëª¨ë¸ë§**

**GraphQL ìŠ¤í‚¤ë§ˆ ë° íƒ€ì… ì •ì˜**
```typescript
// src/types/schedule.ts
export interface Schedule {
  id: string
  title: string
  description?: string
  
  // ì‹œê°„ ê´€ë¦¬
  startDateTime: string
  endDateTime: string
  isAllDay: boolean
  timezone: string
  
  // í”„ë¡œì íŠ¸ ì—°ë™
  projectId: string
  project: Project
  
  // ë°˜ë³µ ì¼ì •
  recurrenceRule?: RecurrenceRule
  parentId?: string // ë°˜ë³µ ì¼ì •ì˜ ë¶€ëª¨
  
  // ì°¸ê°€ì
  attendees: ScheduleAttendee[]
  
  // ìƒíƒœ
  status: 'draft' | 'confirmed' | 'cancelled'
  isPrivate: boolean
  
  // ë©”íƒ€ë°ì´í„°
  location?: string
  url?: string
  attachments: string[]
  
  createdBy: string
  updatedBy: string
  createdAt: string
  updatedAt: string
  version: number // ë‚™ê´€ì  ì—…ë°ì´íŠ¸ìš©
}

export interface ScheduleAttendee {
  userId: string
  email: string
  name: string
  role: 'organizer' | 'required' | 'optional'
  status: 'pending' | 'accepted' | 'declined' | 'tentative'
  responseAt?: string
}

export interface RecurrenceRule {
  frequency: 'daily' | 'weekly' | 'monthly' | 'yearly'
  interval: number // 1 = ë§¤ì¼, 2 = ê²©ì¼
  endDate?: string
  count?: number // ë°˜ë³µ íšŸìˆ˜
  byWeekDay?: number[] // ìš”ì¼ (0=ì¼ìš”ì¼)
  byMonthDay?: number[] // ì›”ì˜ ì¼ (1-31)
}
```

### **3. Apollo Client + Zustand ìƒíƒœ ê´€ë¦¬**

**GraphQL ì¿¼ë¦¬ ë° ë®¤í…Œì´ì…˜**
```typescript
// src/graphql/schedule.graphql
query GetSchedules(
  $filters: ScheduleFilters
  $dateRange: DateRange!
  $projectIds: [ID!]
) {
  schedules(
    filters: $filters
    dateRange: $dateRange 
    projectIds: $projectIds
  ) {
    id
    title
    startDateTime
    endDateTime
    isAllDay
    project {
      id
      name
      color
    }
    attendees {
      userId
      name
      status
    }
    status
    version
  }
}

mutation CreateSchedule($input: CreateScheduleInput!) {
  createSchedule(input: $input) {
    id
    title
    startDateTime
    endDateTime
    project {
      id
      color
    }
    version
  }
}

mutation UpdateSchedule($id: ID!, $input: UpdateScheduleInput!, $version: Int!) {
  updateSchedule(id: $id, input: $input, version: $version) {
    id
    title
    startDateTime
    endDateTime
    version
    # ì¶©ëŒ ì²˜ë¦¬ë¥¼ ìœ„í•œ ì—ëŸ¬
  }
}

mutation DeleteSchedule($id: ID!, $version: Int!) {
  deleteSchedule(id: $id, version: $version) {
    success
    message
  }
}

# ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
subscription ScheduleUpdates($dateRange: DateRange!) {
  scheduleUpdated(dateRange: $dateRange) {
    type # CREATED, UPDATED, DELETED, CONFLICT
    schedule {
      id
      title
      startDateTime
      endDateTime
      project { color }
      version
    }
    conflictInfo {
      conflictingSchedules {
        id
        title
        startDateTime
        endDateTime
      }
    }
  }
}

# ì¶©ëŒ ê²€ì‚¬
query CheckScheduleConflicts($input: ConflictCheckInput!) {
  checkScheduleConflicts(input: $input) {
    hasConflicts
    conflicts {
      scheduleId
      title
      startDateTime
      endDateTime
      severity # 'high' | 'medium' | 'low'
    }
    suggestions {
      startDateTime
      endDateTime
      reason
    }
  }
}
```

**Zustand ìŠ¤ì¼€ì¤„ Store**
```typescript
// src/stores/scheduleStore.ts
interface ScheduleState {
  // ìŠ¤ì¼€ì¤„ ë°ì´í„°
  schedules: Map<string, Schedule>
  selectedDateRange: { start: Date; end: Date }
  selectedProjectIds: string[]
  
  // UI ìƒíƒœ
  selectedSchedule: Schedule | null
  draggedSchedule: Schedule | null
  isLoading: boolean
  error: ApiError | null
  
  // í•„í„°ë§
  viewMode: 'month' | 'week' | 'day' | 'agenda'
  showAllDay: boolean
  showPrivate: boolean
  
  // Actions
  setSchedules: (schedules: Schedule[]) => void
  addSchedule: (schedule: Schedule) => void
  updateSchedule: (id: string, updates: Partial<Schedule>) => void
  deleteSchedule: (id: string) => void
  
  // ë“œë˜ê·¸ ì•¤ ë“œë¡­
  startDrag: (schedule: Schedule) => void
  updateDraggedSchedule: (updates: { startDateTime: string; endDateTime: string }) => void
  commitDrag: () => Promise<void>
  cancelDrag: () => void
  
  // ì¶©ëŒ ê´€ë¦¬
  checkConflicts: (schedule: Partial<Schedule>) => Promise<ConflictCheckResult>
  resolveConflict: (scheduleId: string, resolution: ConflictResolution) => void
  
  // ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
  handleRealtimeUpdate: (update: ScheduleUpdate) => void
}

export const useScheduleStore = create<ScheduleState>((set, get) => ({
  schedules: new Map(),
  selectedDateRange: {
    start: startOfWeek(new Date()),
    end: endOfWeek(new Date())
  },
  selectedProjectIds: [],
  selectedSchedule: null,
  draggedSchedule: null,
  isLoading: false,
  error: null,
  viewMode: 'week',
  showAllDay: true,
  showPrivate: true,
  
  setSchedules: (schedules) => {
    const scheduleMap = new Map()
    schedules.forEach(schedule => scheduleMap.set(schedule.id, schedule))
    set({ schedules: scheduleMap })
  },
  
  updateDraggedSchedule: (updates) => {
    const { draggedSchedule } = get()
    if (!draggedSchedule) return
    
    set({
      draggedSchedule: {
        ...draggedSchedule,
        ...updates
      }
    })
  },
  
  commitDrag: async () => {
    const { draggedSchedule, updateSchedule } = get()
    if (!draggedSchedule) return
    
    // ì¶©ëŒ ê²€ì‚¬
    const conflictResult = await get().checkConflicts(draggedSchedule)
    
    if (conflictResult.hasConflicts) {
      // ì¶©ëŒ í•´ê²° ë‹¤ì´ì–¼ë¡œê·¸ í‘œì‹œ
      showConflictResolutionDialog(conflictResult)
      return
    }
    
    // Apollo Client ë®¤í…Œì´ì…˜ ì‹¤í–‰
    updateSchedule(draggedSchedule.id, {
      startDateTime: draggedSchedule.startDateTime,
      endDateTime: draggedSchedule.endDateTime
    })
    
    set({ draggedSchedule: null })
  },
  
  handleRealtimeUpdate: (update) => {
    const { schedules } = get()
    
    switch (update.type) {
      case 'CREATED':
        schedules.set(update.schedule.id, update.schedule)
        showToast('info', `ìƒˆ ì¼ì •ì´ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤: ${update.schedule.title}`)
        break
        
      case 'UPDATED':
        const existing = schedules.get(update.schedule.id)
        if (existing && existing.version < update.schedule.version) {
          schedules.set(update.schedule.id, update.schedule)
          showToast('info', `ì¼ì •ì´ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤: ${update.schedule.title}`)
        }
        break
        
      case 'DELETED':
        schedules.delete(update.schedule.id)
        showToast('warning', `ì¼ì •ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤: ${update.schedule.title}`)
        break
        
      case 'CONFLICT':
        showConflictNotification(update.conflictInfo)
        break
    }
    
    set({ schedules: new Map(schedules) })
  }
}))
```

### **4. ë“œë˜ê·¸ ì•¤ ë“œë¡­ êµ¬í˜„**

**ì‹œê°„ ê¸°ë°˜ ë“œë˜ê·¸ ì‹œìŠ¤í…œ**
```typescript
// src/components/schedule/DraggableSchedule.tsx
import { useDrag, useDrop } from 'react-dnd'

const DraggableSchedule = ({ schedule, timeSlot }: DraggableScheduleProps) => {
  const { startDrag, updateDraggedSchedule, commitDrag } = useScheduleStore()
  
  const [{ isDragging }, drag] = useDrag(() => ({
    type: 'SCHEDULE',
    item: { schedule, originalTimeSlot: timeSlot },
    begin: () => startDrag(schedule),
    end: (item, monitor) => {
      if (monitor.didDrop()) {
        commitDrag()
      } else {
        useScheduleStore.getState().cancelDrag()
      }
    },
    collect: (monitor) => ({
      isDragging: monitor.isDragging(),
    }),
  }))
  
  const projectColor = PROJECT_COLORS[schedule.project.color]
  
  return (
    <div
      ref={drag}
      className={cn(
        "schedule-item cursor-move border-l-4 p-2 rounded transition-all",
        "hover:shadow-md focus-visible:ring-2 focus-visible:ring-offset-1",
        isDragging && "opacity-50"
      )}
      style={{
        borderLeftColor: projectColor.primary,
        backgroundColor: projectColor.secondary,
      }}
      tabIndex={0}
      role="button"
      aria-label={`ì¼ì •: ${schedule.title}, ì‹œê°„: ${formatTime(schedule.startDateTime)} - ${formatTime(schedule.endDateTime)}`}
      onKeyDown={handleKeyboardMove}
    >
      <div className="flex items-center justify-between">
        <div className="flex-1 min-w-0">
          <h3 className="font-medium text-sm truncate">{schedule.title}</h3>
          <p className="text-xs text-muted-foreground">
            {formatTimeRange(schedule.startDateTime, schedule.endDateTime)}
          </p>
        </div>
        <div className="flex items-center gap-1 ml-2">
          {schedule.attendees.length > 0 && (
            <Badge variant="secondary" className="text-xs">
              {schedule.attendees.length}ëª…
            </Badge>
          )}
          <ScheduleActions schedule={schedule} />
        </div>
      </div>
    </div>
  )
}

// ì‹œê°„ ìŠ¬ë¡¯ ë“œë¡­ ì˜ì—­
const TimeSlotDropZone = ({ timeSlot, date }: TimeSlotDropZoneProps) => {
  const { updateDraggedSchedule } = useScheduleStore()
  
  const [{ isOver, canDrop }, drop] = useDrop(() => ({
    accept: 'SCHEDULE',
    canDrop: (item) => {
      // ì‹œê°„ ì¶©ëŒ ì²´í¬
      return !hasTimeConflict(item.schedule, timeSlot, date)
    },
    drop: (item) => {
      const newStartDateTime = combineDateAndTime(date, timeSlot.start)
      const duration = differenceInMinutes(
        parseISO(item.schedule.endDateTime),
        parseISO(item.schedule.startDateTime)
      )
      const newEndDateTime = addMinutes(newStartDateTime, duration)
      
      updateDraggedSchedule({
        startDateTime: newStartDateTime.toISOString(),
        endDateTime: newEndDateTime.toISOString()
      })
    },
    collect: (monitor) => ({
      isOver: monitor.isOver(),
      canDrop: monitor.canDrop(),
    }),
  }))
  
  return (
    <div
      ref={drop}
      className={cn(
        "time-slot h-12 border-b border-border/50",
        "hover:bg-muted/50 transition-colors",
        isOver && canDrop && "bg-primary/10 border-primary",
        isOver && !canDrop && "bg-destructive/10 border-destructive"
      )}
      data-testid={`time-slot-${timeSlot.start}`}
    >
      {/* ì‹œê°„ í‘œì‹œ ë° ì´ë²¤íŠ¸ ì˜ì—­ */}
    </div>
  )
}
```

### **5. ì¶©ëŒ ê°ì§€ ë° í•´ê²°**

**ì‹¤ì‹œê°„ ì¶©ëŒ ê°ì§€ ì‹œìŠ¤í…œ**
```typescript
// src/lib/schedule/conflictDetection.ts
export class ScheduleConflictDetector {
  static checkTimeOverlap(
    schedule1: Pick<Schedule, 'startDateTime' | 'endDateTime'>,
    schedule2: Pick<Schedule, 'startDateTime' | 'endDateTime'>
  ): boolean {
    const start1 = parseISO(schedule1.startDateTime)
    const end1 = parseISO(schedule1.endDateTime)
    const start2 = parseISO(schedule2.startDateTime)
    const end2 = parseISO(schedule2.endDateTime)
    
    return isBefore(start1, end2) && isBefore(start2, end1)
  }
  
  static detectConflicts(
    targetSchedule: Partial<Schedule>,
    existingSchedules: Schedule[],
    userIds?: string[]
  ): ConflictDetectionResult {
    const conflicts: ScheduleConflict[] = []
    
    for (const existing of existingSchedules) {
      // ê°™ì€ ì¼ì • ì œì™¸
      if (existing.id === targetSchedule.id) continue
      
      // ì‹œê°„ ê²¹ì¹¨ í™•ì¸
      if (this.checkTimeOverlap(targetSchedule as Schedule, existing)) {
        // ì°¸ê°€ì ê²¹ì¹¨ í™•ì¸
        const attendeeConflict = this.checkAttendeeOverlap(
          targetSchedule.attendees || [],
          existing.attendees
        )
        
        if (attendeeConflict.length > 0) {
          conflicts.push({
            scheduleId: existing.id,
            title: existing.title,
            startDateTime: existing.startDateTime,
            endDateTime: existing.endDateTime,
            severity: this.calculateConflictSeverity(existing),
            conflictingAttendees: attendeeConflict
          })
        }
      }
    }
    
    return {
      hasConflicts: conflicts.length > 0,
      conflicts,
      suggestions: this.generateAlternativeTimeSlots(targetSchedule, existingSchedules)
    }
  }
  
  static generateAlternativeTimeSlots(
    targetSchedule: Partial<Schedule>,
    existingSchedules: Schedule[]
  ): TimeSlotSuggestion[] {
    const suggestions: TimeSlotSuggestion[] = []
    const duration = differenceInMinutes(
      parseISO(targetSchedule.endDateTime!),
      parseISO(targetSchedule.startDateTime!)
    )
    
    // ê°™ì€ ë‚  ë‹¤ë¥¸ ì‹œê°„ ì°¾ê¸°
    const targetDate = parseISO(targetSchedule.startDateTime!).toDateString()
    const daySchedules = existingSchedules.filter(s => 
      parseISO(s.startDateTime).toDateString() === targetDate
    )
    
    // 30ë¶„ ê°„ê²©ìœ¼ë¡œ ë¹ˆ ì‹œê°„ ì°¾ê¸°
    const workingHours = { start: 9, end: 18 } // 9ì‹œ-18ì‹œ
    for (let hour = workingHours.start; hour < workingHours.end; hour++) {
      for (let minute = 0; minute < 60; minute += 30) {
        const candidateStart = setHours(setMinutes(parseISO(targetSchedule.startDateTime!), minute), hour)
        const candidateEnd = addMinutes(candidateStart, duration)
        
        const hasConflict = daySchedules.some(schedule =>
          this.checkTimeOverlap(
            { startDateTime: candidateStart.toISOString(), endDateTime: candidateEnd.toISOString() },
            schedule
          )
        )
        
        if (!hasConflict) {
          suggestions.push({
            startDateTime: candidateStart.toISOString(),
            endDateTime: candidateEnd.toISOString(),
            reason: `${format(candidateStart, 'HH:mm')} - ${format(candidateEnd, 'HH:mm')} ì‹œê°„ëŒ€ ê°€ëŠ¥`
          })
        }
        
        if (suggestions.length >= 3) break // ìµœëŒ€ 3ê°œ ì œì•ˆ
      }
    }
    
    return suggestions
  }
}

// ì¶©ëŒ í•´ê²° ë‹¤ì´ì–¼ë¡œê·¸
const ConflictResolutionDialog = ({ conflicts, onResolve }: ConflictResolutionProps) => {
  const [selectedResolution, setSelectedResolution] = useState<ConflictResolution>()
  
  return (
    <Dialog open={true}>
      <DialogContent className="max-w-md">
        <DialogHeader>
          <DialogTitle>ì¼ì • ì¶©ëŒ ê°ì§€</DialogTitle>
          <DialogDescription>
            ë‹¤ë¥¸ ì¼ì •ê³¼ ì‹œê°„ì´ ê²¹ì¹©ë‹ˆë‹¤. í•´ê²° ë°©ë²•ì„ ì„ íƒí•´ì£¼ì„¸ìš”.
          </DialogDescription>
        </DialogHeader>
        
        <div className="space-y-4">
          {/* ì¶©ëŒëœ ì¼ì • ëª©ë¡ */}
          <div className="space-y-2">
            <h4 className="font-medium text-sm">ì¶©ëŒëœ ì¼ì •</h4>
            {conflicts.conflicts.map(conflict => (
              <div key={conflict.scheduleId} className="flex items-center gap-2 p-2 bg-muted rounded">
                <AlertTriangle className="w-4 h-4 text-destructive" />
                <div>
                  <p className="font-medium text-sm">{conflict.title}</p>
                  <p className="text-xs text-muted-foreground">
                    {formatTimeRange(conflict.startDateTime, conflict.endDateTime)}
                  </p>
                </div>
              </div>
            ))}
          </div>
          
          {/* í•´ê²° ì˜µì…˜ */}
          <div className="space-y-2">
            <h4 className="font-medium text-sm">í•´ê²° ë°©ë²•</h4>
            <div className="space-y-2">
              <Button
                variant="outline"
                className="w-full justify-start"
                onClick={() => setSelectedResolution('force')}
              >
                ê·¸ëŒ€ë¡œ ì§„í–‰ (ì¶©ëŒ ë¬´ì‹œ)
              </Button>
              
              {conflicts.suggestions.map((suggestion, index) => (
                <Button
                  key={index}
                  variant="outline"
                  className="w-full justify-start"
                  onClick={() => setSelectedResolution({ type: 'reschedule', timeSlot: suggestion })}
                >
                  {suggestion.reason}
                </Button>
              ))}
              
              <Button
                variant="outline"
                className="w-full justify-start"
                onClick={() => setSelectedResolution('cancel')}
              >
                ì¼ì • ìƒì„± ì·¨ì†Œ
              </Button>
            </div>
          </div>
        </div>
        
        <DialogFooter>
          <Button
            disabled={!selectedResolution}
            onClick={() => onResolve(selectedResolution!)}
          >
            í™•ì¸
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  )
}
```

---

## ğŸ¨ **ì‚¬ìš©ì ê²½í—˜ (UX) ì„¤ê³„**

### **1. ìŠ¤ì¼€ì¤„ ìƒì„± í”Œë¡œìš°**

**ë‹¨ê³„ë³„ í¼ ì¸í„°í˜ì´ìŠ¤**
```typescript
// src/components/schedule/ScheduleCreateForm.tsx
const ScheduleCreateForm = ({ initialData }: ScheduleCreateFormProps) => {
  const form = useForm<CreateScheduleInput>({
    resolver: zodResolver(createScheduleSchema),
    defaultValues: {
      title: '',
      startDateTime: initialData?.startDateTime || new Date().toISOString(),
      endDateTime: initialData?.endDateTime || addHours(new Date(), 1).toISOString(),
      isAllDay: false,
      projectId: '',
      description: '',
      location: '',
      attendees: [],
    }
  })
  
  const { checkConflicts } = useScheduleStore()
  const [conflictResult, setConflictResult] = useState<ConflictCheckResult>()
  
  // ì‹¤ì‹œê°„ ì¶©ëŒ ê²€ì‚¬
  const debouncedConflictCheck = useCallback(
    debounce(async (formData: Partial<Schedule>) => {
      if (formData.startDateTime && formData.endDateTime) {
        const result = await checkConflicts(formData)
        setConflictResult(result)
      }
    }, 500),
    [checkConflicts]
  )
  
  useEffect(() => {
    const subscription = form.watch((formData) => {
      debouncedConflictCheck(formData as Partial<Schedule>)
    })
    return () => subscription.unsubscribe()
  }, [form, debouncedConflictCheck])
  
  return (
    <Form {...form}>
      <form className="space-y-6">
        {/* ê¸°ë³¸ ì •ë³´ */}
        <FormField
          control={form.control}
          name="title"
          render={({ field }) => (
            <FormItem>
              <FormLabel>ì œëª© *</FormLabel>
              <FormControl>
                <Input
                  {...field}
                  placeholder="ì¼ì • ì œëª©ì„ ì…ë ¥í•˜ì„¸ìš”"
                  className="text-base" // ëª¨ë°”ì¼ ì¤Œ ë°©ì§€
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        
        {/* í”„ë¡œì íŠ¸ ì„ íƒ */}
        <FormField
          control={form.control}
          name="projectId"
          render={({ field }) => (
            <FormItem>
              <FormLabel>í”„ë¡œì íŠ¸ *</FormLabel>
              <Select onValueChange={field.onChange} value={field.value}>
                <SelectTrigger>
                  <SelectValue placeholder="í”„ë¡œì íŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”" />
                </SelectTrigger>
                <SelectContent>
                  {projects.map(project => (
                    <SelectItem key={project.id} value={project.id}>
                      <div className="flex items-center gap-2">
                        <div 
                          className="w-3 h-3 rounded-full"
                          style={{ backgroundColor: PROJECT_COLORS[project.color].primary }}
                        />
                        {project.name}
                      </div>
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
              <FormMessage />
            </FormItem>
          )}
        />
        
        {/* ì‹œê°„ ì„¤ì • */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <FormField
            control={form.control}
            name="startDateTime"
            render={({ field }) => (
              <FormItem>
                <FormLabel>ì‹œì‘ ì‹œê°„ *</FormLabel>
                <DateTimePicker
                  value={field.value ? parseISO(field.value) : new Date()}
                  onChange={(date) => field.onChange(date?.toISOString())}
                />
                <FormMessage />
              </FormItem>
            )}
          />
          
          <FormField
            control={form.control}
            name="endDateTime"
            render={({ field }) => (
              <FormItem>
                <FormLabel>ì¢…ë£Œ ì‹œê°„ *</FormLabel>
                <DateTimePicker
                  value={field.value ? parseISO(field.value) : addHours(new Date(), 1)}
                  onChange={(date) => field.onChange(date?.toISOString())}
                  minDate={form.watch('startDateTime') ? parseISO(form.watch('startDateTime')) : undefined}
                />
                <FormMessage />
              </FormItem>
            )}
          />
        </div>
        
        {/* í•˜ë£¨ ì¢…ì¼ í† ê¸€ */}
        <FormField
          control={form.control}
          name="isAllDay"
          render={({ field }) => (
            <FormItem className="flex flex-row items-center justify-between rounded-lg border p-3 shadow-sm">
              <div className="space-y-0.5">
                <FormLabel>í•˜ë£¨ ì¢…ì¼</FormLabel>
                <FormDescription>
                  íŠ¹ì • ì‹œê°„ì´ ì •í•´ì§€ì§€ ì•Šì€ ì¼ì •
                </FormDescription>
              </div>
              <FormControl>
                <Switch
                  checked={field.value}
                  onCheckedChange={field.onChange}
                />
              </FormControl>
            </FormItem>
          )}
        />
        
        {/* ì¶©ëŒ ê²½ê³  */}
        {conflictResult?.hasConflicts && (
          <Alert variant="destructive">
            <AlertTriangle className="h-4 w-4" />
            <AlertTitle>ì¼ì • ì¶©ëŒ</AlertTitle>
            <AlertDescription>
              {conflictResult.conflicts.length}ê°œì˜ ë‹¤ë¥¸ ì¼ì •ê³¼ ì‹œê°„ì´ ê²¹ì¹©ë‹ˆë‹¤.
              <Button 
                variant="link" 
                size="sm" 
                className="p-0 h-auto ml-2"
                onClick={() => setShowConflictDetails(true)}
              >
                ìì„¸íˆ ë³´ê¸°
              </Button>
            </AlertDescription>
          </Alert>
        )}
        
        {/* ì°¸ê°€ì ì¶”ê°€ */}
        <FormField
          control={form.control}
          name="attendees"
          render={({ field }) => (
            <FormItem>
              <FormLabel>ì°¸ê°€ì</FormLabel>
              <AttendeeSelector
                value={field.value}
                onChange={field.onChange}
              />
              <FormDescription>
                ì¼ì •ì— ì°¸ì—¬í•  ì‚¬ëŒë“¤ì„ ì¶”ê°€í•˜ì„¸ìš”
              </FormDescription>
            </FormItem>
          )}
        />
        
        {/* ì¶”ê°€ ì •ë³´ */}
        <Collapsible>
          <CollapsibleTrigger className="flex items-center gap-2 font-medium">
            <ChevronRight className="w-4 h-4 transition-transform data-[state=open]:rotate-90" />
            ì¶”ê°€ ì •ë³´
          </CollapsibleTrigger>
          <CollapsibleContent className="space-y-4 mt-4">
            <FormField
              control={form.control}
              name="description"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>ì„¤ëª…</FormLabel>
                  <FormControl>
                    <Textarea
                      {...field}
                      placeholder="ì¼ì •ì— ëŒ€í•œ ìì„¸í•œ ì„¤ëª…ì„ ì…ë ¥í•˜ì„¸ìš”"
                      rows={3}
                    />
                  </FormControl>
                </FormItem>
              )}
            />
            
            <FormField
              control={form.control}
              name="location"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>ì¥ì†Œ</FormLabel>
                  <FormControl>
                    <Input
                      {...field}
                      placeholder="ì˜ˆ: íšŒì˜ì‹¤ A, ì˜¨ë¼ì¸"
                    />
                  </FormControl>
                </FormItem>
              )}
            />
          </CollapsibleContent>
        </Collapsible>
      </form>
    </Form>
  )
}
```

### **2. ì ‘ê·¼ì„± (A11y) êµ¬í˜„**

**í‚¤ë³´ë“œ ë„¤ë¹„ê²Œì´ì…˜ ë° ìŠ¤í¬ë¦° ë¦¬ë” ì§€ì›**
```typescript
// src/components/schedule/AccessibleScheduleGrid.tsx
const AccessibleScheduleGrid = ({ schedules }: ScheduleGridProps) => {
  const [focusedSchedule, setFocusedSchedule] = useState<string | null>(null)
  const [announcements, setAnnouncements] = useState<string[]>([])
  
  const handleKeyboardNavigation = useCallback((event: KeyboardEvent) => {
    const scheduleIds = Array.from(schedules.keys())
    const currentIndex = scheduleIds.findIndex(id => id === focusedSchedule)
    
    switch (event.key) {
      case 'ArrowDown':
        event.preventDefault()
        const nextIndex = Math.min(currentIndex + 1, scheduleIds.length - 1)
        setFocusedSchedule(scheduleIds[nextIndex])
        announceSchedule(schedules.get(scheduleIds[nextIndex])!)
        break
        
      case 'ArrowUp':
        event.preventDefault()
        const prevIndex = Math.max(currentIndex - 1, 0)
        setFocusedSchedule(scheduleIds[prevIndex])
        announceSchedule(schedules.get(scheduleIds[prevIndex])!)
        break
        
      case 'Enter':
      case ' ':
        event.preventDefault()
        if (focusedSchedule) {
          openScheduleDetails(focusedSchedule)
        }
        break
        
      case 'Delete':
        event.preventDefault()
        if (focusedSchedule) {
          confirmDeleteSchedule(focusedSchedule)
        }
        break
    }
  }, [focusedSchedule, schedules])
  
  const announceSchedule = (schedule: Schedule) => {
    const announcement = `${schedule.title}, ${schedule.project.name} í”„ë¡œì íŠ¸, ${formatTimeRange(schedule.startDateTime, schedule.endDateTime)}`
    setAnnouncements([announcement])
  }
  
  return (
    <div
      className="schedule-grid"
      role="grid"
      aria-label="ì¼ì • ìº˜ë¦°ë”"
      onKeyDown={handleKeyboardNavigation}
      tabIndex={0}
    >
      {/* ìŠ¤í¬ë¦° ë¦¬ë”ë¥¼ ìœ„í•œ ì‹¤ì‹œê°„ ì•Œë¦¼ */}
      <div aria-live="polite" aria-atomic="true" className="sr-only">
        {announcements.map((text, index) => (
          <div key={index}>{text}</div>
        ))}
      </div>
      
      {/* ì‚¬ìš©ë²• ì•ˆë‚´ */}
      <div id="schedule-grid-help" className="sr-only">
        í™”ì‚´í‘œ í‚¤ë¡œ ì¼ì •ì„ íƒìƒ‰í•˜ê³ , ì—”í„°í‚¤ë¡œ ìƒì„¸ ì •ë³´ë¥¼ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
        Delete í‚¤ë¡œ ì¼ì •ì„ ì‚­ì œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
      </div>
      
      {Array.from(schedules.values()).map(schedule => (
        <div
          key={schedule.id}
          role="gridcell"
          tabIndex={focusedSchedule === schedule.id ? 0 : -1}
          className={cn(
            "schedule-item",
            focusedSchedule === schedule.id && "ring-2 ring-primary"
          )}
          onClick={() => setFocusedSchedule(schedule.id)}
          aria-describedby="schedule-grid-help"
          aria-label={`ì¼ì •: ${schedule.title}, í”„ë¡œì íŠ¸: ${schedule.project.name}, ì‹œê°„: ${formatTimeRange(schedule.startDateTime, schedule.endDateTime)}`}
        >
          <AccessibleScheduleCard schedule={schedule} />
        </div>
      ))}
    </div>
  )
}
```

---

## ğŸ“Š **ì„±ëŠ¥ ìµœì í™”**

### **ê°€ìƒí™” ë° ì§€ì—° ë¡œë”©**
```typescript
// src/components/schedule/VirtualizedScheduleList.tsx
import { FixedSizeList as List, areEqual } from 'react-window'

const VirtualizedScheduleList = ({ schedules, dateRange }: VirtualizedScheduleListProps) => {
  // ë‚ ì§œë³„ë¡œ ìŠ¤ì¼€ì¤„ ê·¸ë£¹í™”
  const groupedSchedules = useMemo(() => {
    const groups = new Map<string, Schedule[]>()
    schedules.forEach(schedule => {
      const date = format(parseISO(schedule.startDateTime), 'yyyy-MM-dd')
      if (!groups.has(date)) groups.set(date, [])
      groups.get(date)!.push(schedule)
    })
    return groups
  }, [schedules])
  
  const ScheduleRow = memo(({ index, style }: ListChildComponentProps) => {
    const dateKeys = Array.from(groupedSchedules.keys()).sort()
    const date = dateKeys[index]
    const daySchedules = groupedSchedules.get(date) || []
    
    return (
      <div style={style}>
        <DayScheduleGroup 
          date={date} 
          schedules={daySchedules} 
        />
      </div>
    )
  }, areEqual)
  
  return (
    <List
      height={600}
      itemCount={groupedSchedules.size}
      itemSize={120}
      overscanCount={2}
      className="schedule-list"
    >
      {ScheduleRow}
    </List>
  )
}

// ë©”ëª¨ì´ì œì´ì…˜ëœ ìŠ¤ì¼€ì¤„ ì¹´ë“œ
const ScheduleCard = memo(({ schedule }: { schedule: Schedule }) => {
  const projectColor = PROJECT_COLORS[schedule.project.color]
  
  return (
    <div
      className="schedule-card"
      style={{
        borderLeftColor: projectColor.primary,
        backgroundColor: projectColor.secondary,
      }}
    >
      {/* ìŠ¤ì¼€ì¤„ ë‚´ìš© */}
    </div>
  )
}, (prevProps, nextProps) => {
  return (
    prevProps.schedule.id === nextProps.schedule.id &&
    prevProps.schedule.version === nextProps.schedule.version
  )
})
```

---

## âœ… **Definition of Done**

### **ê¸°ëŠ¥ ìš”êµ¬ì‚¬í•­**
- [ ] í”„ë¡œì íŠ¸ ì—°ë™ ìŠ¤ì¼€ì¤„ CRUD (ìƒì„±/ì¡°íšŒ/ìˆ˜ì •/ì‚­ì œ)
- [ ] ë“œë˜ê·¸ ì•¤ ë“œë¡­ì„ í†µí•œ ì¼ì • ì‹œê°„ ë³€ê²½
- [ ] ì‹¤ì‹œê°„ ì¼ì • ì—…ë°ì´íŠ¸ ë™ê¸°í™”
- [ ] ì¼ì • ì¶©ëŒ ê°ì§€ ë° ëŒ€ì•ˆ ì œì‹œ
- [ ] ì°¸ê°€ì ê´€ë¦¬ ë° ì‘ë‹µ ì¶”ì 

### **ê¸°ìˆ  ìš”êµ¬ì‚¬í•­**
- [ ] ShadCN UI MCP ì„œë²„ ë¸”ë¡ í™œìš© (forms-01, calendar-01, table-01)
- [ ] Apollo Client GraphQL êµ¬ë…ì„ í†µí•œ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
- [ ] Zustand ìƒíƒœ ê´€ë¦¬ ë° ë‚™ê´€ì  ì—…ë°ì´íŠ¸
- [ ] React DnD ë“œë˜ê·¸ ì•¤ ë“œë¡­ êµ¬í˜„
- [ ] ë²„ì „ ê¸°ë°˜ ì¶©ëŒ í•´ê²° ì‹œìŠ¤í…œ

### **ì„±ëŠ¥ ìš”êµ¬ì‚¬í•­**
- [ ] ì¼ì • ëª©ë¡ ë¡œë”© 1ì´ˆ ì´í•˜
- [ ] ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì‘ë‹µì„± 16ms (60fps)
- [ ] ì¶©ëŒ ê°ì§€ ì‘ë‹µì‹œê°„ 500ms ì´í•˜
- [ ] ê°€ìƒí™”ë¥¼ í†µí•œ ëŒ€ìš©ëŸ‰ ì¼ì • ì²˜ë¦¬

### **ì ‘ê·¼ì„± ìš”êµ¬ì‚¬í•­**
- [ ] WCAG 2.2 AA í‚¤ë³´ë“œ ë„¤ë¹„ê²Œì´ì…˜
- [ ] ìŠ¤í¬ë¦° ë¦¬ë” ARIA ë ˆì´ë¸” ì™„ì „ ì§€ì›
- [ ] ìƒ‰ìƒ ëŒ€ë¹„ 4.5:1 ì¤€ìˆ˜
- [ ] 44px ìµœì†Œ í„°ì¹˜ ì˜ì—­ ë³´ì¥

### **ë³´ì•ˆ ìš”êµ¬ì‚¬í•­**
- [ ] JWT ê¸°ë°˜ ì¼ì • ê¶Œí•œ ê²€ì¦
- [ ] ê°œì¸ ì •ë³´ í•„í„°ë§ ë° ë³´í˜¸
- [ ] ì¼ì • ê³µìœ  ê¶Œí•œ ì„¸ë¶„í™”
- [ ] ê°ì‚¬ ë¡œê·¸ ë° ë³€ê²½ ì¶”ì 

### **í…ŒìŠ¤íŠ¸ ìš”êµ¬ì‚¬í•­**
- [ ] Jest + RTL ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ (80% ì»¤ë²„ë¦¬ì§€)
- [ ] Playwright E2E ì¼ì • ê´€ë¦¬ í”Œë¡œìš° í…ŒìŠ¤íŠ¸
- [ ] ì ‘ê·¼ì„± í…ŒìŠ¤íŠ¸ (jest-axe)
- [ ] ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ (Lighthouse 90ì  ì´ìƒ)

---

## ğŸ“š **ê´€ë ¨ ë¬¸ì„œ ì°¸ì¡°**

- [04. ìƒíƒœ ê´€ë¦¬](../ui-architecture/04-state-management.md)
- [08. ëŸ°íƒ€ì„ ì„±ëŠ¥](../ui-architecture/08-runtime-performance.md)
- [11. ì ‘ê·¼ì„± êµ¬í˜„](../ui-architecture/11-accessibility-implementation.md)
- [15. ì‹¤ì‹œê°„ WebSocket ë™ê¸°í™”](../ui-architecture/15-realtime-websocket-sync.md)
- [20. í‘œì¤€ ì—ëŸ¬ í¬ë§· ë° í•¸ë“¤ë§](../ui-architecture/20-error-handling.md)

---

**ì´ ìŠ¤í† ë¦¬ëŠ” ë°”ë¡œìº˜ë¦°ë”ì˜ í•µì‹¬ ìŠ¤ì¼€ì¤„ ê´€ë¦¬ ê¸°ëŠ¥ì„ ì™„ì „í•˜ê²Œ êµ¬í˜„í•˜ê¸° ìœ„í•œ ì¢…í•©ì ì¸ ê¸°ìˆ  ê°€ì´ë“œì…ë‹ˆë‹¤. ëª¨ë“  UI ì•„í‚¤í…ì²˜ ë¬¸ì„œì˜ ìš”êµ¬ì‚¬í•­ì„ í†µí•©í•˜ì—¬ ê³ ì„±ëŠ¥, ê³ ì ‘ê·¼ì„±, ì‹¤ì‹œê°„ í˜‘ì—…ì´ ê°€ëŠ¥í•œ ì‹œìŠ¤í…œìœ¼ë¡œ ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤.**