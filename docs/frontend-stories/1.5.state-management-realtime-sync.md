# Story 1.5: ìƒíƒœ ê´€ë¦¬ ë° ì‹¤ì‹œê°„ ë™ê¸°í™” ì‹œìŠ¤í…œ

## ğŸ“‹ ë¬¸ì„œ ì •ë³´
- **ìŠ¤í† ë¦¬ ë²„ì „**: 2.0
- **ì‘ì„±ì¼**: 2025-08-27
- **ì‘ì„±ì**: Bob (Scrum Master Agent)
- **í”„ë¡œì íŠ¸ëª…**: ë°”ë¡œìº˜ë¦°ë” (Baro Calendar)
- **Epic**: í”„ë¡ íŠ¸ì—”ë“œ í•µì‹¬ ê¸°ëŠ¥ êµ¬í˜„
- **ìƒíƒœ**: Ready for Development

---

## ğŸ¯ **ìŠ¤í† ë¦¬ ëª©í‘œ**

**ì™„ì „í•œ ìƒíƒœ ê´€ë¦¬ ë° ì‹¤ì‹œê°„ ë™ê¸°í™” ì‹œìŠ¤í…œ**
- Apollo Client + Zustand í†µí•© í•˜ì´ë¸Œë¦¬ë“œ ìƒíƒœ ê´€ë¦¬
- WebSocket ê¸°ë°˜ ì‹¤ì‹œê°„ í˜‘ì—… ì‹œìŠ¤í…œ
- ë‚™ê´€ì  ì—…ë°ì´íŠ¸ ë° ì¶©ëŒ í•´ê²°
- ì˜¤í”„ë¼ì¸ ì§€ì› ë° ìë™ ë™ê¸°í™”
- ì„±ëŠ¥ ìµœì í™” ë° ë©”ëª¨ë¦¬ ê´€ë¦¬

---

## ğŸ‘¤ **ì‚¬ìš©ì ìŠ¤í† ë¦¬**

**íŒ€ í˜‘ì—…ìë¡œì„œ, ë‚˜ëŠ”:**
1. ë‹¤ë¥¸ íŒ€ì›ì˜ ì¼ì • ë³€ê²½ì‚¬í•­ì„ ì‹¤ì‹œê°„ìœ¼ë¡œ í™•ì¸í•˜ê³  ì‹¶ë‹¤
2. ì˜¤í”„ë¼ì¸ì—ì„œë„ ì¼ì •ì„ ìˆ˜ì •í•˜ê³  ì˜¨ë¼ì¸ ì‹œ ìë™ ë™ê¸°í™”ë˜ê¸¸ ë°”ë€ë‹¤
3. ë™ì‹œ í¸ì§‘ ì‹œ ì¶©ëŒì„ ìë™ìœ¼ë¡œ í•´ê²°í•˜ê±°ë‚˜ ì„ íƒí•  ìˆ˜ ìˆê¸°ë¥¼ ë°”ë€ë‹¤
4. ë¹ ë¥¸ ì‘ë‹µì„±ì„ ìœ„í•´ ì¦‰ì‹œ UIê°€ ì—…ë°ì´íŠ¸ë˜ê¸¸ ë°”ë€ë‹¤
5. ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì´ ë¶ˆì•ˆì •í•´ë„ ì•ˆì •ì ìœ¼ë¡œ ì‚¬ìš©í•˜ê³  ì‹¶ë‹¤

---

## ğŸ—ï¸ **ê¸°ìˆ ì  êµ¬í˜„ ìš”êµ¬ì‚¬í•­**

### **1. Apollo Client + Zustand í•˜ì´ë¸Œë¦¬ë“œ ì•„í‚¤í…ì²˜**

**Apollo Client ì„¤ì • ë° ìºì‹œ ì „ëµ**
```typescript
// src/lib/apollo/client.ts
import { ApolloClient, InMemoryCache, createHttpLink, split } from '@apollo/client'
import { getMainDefinition } from '@apollo/client/utilities'
import { GraphQLWsLink } from '@apollo/client/link/subscriptions'
import { createClient } from 'graphql-ws'
import { setContext } from '@apollo/client/link/context'

// HTTP Link ì„¤ì •
const httpLink = createHttpLink({
  uri: process.env.NEXT_PUBLIC_GRAPHQL_ENDPOINT,
  credentials: 'include'
})

// WebSocket Link ì„¤ì •
const wsLink = new GraphQLWsLink(
  createClient({
    url: process.env.NEXT_PUBLIC_GRAPHQL_WS_ENDPOINT!,
    connectionParams: () => ({
      authorization: `Bearer ${getAuthToken()}`,
    }),
    on: {
      connected: () => console.log('WebSocket connected'),
      error: (error) => console.error('WebSocket error:', error),
    },
  })
)

// ì¸ì¦ ë§í¬
const authLink = setContext((_, { headers }) => {
  const token = getAuthToken()
  return {
    headers: {
      ...headers,
      authorization: token ? `Bearer ${token}` : "",
    }
  }
})

// ì¿¼ë¦¬ëŠ” HTTP, êµ¬ë…ì€ WebSocket ì‚¬ìš©
const splitLink = split(
  ({ query }) => {
    const definition = getMainDefinition(query)
    return (
      definition.kind === 'OperationDefinition' &&
      definition.operation === 'subscription'
    )
  },
  wsLink,
  authLink.concat(httpLink)
)

// InMemoryCache ì„¤ì •
const cache = new InMemoryCache({
  typePolicies: {
    Query: {
      fields: {
        // í”„ë¡œì íŠ¸ ìºì‹œ ë³‘í•© ì •ì±…
        projects: {
          merge(existing = [], incoming) {
            return incoming
          }
        },
        // ìŠ¤ì¼€ì¤„ ìºì‹œ ë³‘í•© ì •ì±…
        schedules: {
          keyArgs: ['dateRange', 'projectIds'],
          merge(existing = [], incoming, { args, readField }) {
            const merged = new Map()
            
            // ê¸°ì¡´ ë°ì´í„° ì¶”ê°€
            existing.forEach((schedule: any) => {
              const id = readField('id', schedule)
              if (id) merged.set(id, schedule)
            })
            
            // ìƒˆ ë°ì´í„°ë¡œ ì—…ë°ì´íŠ¸/ì¶”ê°€
            incoming.forEach((schedule: any) => {
              const id = readField('id', schedule)
              if (id) merged.set(id, schedule)
            })
            
            return Array.from(merged.values())
          }
        }
      }
    },
    Schedule: {
      fields: {
        // ë‚™ê´€ì  ì—…ë°ì´íŠ¸ë¥¼ ìœ„í•œ ë²„ì „ ê´€ë¦¬
        version: {
          merge(existing, incoming) {
            return Math.max(existing || 0, incoming || 0)
          }
        }
      }
    }
  }
})

export const apolloClient = new ApolloClient({
  link: splitLink,
  cache,
  defaultOptions: {
    watchQuery: {
      errorPolicy: 'all',
      fetchPolicy: 'cache-and-network'
    },
    query: {
      errorPolicy: 'all',
      fetchPolicy: 'cache-first'
    }
  }
})
```

### **2. Zustand ìƒíƒœ ê´€ë¦¬ ì•„í‚¤í…ì²˜**

**ë„ë©”ì¸ ë¶„ë¦¬ëœ Store ì„¤ê³„**
```typescript
// src/stores/index.ts
// ê° ë„ë©”ì¸ë³„ë¡œ ë¶„ë¦¬ëœ ìŠ¤í† ì–´ë“¤ì„ ê²°í•©

import { create } from 'zustand'
import { subscribeWithSelector, devtools, persist } from 'zustand/middleware'
import { immer } from 'zustand/middleware/immer'

// UI ìƒíƒœ ê´€ë¦¬ (Apolloì™€ ë¶„ë¦¬)
interface UIState {
  // ë ˆì´ì•„ì›ƒ ìƒíƒœ
  sidebarCollapsed: boolean
  currentView: 'month' | 'week' | 'day' | 'agenda'
  selectedDate: Date
  
  // ëª¨ë‹¬ ë° ë‹¤ì´ì–¼ë¡œê·¸ ìƒíƒœ
  modals: {
    createSchedule: { open: boolean; data?: any }
    editSchedule: { open: boolean; scheduleId?: string }
    projectSettings: { open: boolean; projectId?: string }
    conflictResolution: { open: boolean; conflicts?: ConflictData[] }
  }
  
  // í•„í„° ìƒíƒœ
  filters: {
    selectedProjectIds: string[]
    showCompletedSchedules: boolean
    dateRange: { start: Date; end: Date }
  }
  
  // ë¡œë”© ìƒíƒœ
  loading: {
    schedules: boolean
    projects: boolean
    sync: boolean
  }
  
  // Actions
  toggleSidebar: () => void
  setCurrentView: (view: ViewType) => void
  setSelectedDate: (date: Date) => void
  openModal: (modal: keyof UIState['modals'], data?: any) => void
  closeModal: (modal: keyof UIState['modals']) => void
  setFilter: (key: keyof UIState['filters'], value: any) => void
  setLoading: (key: keyof UIState['loading'], loading: boolean) => void
}

export const useUIStore = create<UIState>()(
  devtools(
    subscribeWithSelector(
      persist(
        immer((set) => ({
          sidebarCollapsed: false,
          currentView: 'week',
          selectedDate: new Date(),
          modals: {
            createSchedule: { open: false },
            editSchedule: { open: false },
            projectSettings: { open: false },
            conflictResolution: { open: false },
          },
          filters: {
            selectedProjectIds: [],
            showCompletedSchedules: true,
            dateRange: {
              start: startOfWeek(new Date()),
              end: endOfWeek(new Date())
            }
          },
          loading: {
            schedules: false,
            projects: false,
            sync: false
          },
          
          toggleSidebar: () => set(state => {
            state.sidebarCollapsed = !state.sidebarCollapsed
          }),
          
          setCurrentView: (view) => set(state => {
            state.currentView = view
            // ë·° ë³€ê²½ ì‹œ ë‚ ì§œ ë²”ìœ„ ìë™ ì¡°ì •
            const date = state.selectedDate
            switch (view) {
              case 'month':
                state.filters.dateRange = {
                  start: startOfMonth(date),
                  end: endOfMonth(date)
                }
                break
              case 'week':
                state.filters.dateRange = {
                  start: startOfWeek(date),
                  end: endOfWeek(date)
                }
                break
              case 'day':
                state.filters.dateRange = {
                  start: startOfDay(date),
                  end: endOfDay(date)
                }
                break
            }
          }),
          
          openModal: (modal, data) => set(state => {
            state.modals[modal] = { open: true, ...data }
          }),
          
          closeModal: (modal) => set(state => {
            state.modals[modal] = { open: false }
          }),
          
          setFilter: (key, value) => set(state => {
            state.filters[key] = value
          }),
          
          setLoading: (key, loading) => set(state => {
            state.loading[key] = loading
          })
        })),
        {
          name: 'baro-calendar-ui-state',
          partialize: (state) => ({
            sidebarCollapsed: state.sidebarCollapsed,
            currentView: state.currentView,
            filters: state.filters
          })
        }
      )
    ),
    { name: 'UI Store' }
  )
)

// ì‹¤ì‹œê°„ ë™ê¸°í™” ìƒíƒœ ê´€ë¦¬
interface SyncState {
  // ì—°ê²° ìƒíƒœ
  isConnected: boolean
  connectionQuality: 'excellent' | 'good' | 'poor' | 'offline'
  lastSync: Date | null
  
  // ì˜¤í”„ë¼ì¸ í
  offlineQueue: OfflineAction[]
  syncInProgress: boolean
  
  // ì¶©ëŒ ê´€ë¦¬
  conflicts: Map<string, ConflictData>
  
  // í™œì„± ì‚¬ìš©ì (ê°™ì€ ìº˜ë¦°ë”ë¥¼ ë³´ê³  ìˆëŠ” ì‚¬ìš©ìë“¤)
  activeUsers: ActiveUser[]
  
  // Actions
  setConnectionStatus: (connected: boolean, quality?: ConnectionQuality) => void
  addToOfflineQueue: (action: OfflineAction) => void
  processOfflineQueue: () => Promise<void>
  addConflict: (entityId: string, conflict: ConflictData) => void
  resolveConflict: (entityId: string, resolution: ConflictResolution) => void
  updateActiveUsers: (users: ActiveUser[]) => void
}

export const useSyncStore = create<SyncState>()(
  devtools(
    subscribeWithSelector((set, get) => ({
      isConnected: true,
      connectionQuality: 'excellent',
      lastSync: null,
      offlineQueue: [],
      syncInProgress: false,
      conflicts: new Map(),
      activeUsers: [],
      
      setConnectionStatus: (connected, quality = 'excellent') => set({
        isConnected: connected,
        connectionQuality: quality
      }),
      
      addToOfflineQueue: (action) => set(state => ({
        offlineQueue: [...state.offlineQueue, {
          ...action,
          timestamp: new Date(),
          id: generateId()
        }]
      })),
      
      processOfflineQueue: async () => {
        const { offlineQueue } = get()
        if (offlineQueue.length === 0) return
        
        set({ syncInProgress: true })
        
        try {
          // ì˜¤í”„ë¼ì¸ ì•¡ì…˜ë“¤ì„ ìˆœì„œëŒ€ë¡œ ì²˜ë¦¬
          for (const action of offlineQueue) {
            await processOfflineAction(action)
          }
          
          set({ 
            offlineQueue: [],
            lastSync: new Date(),
            syncInProgress: false
          })
          
          showToast('success', `${offlineQueue.length}ê°œì˜ ë³€ê²½ì‚¬í•­ì´ ë™ê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤`)
        } catch (error) {
          set({ syncInProgress: false })
          showToast('error', 'ë™ê¸°í™” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤')
          console.error('Offline sync error:', error)
        }
      },
      
      addConflict: (entityId, conflict) => set(state => ({
        conflicts: new Map(state.conflicts).set(entityId, conflict)
      })),
      
      resolveConflict: (entityId, resolution) => set(state => {
        const newConflicts = new Map(state.conflicts)
        newConflicts.delete(entityId)
        return { conflicts: newConflicts }
      }),
      
      updateActiveUsers: (users) => set({ activeUsers: users })
    })),
    { name: 'Sync Store' }
  )
)
```

### **3. WebSocket ì‹¤ì‹œê°„ ë™ê¸°í™” ì‹œìŠ¤í…œ**

**WebSocket ì—°ê²° ê´€ë¦¬ ë° ë©”ì‹œì§€ ì²˜ë¦¬**
```typescript
// src/lib/websocket/manager.ts
export class WebSocketManager {
  private ws: WebSocket | null = null
  private reconnectAttempts = 0
  private maxReconnectAttempts = 5
  private reconnectTimeout: NodeJS.Timeout | null = null
  private messageQueue: WebSocketMessage[] = []
  private subscribers = new Map<string, Set<MessageHandler>>()
  private heartbeatInterval: NodeJS.Timeout | null = null
  
  constructor(private url: string) {
    this.connect()
  }
  
  private connect() {
    try {
      this.ws = new WebSocket(this.url)
      
      this.ws.onopen = this.handleOpen.bind(this)
      this.ws.onmessage = this.handleMessage.bind(this)
      this.ws.onclose = this.handleClose.bind(this)
      this.ws.onerror = this.handleError.bind(this)
    } catch (error) {
      console.error('WebSocket connection error:', error)
      this.handleReconnect()
    }
  }
  
  private handleOpen() {
    console.log('WebSocket connected')
    this.reconnectAttempts = 0
    useSyncStore.getState().setConnectionStatus(true, 'excellent')
    
    // ì¸ì¦
    this.send({
      type: 'AUTH',
      payload: { token: getAuthToken() }
    })
    
    // í•˜íŠ¸ë¹„íŠ¸ ì‹œì‘
    this.startHeartbeat()
    
    // ëŒ€ê¸° ì¤‘ì¸ ë©”ì‹œì§€ ì „ì†¡
    this.flushMessageQueue()
  }
  
  private handleMessage(event: MessageEvent) {
    try {
      const message: WebSocketMessage = JSON.parse(event.data)
      
      switch (message.type) {
        case 'SCHEDULE_UPDATED':
          this.notifySubscribers('schedule', message)
          this.handleScheduleUpdate(message.payload)
          break
          
        case 'PROJECT_UPDATED':
          this.notifySubscribers('project', message)
          this.handleProjectUpdate(message.payload)
          break
          
        case 'USER_PRESENCE':
          this.handleUserPresence(message.payload)
          break
          
        case 'CONFLICT_DETECTED':
          this.handleConflictDetected(message.payload)
          break
          
        case 'PONG':
          // í•˜íŠ¸ë¹„íŠ¸ ì‘ë‹µ
          break
          
        default:
          console.warn('Unknown WebSocket message type:', message.type)
      }
    } catch (error) {
      console.error('Error parsing WebSocket message:', error)
    }
  }
  
  private handleClose() {
    console.log('WebSocket disconnected')
    useSyncStore.getState().setConnectionStatus(false, 'offline')
    this.stopHeartbeat()
    this.handleReconnect()
  }
  
  private handleError(error: Event) {
    console.error('WebSocket error:', error)
    useSyncStore.getState().setConnectionStatus(false, 'poor')
  }
  
  private handleReconnect() {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      console.error('Max reconnection attempts reached')
      return
    }
    
    this.reconnectAttempts++
    const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000) // ì§€ìˆ˜ ë°±ì˜¤í”„
    
    console.log(`Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts})`)
    
    this.reconnectTimeout = setTimeout(() => {
      this.connect()
    }, delay)
  }
  
  private startHeartbeat() {
    this.heartbeatInterval = setInterval(() => {
      this.send({ type: 'PING' })
    }, 30000) // 30ì´ˆë§ˆë‹¤ í•‘
  }
  
  private stopHeartbeat() {
    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval)
      this.heartbeatInterval = null
    }
  }
  
  send(message: WebSocketMessage) {
    if (this.ws?.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(message))
    } else {
      // ì—°ê²°ì´ ëŠì–´ì§„ ê²½ìš° íì— ì¶”ê°€
      this.messageQueue.push(message)
    }
  }
  
  private flushMessageQueue() {
    while (this.messageQueue.length > 0) {
      const message = this.messageQueue.shift()!
      this.send(message)
    }
  }
  
  subscribe(channel: string, handler: MessageHandler): () => void {
    if (!this.subscribers.has(channel)) {
      this.subscribers.set(channel, new Set())
    }
    
    this.subscribers.get(channel)!.add(handler)
    
    // êµ¬ë… í•´ì œ í•¨ìˆ˜ ë°˜í™˜
    return () => {
      this.subscribers.get(channel)?.delete(handler)
    }
  }
  
  private notifySubscribers(channel: string, message: WebSocketMessage) {
    const handlers = this.subscribers.get(channel)
    if (handlers) {
      handlers.forEach(handler => handler(message))
    }
  }
  
  private handleScheduleUpdate(payload: any) {
    // Apollo ìºì‹œ ì—…ë°ì´íŠ¸
    const { type, schedule } = payload
    
    switch (type) {
      case 'CREATED':
      case 'UPDATED':
        apolloClient.cache.writeFragment({
          id: `Schedule:${schedule.id}`,
          fragment: SCHEDULE_FRAGMENT,
          data: schedule
        })
        break
        
      case 'DELETED':
        apolloClient.cache.evict({ id: `Schedule:${schedule.id}` })
        apolloClient.cache.gc()
        break
    }
    
    // ìºì‹œ ì¿¼ë¦¬ ë‹¤ì‹œ ì‹¤í–‰
    apolloClient.refetchQueries({ include: ['GetSchedules'] })
  }
  
  private handleConflictDetected(payload: ConflictData) {
    const { addConflict } = useSyncStore.getState()
    addConflict(payload.entityId, payload)
    
    // ì¶©ëŒ í•´ê²° ëª¨ë‹¬ í‘œì‹œ
    const { openModal } = useUIStore.getState()
    openModal('conflictResolution', { conflicts: [payload] })
  }
  
  disconnect() {
    if (this.reconnectTimeout) {
      clearTimeout(this.reconnectTimeout)
    }
    this.stopHeartbeat()
    this.ws?.close()
  }
}

// ì „ì—­ WebSocket ë§¤ë‹ˆì € ì¸ìŠ¤í„´ìŠ¤
export const wsManager = new WebSocketManager(
  process.env.NEXT_PUBLIC_WS_ENDPOINT || 'ws://localhost:4000/graphql'
)
```

### **4. ë‚™ê´€ì  ì—…ë°ì´íŠ¸ ë° ì¶©ëŒ í•´ê²°**

**ë‚™ê´€ì  ì—…ë°ì´íŠ¸ ì‹œìŠ¤í…œ**
```typescript
// src/hooks/useOptimisticSchedule.ts
export const useOptimisticSchedule = () => {
  const [updateSchedule] = useUpdateScheduleMutation()
  const { addToOfflineQueue, isConnected } = useSyncStore()
  
  const optimisticUpdate = useCallback(async (
    scheduleId: string,
    updates: Partial<Schedule>,
    optimisticData?: Partial<Schedule>
  ) => {
    // 1. ì¦‰ì‹œ UI ì—…ë°ì´íŠ¸ (ë‚™ê´€ì )
    apolloClient.cache.writeFragment({
      id: `Schedule:${scheduleId}`,
      fragment: SCHEDULE_FRAGMENT,
      data: {
        id: scheduleId,
        ...optimisticData,
        version: (optimisticData?.version || 0) + 1,
        __typename: 'Schedule'
      }
    })
    
    // 2. ì„œë²„ ìš”ì²­
    if (isConnected) {
      try {
        const result = await updateSchedule({
          variables: { 
            id: scheduleId, 
            input: updates,
            version: optimisticData?.version || 0
          },
          optimisticResponse: {
            updateSchedule: {
              __typename: 'Schedule',
              id: scheduleId,
              ...optimisticData,
              version: (optimisticData?.version || 0) + 1
            }
          },
          update: (cache, { data }) => {
            if (data?.updateSchedule) {
              cache.writeFragment({
                id: `Schedule:${scheduleId}`,
                fragment: SCHEDULE_FRAGMENT,
                data: data.updateSchedule
              })
            }
          },
          errorPolicy: 'all'
        })
        
        // ì„œë²„ ì‘ë‹µìœ¼ë¡œ ìµœì¢… ì—…ë°ì´íŠ¸
        if (result.data?.updateSchedule) {
          apolloClient.cache.writeFragment({
            id: `Schedule:${scheduleId}`,
            fragment: SCHEDULE_FRAGMENT,
            data: result.data.updateSchedule
          })
        }
        
      } catch (error) {
        // ì¶©ëŒ ë˜ëŠ” ì—ëŸ¬ ë°œìƒ ì‹œ ì²˜ë¦¬
        if (error.graphQLErrors?.some(e => e.extensions?.code === 'CONFLICT')) {
          // ì¶©ëŒ í•´ê²° ë¡œì§
          handleVersionConflict(scheduleId, error)
        } else {
          // ì¼ë°˜ ì—ëŸ¬ - ì›ë˜ ë°ì´í„°ë¡œ ë˜ëŒë¦¬ê¸°
          rollbackOptimisticUpdate(scheduleId)
          showToast('error', 'ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤')
        }
      }
    } else {
      // ì˜¤í”„ë¼ì¸ - íì— ì¶”ê°€
      addToOfflineQueue({
        type: 'UPDATE_SCHEDULE',
        entityId: scheduleId,
        data: updates,
        optimisticData
      })
    }
  }, [updateSchedule, addToOfflineQueue, isConnected])
  
  const rollbackOptimisticUpdate = useCallback((scheduleId: string) => {
    // ì„œë²„ì—ì„œ ìµœì‹  ë°ì´í„° ë‹¤ì‹œ ê°€ì ¸ì™€ì„œ ìºì‹œ ì—…ë°ì´íŠ¸
    apolloClient.refetchQueries({
      include: [{ query: GET_SCHEDULE, variables: { id: scheduleId } }]
    })
  }, [])
  
  const handleVersionConflict = useCallback(async (
    scheduleId: string, 
    error: ApolloError
  ) => {
    const conflictInfo = error.graphQLErrors[0]?.extensions?.conflictInfo
    
    // ì„œë²„ì˜ ìµœì‹  ë²„ì „ ê°€ì ¸ì˜¤ê¸°
    const { data } = await apolloClient.query({
      query: GET_SCHEDULE,
      variables: { id: scheduleId },
      fetchPolicy: 'network-only'
    })
    
    const serverSchedule = data.schedule
    const cachedSchedule = apolloClient.cache.readFragment({
      id: `Schedule:${scheduleId}`,
      fragment: SCHEDULE_FRAGMENT
    })
    
    // ì¶©ëŒ í•´ê²° ëª¨ë‹¬ í‘œì‹œ
    const { openModal } = useUIStore.getState()
    const { addConflict } = useSyncStore.getState()
    
    const conflict: ConflictData = {
      entityId: scheduleId,
      entityType: 'Schedule',
      localVersion: cachedSchedule,
      serverVersion: serverSchedule,
      conflictType: 'version',
      timestamp: new Date().toISOString()
    }
    
    addConflict(scheduleId, conflict)
    openModal('conflictResolution', { conflicts: [conflict] })
  }, [])
  
  return {
    optimisticUpdate,
    rollbackOptimisticUpdate,
    handleVersionConflict
  }
}
```

### **5. ì¶©ëŒ í•´ê²° UI ì»´í¬ë„ŒíŠ¸**

**ì¶©ëŒ í•´ê²° ë‹¤ì´ì–¼ë¡œê·¸**
```typescript
// src/components/sync/ConflictResolutionModal.tsx
const ConflictResolutionModal = () => {
  const { modals, closeModal } = useUIStore()
  const { conflicts, resolveConflict } = useSyncStore()
  const { optimisticUpdate } = useOptimisticSchedule()
  
  const isOpen = modals.conflictResolution.open
  const conflictList = modals.conflictResolution.conflicts || []
  
  const [selectedResolutions, setSelectedResolutions] = useState<Map<string, ConflictResolution>>(new Map())
  
  const handleResolveConflict = async (entityId: string, resolution: ConflictResolution) => {
    const conflict = conflicts.get(entityId)
    if (!conflict) return
    
    switch (resolution.type) {
      case 'use_local':
        // ë¡œì»¬ ë²„ì „ ì‚¬ìš©
        await optimisticUpdate(
          entityId,
          conflict.localVersion,
          conflict.localVersion
        )
        break
        
      case 'use_server':
        // ì„œë²„ ë²„ì „ ì‚¬ìš©
        apolloClient.cache.writeFragment({
          id: `Schedule:${entityId}`,
          fragment: SCHEDULE_FRAGMENT,
          data: conflict.serverVersion
        })
        break
        
      case 'merge':
        // ìˆ˜ë™ ë³‘í•©
        const mergedData = resolution.mergedData
        await optimisticUpdate(entityId, mergedData, mergedData)
        break
    }
    
    resolveConflict(entityId, resolution)
  }
  
  const handleResolveAll = async () => {
    for (const [entityId, resolution] of selectedResolutions) {
      await handleResolveConflict(entityId, resolution)
    }
    closeModal('conflictResolution')
  }
  
  return (
    <Dialog open={isOpen} onOpenChange={() => closeModal('conflictResolution')}>
      <DialogContent className="max-w-4xl max-h-[80vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>ì¶©ëŒ í•´ê²°</DialogTitle>
          <DialogDescription>
            ë™ì‹œì— í¸ì§‘ëœ í•­ëª©ë“¤ì´ ìˆìŠµë‹ˆë‹¤. ì–´ë–¤ ë²„ì „ì„ ì‚¬ìš©í• ì§€ ì„ íƒí•´ì£¼ì„¸ìš”.
          </DialogDescription>
        </DialogHeader>
        
        <div className="space-y-6">
          {conflictList.map((conflict) => (
            <div key={conflict.entityId} className="border rounded-lg p-4 space-y-4">
              <div className="flex items-center gap-2">
                <AlertTriangle className="w-5 h-5 text-destructive" />
                <h3 className="font-semibold">
                  {conflict.entityType}: {conflict.localVersion.title || conflict.entityId}
                </h3>
              </div>
              
              <div className="grid grid-cols-2 gap-4">
                {/* ë¡œì»¬ ë²„ì „ */}
                <div className="space-y-2">
                  <div className="flex items-center gap-2">
                    <User className="w-4 h-4" />
                    <span className="font-medium text-blue-600">ë‚´ ë²„ì „</span>
                  </div>
                  <div className="bg-blue-50 border border-blue-200 rounded p-3">
                    <ScheduleConflictPreview schedule={conflict.localVersion} />
                  </div>
                  <Button
                    variant="outline"
                    size="sm"
                    className="w-full"
                    onClick={() => setSelectedResolutions(prev => 
                      new Map(prev).set(conflict.entityId, { type: 'use_local' })
                    )}
                  >
                    ì´ ë²„ì „ ì‚¬ìš©
                  </Button>
                </div>
                
                {/* ì„œë²„ ë²„ì „ */}
                <div className="space-y-2">
                  <div className="flex items-center gap-2">
                    <Server className="w-4 h-4" />
                    <span className="font-medium text-green-600">ì„œë²„ ë²„ì „</span>
                  </div>
                  <div className="bg-green-50 border border-green-200 rounded p-3">
                    <ScheduleConflictPreview schedule={conflict.serverVersion} />
                  </div>
                  <Button
                    variant="outline"
                    size="sm"
                    className="w-full"
                    onClick={() => setSelectedResolutions(prev => 
                      new Map(prev).set(conflict.entityId, { type: 'use_server' })
                    )}
                  >
                    ì´ ë²„ì „ ì‚¬ìš©
                  </Button>
                </div>
              </div>
              
              {/* ìˆ˜ë™ ë³‘í•© ì˜µì…˜ */}
              <Collapsible>
                <CollapsibleTrigger className="flex items-center gap-2 text-sm text-muted-foreground hover:text-foreground">
                  <Settings className="w-4 h-4" />
                  ìˆ˜ë™ìœ¼ë¡œ ë³‘í•©í•˜ê¸°
                  <ChevronRight className="w-4 h-4 transition-transform data-[state=open]:rotate-90" />
                </CollapsibleTrigger>
                <CollapsibleContent className="mt-2">
                  <ConflictMergeEditor
                    conflict={conflict}
                    onMerged={(mergedData) => 
                      setSelectedResolutions(prev => 
                        new Map(prev).set(conflict.entityId, { 
                          type: 'merge', 
                          mergedData 
                        })
                      )
                    }
                  />
                </CollapsibleContent>
              </Collapsible>
            </div>
          ))}
        </div>
        
        <DialogFooter>
          <Button variant="outline" onClick={() => closeModal('conflictResolution')}>
            ë‚˜ì¤‘ì—
          </Button>
          <Button 
            onClick={handleResolveAll}
            disabled={selectedResolutions.size === 0}
          >
            {selectedResolutions.size}ê°œ ì¶©ëŒ í•´ê²°
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  )
}

// ì¶©ëŒ ë¯¸ë¦¬ë³´ê¸° ì»´í¬ë„ŒíŠ¸
const ScheduleConflictPreview = ({ schedule }: { schedule: Schedule }) => {
  const projectColor = PROJECT_COLORS[schedule.project?.color || 'blue']
  
  return (
    <div className="space-y-2">
      <div className="flex items-center gap-2">
        <div 
          className="w-3 h-3 rounded-full"
          style={{ backgroundColor: projectColor.primary }}
        />
        <span className="font-medium text-sm">{schedule.title}</span>
      </div>
      <div className="text-xs text-muted-foreground space-y-1">
        <div>ì‹œê°„: {formatTimeRange(schedule.startDateTime, schedule.endDateTime)}</div>
        {schedule.description && <div>ì„¤ëª…: {schedule.description}</div>}
        {schedule.location && <div>ì¥ì†Œ: {schedule.location}</div>}
        <div>ìˆ˜ì •: {format(parseISO(schedule.updatedAt), 'MM/dd HH:mm')}</div>
      </div>
    </div>
  )
}
```

---

## ğŸ¨ **ì‚¬ìš©ì ê²½í—˜ (UX) ì„¤ê³„**

### **1. ì‹¤ì‹œê°„ í˜‘ì—… í‘œì‹œ**

**í™œì„± ì‚¬ìš©ì ë° ì‹¤ì‹œê°„ ë³€ê²½ì‚¬í•­ í‘œì‹œ**
```typescript
// src/components/sync/RealtimeIndicator.tsx
const RealtimeIndicator = () => {
  const { isConnected, connectionQuality, activeUsers, syncInProgress } = useSyncStore()
  const [recentChanges, setRecentChanges] = useState<RecentChange[]>([])
  
  return (
    <div className="flex items-center gap-2 text-sm">
      {/* ì—°ê²° ìƒíƒœ í‘œì‹œ */}
      <div className="flex items-center gap-1">
        <div className={cn(
          "w-2 h-2 rounded-full",
          isConnected ? "bg-green-500" : "bg-red-500",
          connectionQuality === 'poor' && "bg-yellow-500"
        )} />
        <span className="text-xs text-muted-foreground">
          {isConnected ? 'ì‹¤ì‹œê°„ ë™ê¸°í™”' : 'ì˜¤í”„ë¼ì¸'}
        </span>
      </div>
      
      {/* ë™ê¸°í™” ì§„í–‰ í‘œì‹œ */}
      {syncInProgress && (
        <div className="flex items-center gap-1">
          <Loader2 className="w-3 h-3 animate-spin" />
          <span className="text-xs text-muted-foreground">ë™ê¸°í™” ì¤‘...</span>
        </div>
      )}
      
      {/* í™œì„± ì‚¬ìš©ì í‘œì‹œ */}
      {activeUsers.length > 0 && (
        <div className="flex items-center gap-1">
          <Users className="w-3 h-3" />
          <span className="text-xs text-muted-foreground">
            {activeUsers.length}ëª… ì˜¨ë¼ì¸
          </span>
        </div>
      )}
      
      {/* ìµœê·¼ ë³€ê²½ì‚¬í•­ ì•Œë¦¼ */}
      <Popover>
        <PopoverTrigger asChild>
          <Button variant="ghost" size="sm" className="h-6 px-2">
            <Bell className="w-3 h-3" />
            {recentChanges.length > 0 && (
              <Badge variant="destructive" className="w-1 h-1 p-0 ml-1" />
            )}
          </Button>
        </PopoverTrigger>
        <PopoverContent className="w-80">
          <div className="space-y-2">
            <h4 className="font-medium text-sm">ìµœê·¼ ë³€ê²½ì‚¬í•­</h4>
            {recentChanges.length === 0 ? (
              <p className="text-xs text-muted-foreground">ë³€ê²½ì‚¬í•­ì´ ì—†ìŠµë‹ˆë‹¤</p>
            ) : (
              <div className="space-y-1 max-h-60 overflow-y-auto">
                {recentChanges.map(change => (
                  <div key={change.id} className="text-xs p-2 bg-muted rounded">
                    <div className="font-medium">{change.title}</div>
                    <div className="text-muted-foreground">
                      {change.userName} â€¢ {formatDistanceToNow(parseISO(change.timestamp), { addSuffix: true })}
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>
        </PopoverContent>
      </Popover>
    </div>
  )
}
```

### **2. ì˜¤í”„ë¼ì¸ ì§€ì› UI**

**ì˜¤í”„ë¼ì¸ ìƒíƒœ í‘œì‹œ ë° í ê´€ë¦¬**
```typescript
// src/components/sync/OfflineQueueManager.tsx
const OfflineQueueManager = () => {
  const { offlineQueue, syncInProgress, isConnected, processOfflineQueue } = useSyncStore()
  const [showQueue, setShowQueue] = useState(false)
  
  // ì˜¨ë¼ì¸ ë³µê·€ ì‹œ ìë™ ë™ê¸°í™”
  useEffect(() => {
    if (isConnected && offlineQueue.length > 0 && !syncInProgress) {
      const timer = setTimeout(() => {
        processOfflineQueue()
      }, 1000) // 1ì´ˆ í›„ ìë™ ë™ê¸°í™”
      
      return () => clearTimeout(timer)
    }
  }, [isConnected, offlineQueue.length, syncInProgress])
  
  if (offlineQueue.length === 0) return null
  
  return (
    <div className="fixed bottom-4 right-4 z-50">
      <Card className="bg-orange-50 border-orange-200">
        <CardContent className="p-4">
          <div className="flex items-center gap-2 mb-2">
            <WifiOff className="w-4 h-4 text-orange-600" />
            <span className="font-medium text-sm text-orange-800">
              ì˜¤í”„ë¼ì¸ ë³€ê²½ì‚¬í•­ {offlineQueue.length}ê°œ
            </span>
          </div>
          
          <div className="flex items-center gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={() => setShowQueue(!showQueue)}
            >
              {showQueue ? 'ìˆ¨ê¸°ê¸°' : 'ë³´ê¸°'}
            </Button>
            
            <Button
              size="sm"
              onClick={processOfflineQueue}
              disabled={!isConnected || syncInProgress}
            >
              {syncInProgress ? (
                <>
                  <Loader2 className="w-3 h-3 animate-spin mr-1" />
                  ë™ê¸°í™” ì¤‘
                </>
              ) : (
                'ì§€ê¸ˆ ë™ê¸°í™”'
              )}
            </Button>
          </div>
          
          {showQueue && (
            <div className="mt-3 space-y-1 max-h-40 overflow-y-auto">
              {offlineQueue.map(action => (
                <div key={action.id} className="text-xs p-2 bg-white rounded border">
                  <div className="font-medium">
                    {action.type === 'CREATE_SCHEDULE' && 'ì¼ì • ìƒì„±'}
                    {action.type === 'UPDATE_SCHEDULE' && 'ì¼ì • ìˆ˜ì •'}
                    {action.type === 'DELETE_SCHEDULE' && 'ì¼ì • ì‚­ì œ'}
                  </div>
                  <div className="text-muted-foreground">
                    {format(action.timestamp, 'MM/dd HH:mm')}
                  </div>
                </div>
              ))}
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  )
}
```

---

## ğŸ“Š **ì„±ëŠ¥ ìµœì í™”**

### **ë©”ëª¨ë¦¬ ê´€ë¦¬ ë° ìºì‹œ ìµœì í™”**
```typescript
// src/lib/performance/cacheOptimization.ts
export class CacheOptimizer {
  private static cacheCleanupInterval: NodeJS.Timeout | null = null
  
  static initialize() {
    // 5ë¶„ë§ˆë‹¤ ìºì‹œ ì •ë¦¬
    this.cacheCleanupInterval = setInterval(() => {
      this.cleanupExpiredCache()
      this.optimizeMemoryUsage()
    }, 5 * 60 * 1000)
  }
  
  private static cleanupExpiredCache() {
    const cache = apolloClient.cache as InMemoryCache
    
    // ì˜¤ë˜ëœ ì¿¼ë¦¬ ê²°ê³¼ ì œê±°
    const expiredQueries = cache.extract().ROOT_QUERY
    Object.keys(expiredQueries).forEach(key => {
      if (key.startsWith('schedules') && this.isCacheExpired(key)) {
        cache.evict({ fieldName: key })
      }
    })
    
    // ê°€ë¹„ì§€ ì»¬ë ‰ì…˜
    cache.gc()
  }
  
  private static optimizeMemoryUsage() {
    const { schedules } = useScheduleStore.getState()
    const currentDateRange = useUIStore.getState().filters.dateRange
    
    // í˜„ì¬ ë·° ë²”ìœ„ ë°–ì˜ ìŠ¤ì¼€ì¤„ ë°ì´í„° ì •ë¦¬
    const expiredSchedules: string[] = []
    schedules.forEach((schedule, id) => {
      const scheduleDate = parseISO(schedule.startDateTime)
      if (
        isBefore(scheduleDate, subMonths(currentDateRange.start, 1)) ||
        isAfter(scheduleDate, addMonths(currentDateRange.end, 1))
      ) {
        expiredSchedules.push(id)
      }
    })
    
    // ë§Œë£Œëœ ìŠ¤ì¼€ì¤„ ìºì‹œì—ì„œ ì œê±°
    expiredSchedules.forEach(id => {
      apolloClient.cache.evict({ id: `Schedule:${id}` })
    })
  }
  
  private static isCacheExpired(cacheKey: string): boolean {
    // ìºì‹œ í‚¤ì—ì„œ íƒ€ì„ìŠ¤íƒ¬í”„ ì¶”ì¶œí•˜ì—¬ ë§Œë£Œ ì—¬ë¶€ í™•ì¸
    // êµ¬í˜„ì€ ì‹¤ì œ ìºì‹œ í‚¤ êµ¬ì¡°ì— ë”°ë¼ ë‹¬ë¼ì§
    return false // êµ¬í˜„ í•„ìš”
  }
  
  static destroy() {
    if (this.cacheCleanupInterval) {
      clearInterval(this.cacheCleanupInterval)
    }
  }
}

// ì„±ëŠ¥ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
export const trackStatePerformance = () => {
  // Zustand ìƒíƒœ ë³€ê²½ ì¶”ì 
  useUIStore.subscribe(
    (state) => state.filters,
    (filters, prevFilters) => {
      performance.mark('filter-change-start')
      // í•„í„° ë³€ê²½ ì™„ë£Œ í›„
      requestIdleCallback(() => {
        performance.mark('filter-change-end')
        performance.measure('filter-change', 'filter-change-start', 'filter-change-end')
        
        const measure = performance.getEntriesByName('filter-change')[0]
        PerformanceMonitor.recordMetric('filter-change-duration', measure.duration)
      })
    }
  )
  
  // Apollo ì¿¼ë¦¬ ì„±ëŠ¥ ì¶”ì 
  const link = ApolloLink.from([
    new ApolloLink((operation, forward) => {
      const startTime = Date.now()
      
      return forward(operation).map((result) => {
        const duration = Date.now() - startTime
        PerformanceMonitor.recordMetric(`graphql-${operation.operationName}`, duration)
        
        return result
      })
    })
  ])
}
```

---

## âœ… **Definition of Done**

### **ê¸°ëŠ¥ ìš”êµ¬ì‚¬í•­**
- [ ] Apollo Client + Zustand í•˜ì´ë¸Œë¦¬ë“œ ìƒíƒœ ê´€ë¦¬ ì‹œìŠ¤í…œ
- [ ] WebSocket ê¸°ë°˜ ì‹¤ì‹œê°„ ì–‘ë°©í–¥ ë™ê¸°í™”
- [ ] ë‚™ê´€ì  ì—…ë°ì´íŠ¸ ë° ìë™ ì¶©ëŒ í•´ê²°
- [ ] ì˜¤í”„ë¼ì¸ ì§€ì› ë° ìë™ ë™ê¸°í™” í
- [ ] í™œì„± ì‚¬ìš©ì í‘œì‹œ ë° ì‹¤ì‹œê°„ í˜‘ì—… ì§€ì›

### **ê¸°ìˆ  ìš”êµ¬ì‚¬í•­**
- [ ] Apollo InMemoryCache ì •ê·œí™” ë° ìºì‹œ ì •ì±… êµ¬í˜„
- [ ] Zustand devtools ë° persist ë¯¸ë“¤ì›¨ì–´ ì ìš©
- [ ] WebSocket ì¬ì—°ê²° ë° í•˜íŠ¸ë¹„íŠ¸ ì‹œìŠ¤í…œ
- [ ] ë²„ì „ ê¸°ë°˜ ì¶©ëŒ ê°ì§€ ë° í•´ê²°
- [ ] GraphQL êµ¬ë…ì„ í†µí•œ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸

### **ì„±ëŠ¥ ìš”êµ¬ì‚¬í•­**
- [ ] ìƒíƒœ ë³€ê²½ ì‘ë‹µì‹œê°„ 50ms ì´í•˜
- [ ] WebSocket ë©”ì‹œì§€ ì²˜ë¦¬ 10ms ì´í•˜
- [ ] ìºì‹œ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ 50MB ì´í•˜
- [ ] ì˜¤í”„ë¼ì¸ í ì²˜ë¦¬ ì‹œê°„ 2ì´ˆ ì´í•˜

### **ì ‘ê·¼ì„± ìš”êµ¬ì‚¬í•­**
- [ ] ì‹¤ì‹œê°„ ë³€ê²½ì‚¬í•­ ìŠ¤í¬ë¦° ë¦¬ë” ì•Œë¦¼
- [ ] í‚¤ë³´ë“œë¡œ ì¶©ëŒ í•´ê²° ë‹¤ì´ì–¼ë¡œê·¸ ì¡°ì‘ ê°€ëŠ¥
- [ ] ì—°ê²° ìƒíƒœ ì‹œê°ì /ì²­ê°ì  í”¼ë“œë°±
- [ ] ê³ ëŒ€ë¹„ ëª¨ë“œì—ì„œ ìƒíƒœ í‘œì‹œ ëª…í™•ì„±

### **ë³´ì•ˆ ìš”êµ¬ì‚¬í•­**
- [ ] WebSocket ì¸ì¦ í† í° ê²€ì¦
- [ ] ë¯¼ê° ì •ë³´ ìºì‹œ ì•”í˜¸í™”
- [ ] ì¶©ëŒ í•´ê²° ê¶Œí•œ ê²€ì¦
- [ ] ì‹¤ì‹œê°„ ë°ì´í„° ë¬´ê²°ì„± ê²€ì¦

### **í…ŒìŠ¤íŠ¸ ìš”êµ¬ì‚¬í•­**
- [ ] Jestë¥¼ í†µí•œ ìƒíƒœ ê´€ë¦¬ ë¡œì§ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
- [ ] WebSocket ì—°ê²° ë° ì¬ì—°ê²° ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸
- [ ] ì¶©ëŒ í•´ê²° í”Œë¡œìš° E2E í…ŒìŠ¤íŠ¸
- [ ] ì˜¤í”„ë¼ì¸/ì˜¨ë¼ì¸ ì „í™˜ í…ŒìŠ¤íŠ¸

---

## ğŸ“š **ê´€ë ¨ ë¬¸ì„œ ì°¸ì¡°**

- [04. ìƒíƒœ ê´€ë¦¬](../ui-architecture/04-state-management.md)
- [15. ì‹¤ì‹œê°„ WebSocket ë™ê¸°í™”](../ui-architecture/15-realtime-websocket-sync.md)
- [19. ì„œë²„ ìƒíƒœ ê´€ë¦¬ ì›ì¹™](../ui-architecture/19-server-state-management.md)
- [20. í‘œì¤€ ì—ëŸ¬ í¬ë§· ë° í•¸ë“¤ë§](../ui-architecture/20-error-handling.md)
- [21. Observability ë° ëª¨ë‹ˆí„°ë§](../ui-architecture/21-observability-monitoring.md)

---

**ì´ ìŠ¤í† ë¦¬ëŠ” ë°”ë¡œìº˜ë¦°ë”ì˜ í•µì‹¬ ìƒíƒœ ê´€ë¦¬ ë° ì‹¤ì‹œê°„ í˜‘ì—… ê¸°ëŠ¥ì„ ì™„ì „í•˜ê²Œ êµ¬í˜„í•˜ê¸° ìœ„í•œ ì¢…í•©ì ì¸ ê¸°ìˆ  ê°€ì´ë“œì…ë‹ˆë‹¤. Apollo Clientì™€ Zustandì˜ ìµœì  ì¡°í•©ìœ¼ë¡œ í™•ì¥ ê°€ëŠ¥í•˜ê³  ì„±ëŠ¥ ìµœì í™”ëœ ìƒíƒœ ê´€ë¦¬ ì‹œìŠ¤í…œì„ êµ¬ì¶•í•©ë‹ˆë‹¤.**