# Story 2.8: ë³´ì•ˆ ëª¨ë²” ì‚¬ë¡€ êµ¬í˜„

## ğŸ“‹ ë¬¸ì„œ ì •ë³´
- **ìŠ¤í† ë¦¬ ë²„ì „**: 2.0
- **ì‘ì„±ì¼**: 2025-08-28
- **ì‘ì„±ì**: Bob (Scrum Master Agent)  
- **í”„ë¡œì íŠ¸ëª…**: ë°”ë¡œìº˜ë¦°ë” (Baro Calendar)
- **Epic**: í”„ë¡ íŠ¸ì—”ë“œ ë³´ì•ˆ ê°•í™”
- **ìƒíƒœ**: Ready for Development

---

## ğŸ¯ **ìŠ¤í† ë¦¬ ëª©í‘œ**

**ì™„ì „í•œ í”„ë¡ íŠ¸ì—”ë“œ ë³´ì•ˆ ì‹œìŠ¤í…œ êµ¬í˜„**
- XSS/CSRF ë°©ì–´ ë©”ì»¤ë‹ˆì¦˜
- ì•ˆì „í•œ ì¸ì¦ ë° í† í° ê´€ë¦¬
- ë°ì´í„° ì•”í˜¸í™” ë° ê²€ì¦
- Content Security Policy êµ¬í˜„
- ë³´ì•ˆ ì·¨ì•½ì  ìŠ¤ìº” ìë™í™”

---

## ğŸ‘¤ **ì‚¬ìš©ì ìŠ¤í† ë¦¬**

**ì‚¬ìš©ìë¡œì„œ, ë‚˜ëŠ”:**
1. ê°œì¸ ë°ì´í„°ê°€ ì•ˆì „í•˜ê²Œ ë³´í˜¸ë˜ê¸°ë¥¼ ì›í•œë‹¤
2. ì„¸ì…˜ í•˜ì´ì¬í‚¹ì´ë‚˜ ê³„ì • íƒˆì·¨ë¥¼ ë‹¹í•˜ì§€ ì•Šê³  ì‹¶ë‹¤
3. ì•…ì˜ì ì¸ ìŠ¤í¬ë¦½íŠ¸ë¡œë¶€í„° ë³´í˜¸ë°›ê³  ì‹¶ë‹¤
4. ë¯¼ê°í•œ ì •ë³´ê°€ ì•”í˜¸í™”ë˜ì–´ ì „ì†¡ë˜ê¸°ë¥¼ ì›í•œë‹¤
5. ë³´ì•ˆ ì‚¬ê³  ë°œìƒ ì‹œ ì¦‰ì‹œ ì•Œë¦¼ì„ ë°›ê³  ì‹¶ë‹¤

---

## ğŸ—ï¸ **ê¸°ìˆ ì  êµ¬í˜„ ìš”êµ¬ì‚¬í•­**

### **1. XSS ë°©ì–´ ì‹œìŠ¤í…œ**

**XSS ë°©ì–´ ë° ì…ë ¥ ê²€ì¦**
```typescript
// src/lib/security/xss-protection.ts
import DOMPurify from 'dompurify'

export class XSSProtection {
  // HTML ì½˜í…ì¸  sanitization
  static sanitizeHTML(html: string, options?: {
    allowedTags?: string[]
    allowedAttributes?: Record<string, string[]>
  }): string {
    const config = {
      ALLOWED_TAGS: options?.allowedTags || [
        'b', 'i', 'u', 'strong', 'em', 'p', 'br', 'ul', 'ol', 'li'
      ],
      ALLOWED_ATTR: options?.allowedAttributes || {
        'a': ['href', 'title'],
        'img': ['src', 'alt']
      },
      FORBID_SCRIPT: true,
      FORBID_TAGS: ['script', 'object', 'embed', 'form'],
      FORBID_ATTR: ['onerror', 'onload', 'onclick']
    }
    
    return DOMPurify.sanitize(html, config)
  }

  // ì‚¬ìš©ì ì…ë ¥ ê²€ì¦
  static validateUserInput(input: string, type: 'text' | 'email' | 'url' | 'filename'): {
    isValid: boolean
    sanitized: string
    errors: string[]
  } {
    const errors: string[] = []
    let sanitized = input.trim()

    // ê¸°ë³¸ XSS íŒ¨í„´ ê²€ì‚¬
    const xssPatterns = [
      /<script[^>]*>.*?<\/script>/gi,
      /javascript:/gi,
      /on\w+\s*=/gi,
      /<iframe[^>]*>.*?<\/iframe>/gi,
      /data:text\/html/gi
    ]

    for (const pattern of xssPatterns) {
      if (pattern.test(sanitized)) {
        errors.push('Potentially malicious content detected')
        break
      }
    }

    // íƒ€ì…ë³„ ê²€ì¦
    switch (type) {
      case 'email':
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
        if (!emailRegex.test(sanitized)) {
          errors.push('Invalid email format')
        }
        break

      case 'url':
        try {
          const url = new URL(sanitized)
          if (!['http:', 'https:'].includes(url.protocol)) {
            errors.push('Only HTTP/HTTPS URLs are allowed')
          }
        } catch {
          errors.push('Invalid URL format')
        }
        break

      case 'filename':
        const dangerousChars = /[<>:"/\\|?*\x00-\x1f]/
        if (dangerousChars.test(sanitized)) {
          errors.push('Filename contains invalid characters')
        }
        break

      case 'text':
        // SQL Injection íŒ¨í„´ ê²€ì‚¬
        const sqlPatterns = [
          /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|UNION)\b)/gi,
          /('|(\\)|;|--|\||`)/g
        ]
        
        for (const pattern of sqlPatterns) {
          if (pattern.test(sanitized)) {
            errors.push('Potentially malicious SQL pattern detected')
            break
          }
        }
        break
    }

    // HTML ì—”ì½”ë”©
    sanitized = sanitized
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#x27;')

    return {
      isValid: errors.length === 0,
      sanitized,
      errors
    }
  }

  // React ì»´í¬ë„ŒíŠ¸ìš© ì•ˆì „í•œ HTML ë Œë”ë§
  static createSafeHTML(html: string) {
    return {
      __html: this.sanitizeHTML(html)
    }
  }
}

// React Hook for input validation
export const useSecureInput = () => {
  const validateAndSanitize = useCallback((
    input: string,
    type: Parameters<typeof XSSProtection.validateUserInput>[1]
  ) => {
    return XSSProtection.validateUserInput(input, type)
  }, [])

  return { validateAndSanitize }
}

// Secure Input Component
interface SecureInputProps extends React.InputHTMLAttributes<HTMLInputElement> {
  validationType?: 'text' | 'email' | 'url' | 'filename'
  onValidationChange?: (isValid: boolean, errors: string[]) => void
}

export const SecureInput: React.FC<SecureInputProps> = ({
  validationType = 'text',
  onValidationChange,
  onChange,
  ...props
}) => {
  const { validateAndSanitize } = useSecureInput()
  const [validationErrors, setValidationErrors] = useState<string[]>([])

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { isValid, sanitized, errors } = validateAndSanitize(e.target.value, validationType)
    
    setValidationErrors(errors)
    onValidationChange?.(isValid, errors)

    // ì•ˆì „í•œ ê°’ìœ¼ë¡œ ì´ë²¤íŠ¸ ì—…ë°ì´íŠ¸
    const sanitizedEvent = {
      ...e,
      target: {
        ...e.target,
        value: sanitized
      }
    }
    
    onChange?.(sanitizedEvent)
  }

  return (
    <div>
      <input
        {...props}
        onChange={handleChange}
        className={cn(props.className, validationErrors.length > 0 && 'border-destructive')}
      />
      {validationErrors.length > 0 && (
        <div className="text-sm text-destructive mt-1">
          {validationErrors.map((error, index) => (
            <div key={index}>{error}</div>
          ))}
        </div>
      )}
    </div>
  )
}
```

### **2. CSRF ë°©ì–´ ì‹œìŠ¤í…œ**

**CSRF í† í° ê´€ë¦¬**
```typescript
// src/lib/security/csrf-protection.ts
export class CSRFProtection {
  private static tokenKey = 'csrf-token'
  private static headerName = 'X-CSRF-Token'

  // CSRF í† í° ìƒì„±
  static generateToken(): string {
    const array = new Uint8Array(32)
    crypto.getRandomValues(array)
    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('')
  }

  // í† í° ì €ì¥
  static setToken(token: string): void {
    sessionStorage.setItem(this.tokenKey, token)
    
    // ë©”íƒ€ íƒœê·¸ì—ë„ ì„¤ì • (ì„œë²„ì—ì„œ ì´ˆê¸° ì„¤ì •ëœ í† í° ì‚¬ìš©)
    let metaTag = document.querySelector('meta[name="csrf-token"]') as HTMLMetaElement
    if (!metaTag) {
      metaTag = document.createElement('meta')
      metaTag.name = 'csrf-token'
      document.head.appendChild(metaTag)
    }
    metaTag.content = token
  }

  // í† í° ì¡°íšŒ
  static getToken(): string | null {
    // ì„¸ì…˜ ìŠ¤í† ë¦¬ì§€ì—ì„œ ë¨¼ì € í™•ì¸
    let token = sessionStorage.getItem(this.tokenKey)
    
    // ì—†ìœ¼ë©´ ë©”íƒ€ íƒœê·¸ì—ì„œ í™•ì¸
    if (!token) {
      const metaTag = document.querySelector('meta[name="csrf-token"]') as HTMLMetaElement
      token = metaTag?.content || null
    }
    
    return token
  }

  // HTTP ìš”ì²­ì— CSRF í† í° ì¶”ê°€
  static addTokenToHeaders(headers: HeadersInit = {}): HeadersInit {
    const token = this.getToken()
    if (!token) {
      console.warn('CSRF token not found')
      return headers
    }

    return {
      ...headers,
      [this.headerName]: token
    }
  }

  // í¼ì— CSRF í† í° ì¶”ê°€
  static addTokenToForm(formData: FormData): FormData {
    const token = this.getToken()
    if (token) {
      formData.append('_csrf', token)
    }
    return formData
  }

  // í† í° ìœ íš¨ì„± ê²€ì¦
  static async validateToken(token: string): Promise<boolean> {
    try {
      const response = await fetch('/api/csrf/validate', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          ...this.addTokenToHeaders()
        },
        body: JSON.stringify({ token })
      })
      
      return response.ok
    } catch (error) {
      console.error('CSRF token validation failed:', error)
      return false
    }
  }
}

// HTTP í´ë¼ì´ì–¸íŠ¸ì— CSRF ë³´í˜¸ í†µí•©
export const secureApiClient = {
  async request<T>(url: string, options: RequestInit = {}): Promise<T> {
    const headers = CSRFProtection.addTokenToHeaders(options.headers)
    
    const response = await fetch(url, {
      ...options,
      headers,
      credentials: 'same-origin' // CSRF ë°©ì–´ë¥¼ ìœ„í•´ same-originë§Œ í—ˆìš©
    })

    // CSRF í† í° ë§Œë£Œ ì‹œ ìƒˆ í† í° ìš”ì²­
    if (response.status === 403) {
      const newToken = await this.refreshCSRFToken()
      if (newToken) {
        const retryHeaders = CSRFProtection.addTokenToHeaders(options.headers)
        const retryResponse = await fetch(url, {
          ...options,
          headers: retryHeaders
        })
        
        if (retryResponse.ok) {
          return retryResponse.json()
        }
      }
    }

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`)
    }

    return response.json()
  },

  async refreshCSRFToken(): Promise<string | null> {
    try {
      const response = await fetch('/api/csrf/token', {
        method: 'GET',
        credentials: 'same-origin'
      })
      
      if (response.ok) {
        const { token } = await response.json()
        CSRFProtection.setToken(token)
        return token
      }
    } catch (error) {
      console.error('Failed to refresh CSRF token:', error)
    }
    
    return null
  }
}

// React Hook for CSRF protection
export const useCSRFProtection = () => {
  const [token, setToken] = useState<string | null>(null)

  useEffect(() => {
    // ì»´í¬ë„ŒíŠ¸ ë§ˆìš´íŠ¸ ì‹œ í† í° ì´ˆê¸°í™”
    const initToken = async () => {
      let currentToken = CSRFProtection.getToken()
      
      if (!currentToken) {
        currentToken = await secureApiClient.refreshCSRFToken()
      }
      
      setToken(currentToken)
    }

    initToken()
  }, [])

  const refreshToken = useCallback(async () => {
    const newToken = await secureApiClient.refreshCSRFToken()
    setToken(newToken)
    return newToken
  }, [])

  return {
    token,
    refreshToken,
    addToHeaders: CSRFProtection.addTokenToHeaders,
    addToForm: CSRFProtection.addTokenToForm
  }
}
```

### **3. ì¸ì¦ ë° í† í° ë³´ì•ˆ**

**JWT í† í° ë³´ì•ˆ ê´€ë¦¬**
```typescript
// src/lib/security/token-manager.ts
export class SecureTokenManager {
  private static readonly ACCESS_TOKEN_KEY = 'access_token'
  private static readonly REFRESH_TOKEN_KEY = 'refresh_token'
  private static readonly TOKEN_EXPIRY_KEY = 'token_expiry'

  // í† í° ì €ì¥ (HttpOnly ì¿ í‚¤ ê¶Œì¥, ì—¬ê¸°ì„œëŠ” secure storage êµ¬í˜„)
  static setTokens(accessToken: string, refreshToken: string, expiryTime?: number) {
    try {
      // Access tokenì€ ë©”ëª¨ë¦¬ì—ë§Œ ì €ì¥ (ë” ì•ˆì „)
      this.setSecureItem(this.ACCESS_TOKEN_KEY, accessToken, 'memory')
      
      // Refresh tokenì€ ì•”í˜¸í™”í•˜ì—¬ localStorageì— ì €ì¥
      this.setSecureItem(this.REFRESH_TOKEN_KEY, refreshToken, 'encrypted')
      
      // ë§Œë£Œ ì‹œê°„ ì €ì¥
      if (expiryTime) {
        localStorage.setItem(this.TOKEN_EXPIRY_KEY, expiryTime.toString())
      }
    } catch (error) {
      console.error('Failed to store tokens:', error)
    }
  }

  static getAccessToken(): string | null {
    return this.getSecureItem(this.ACCESS_TOKEN_KEY, 'memory')
  }

  static getRefreshToken(): string | null {
    return this.getSecureItem(this.REFRESH_TOKEN_KEY, 'encrypted')
  }

  static isTokenExpired(): boolean {
    const expiryTime = localStorage.getItem(this.TOKEN_EXPIRY_KEY)
    if (!expiryTime) return true
    
    return Date.now() >= parseInt(expiryTime, 10)
  }

  static clearTokens(): void {
    this.removeSecureItem(this.ACCESS_TOKEN_KEY, 'memory')
    this.removeSecureItem(this.REFRESH_TOKEN_KEY, 'encrypted')
    localStorage.removeItem(this.TOKEN_EXPIRY_KEY)
  }

  // ë©”ëª¨ë¦¬ ê¸°ë°˜ ì €ì¥ì†Œ (í˜ì´ì§€ ìƒˆë¡œê³ ì¹¨ ì‹œ ì´ˆê¸°í™”ë¨)
  private static memoryStorage = new Map<string, string>()

  private static setSecureItem(key: string, value: string, type: 'memory' | 'encrypted'): void {
    if (type === 'memory') {
      this.memoryStorage.set(key, value)
    } else {
      // ê°„ë‹¨í•œ ì•”í˜¸í™” (ì‹¤ì œë¡œëŠ” ë” ê°•ë ¥í•œ ì•”í˜¸í™” ì‚¬ìš©)
      const encrypted = this.encrypt(value)
      localStorage.setItem(key, encrypted)
    }
  }

  private static getSecureItem(key: string, type: 'memory' | 'encrypted'): string | null {
    if (type === 'memory') {
      return this.memoryStorage.get(key) || null
    } else {
      const encrypted = localStorage.getItem(key)
      if (!encrypted) return null
      
      try {
        return this.decrypt(encrypted)
      } catch {
        return null
      }
    }
  }

  private static removeSecureItem(key: string, type: 'memory' | 'encrypted'): void {
    if (type === 'memory') {
      this.memoryStorage.delete(key)
    } else {
      localStorage.removeItem(key)
    }
  }

  // ê°„ë‹¨í•œ ì•”í˜¸í™”/ë³µí˜¸í™” (ì‹¤ì œë¡œëŠ” Web Crypto API ì‚¬ìš©)
  private static encrypt(text: string): string {
    return btoa(text) // ì‹¤ì œë¡œëŠ” ë” ê°•ë ¥í•œ ì•”í˜¸í™” í•„ìš”
  }

  private static decrypt(encrypted: string): string {
    return atob(encrypted) // ì‹¤ì œë¡œëŠ” ë³µí˜¸í™” ë¡œì§ í•„ìš”
  }

  // ìë™ í† í° ê°±ì‹ 
  static async refreshTokens(): Promise<boolean> {
    const refreshToken = this.getRefreshToken()
    if (!refreshToken) return false

    try {
      const response = await fetch('/api/auth/refresh', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ refreshToken })
      })

      if (response.ok) {
        const { accessToken, refreshToken: newRefreshToken, expiresIn } = await response.json()
        
        const expiryTime = Date.now() + (expiresIn * 1000)
        this.setTokens(accessToken, newRefreshToken, expiryTime)
        
        return true
      }
    } catch (error) {
      console.error('Token refresh failed:', error)
    }

    // ê°±ì‹  ì‹¤íŒ¨ ì‹œ í† í° ì •ë¦¬
    this.clearTokens()
    return false
  }
}

// Axios/Fetch ì¸í„°ì…‰í„°
export const createAuthenticatedClient = () => {
  const client = axios.create()

  // ìš”ì²­ ì¸í„°ì…‰í„° - í† í° ìë™ ì¶”ê°€
  client.interceptors.request.use(
    async (config) => {
      // í† í° ë§Œë£Œ í™•ì¸ ë° ê°±ì‹ 
      if (SecureTokenManager.isTokenExpired()) {
        const refreshed = await SecureTokenManager.refreshTokens()
        if (!refreshed) {
          // ë¡œê·¸ì•„ì›ƒ ì²˜ë¦¬
          window.location.href = '/login'
          return Promise.reject(new Error('Authentication required'))
        }
      }

      const token = SecureTokenManager.getAccessToken()
      if (token) {
        config.headers.Authorization = `Bearer ${token}`
      }

      return config
    },
    (error) => Promise.reject(error)
  )

  // ì‘ë‹µ ì¸í„°ì…‰í„° - 401 ì—ëŸ¬ ì²˜ë¦¬
  client.interceptors.response.use(
    (response) => response,
    async (error) => {
      const originalRequest = error.config

      if (error.response?.status === 401 && !originalRequest._retry) {
        originalRequest._retry = true

        const refreshed = await SecureTokenManager.refreshTokens()
        if (refreshed) {
          const token = SecureTokenManager.getAccessToken()
          originalRequest.headers.Authorization = `Bearer ${token}`
          return client(originalRequest)
        } else {
          // ë¦¬í”„ë ˆì‹œ í† í°ë„ ë§Œë£Œëœ ê²½ìš°
          SecureTokenManager.clearTokens()
          window.location.href = '/login'
        }
      }

      return Promise.reject(error)
    }
  )

  return client
}
```

### **4. Content Security Policy**

**CSP í—¤ë” êµ¬ì„±**
```typescript
// src/lib/security/csp-config.ts
export const generateCSPConfig = (environment: 'development' | 'production' = 'production') => {
  const config = {
    'default-src': ["'self'"],
    'script-src': [
      "'self'",
      "'unsafe-inline'", // Next.js ì¸ë¼ì¸ ìŠ¤í¬ë¦½íŠ¸ë¥¼ ìœ„í•´ í•„ìš”
      environment === 'development' ? "'unsafe-eval'" : null,
      'https://vercel.live', // Vercel analytics
    ].filter(Boolean),
    'style-src': [
      "'self'",
      "'unsafe-inline'", // styled-componentsë¥¼ ìœ„í•´ í•„ìš”
      'https://fonts.googleapis.com',
    ],
    'img-src': [
      "'self'",
      'data:', // base64 ì´ë¯¸ì§€
      'https://*.vercel.app',
      'https://images.unsplash.com', // ì™¸ë¶€ ì´ë¯¸ì§€ ì†ŒìŠ¤
    ],
    'font-src': [
      "'self'",
      'https://fonts.gstatic.com',
    ],
    'connect-src': [
      "'self'",
      environment === 'development' ? 'ws://localhost:3000' : null,
      'https://api.baro-calendar.com',
      'wss://ws.baro-calendar.com',
    ].filter(Boolean),
    'frame-src': [
      "'none'" // iframe ì™„ì „ ì°¨ë‹¨
    ],
    'object-src': [
      "'none'" // object, embed íƒœê·¸ ì°¨ë‹¨
    ],
    'base-uri': [
      "'self'"
    ],
    'form-action': [
      "'self'"
    ],
    'upgrade-insecure-requests': environment === 'production' ? [] : null,
  }

  // CSP í—¤ë” ë¬¸ìì—´ ìƒì„±
  return Object.entries(config)
    .filter(([_, value]) => value !== null)
    .map(([directive, sources]) => {
      if (Array.isArray(sources) && sources.length > 0) {
        return `${directive} ${sources.join(' ')}`
      } else if (!Array.isArray(sources)) {
        return directive
      }
      return null
    })
    .filter(Boolean)
    .join('; ')
}

// Next.js ë¯¸ë“¤ì›¨ì–´ì—ì„œ CSP í—¤ë” ì„¤ì •
export const cspMiddleware = (req: NextRequest) => {
  const response = NextResponse.next()
  
  const csp = generateCSPConfig(process.env.NODE_ENV as any)
  
  response.headers.set('Content-Security-Policy', csp)
  response.headers.set('X-Content-Type-Options', 'nosniff')
  response.headers.set('X-Frame-Options', 'DENY')
  response.headers.set('X-XSS-Protection', '1; mode=block')
  response.headers.set('Referrer-Policy', 'strict-origin-when-cross-origin')
  response.headers.set('Permissions-Policy', 'camera=(), microphone=(), geolocation=()')
  
  return response
}

// CSP ìœ„ë°˜ ë¦¬í¬íŒ…
export const setupCSPReporting = () => {
  if (typeof window !== 'undefined') {
    document.addEventListener('securitypolicyviolation', (e) => {
      const violation = {
        blockedURI: e.blockedURI,
        violatedDirective: e.violatedDirective,
        originalPolicy: e.originalPolicy,
        documentURI: e.documentURI,
        lineNumber: e.lineNumber,
        columnNumber: e.columnNumber,
        sourceFile: e.sourceFile,
        timestamp: Date.now()
      }

      // ìœ„ë°˜ ì‚¬í•­ì„ ì„œë²„ë¡œ ì „ì†¡
      fetch('/api/security/csp-violation', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(violation)
      }).catch(console.error)
    })
  }
}
```

### **5. ë°ì´í„° ì•”í˜¸í™” ë° ë³´ì•ˆ ì €ì¥**

**í´ë¼ì´ì–¸íŠ¸ ì‚¬ì´ë“œ ì•”í˜¸í™”**
```typescript
// src/lib/security/encryption.ts
export class ClientSideEncryption {
  private static readonly ALGORITHM = 'AES-GCM'
  private static readonly KEY_LENGTH = 256

  // ì•”í˜¸í™” í‚¤ ìƒì„±
  static async generateKey(): Promise<CryptoKey> {
    return await crypto.subtle.generateKey(
      {
        name: this.ALGORITHM,
        length: this.KEY_LENGTH,
      },
      true, // extractable
      ['encrypt', 'decrypt']
    )
  }

  // í‚¤ë¥¼ ì €ì¥ ê°€ëŠ¥í•œ í˜•íƒœë¡œ ë‚´ë³´ë‚´ê¸°
  static async exportKey(key: CryptoKey): Promise<string> {
    const exported = await crypto.subtle.exportKey('raw', key)
    return this.arrayBufferToBase64(exported)
  }

  // ì €ì¥ëœ í‚¤ ê°€ì ¸ì˜¤ê¸°
  static async importKey(keyString: string): Promise<CryptoKey> {
    const keyBuffer = this.base64ToArrayBuffer(keyString)
    return await crypto.subtle.importKey(
      'raw',
      keyBuffer,
      {
        name: this.ALGORITHM,
        length: this.KEY_LENGTH,
      },
      true,
      ['encrypt', 'decrypt']
    )
  }

  // ë°ì´í„° ì•”í˜¸í™”
  static async encrypt(data: string, key: CryptoKey): Promise<{
    encrypted: string
    iv: string
  }> {
    const encoder = new TextEncoder()
    const dataBuffer = encoder.encode(data)
    
    const iv = crypto.getRandomValues(new Uint8Array(12)) // 96-bit IV for GCM
    
    const encryptedBuffer = await crypto.subtle.encrypt(
      {
        name: this.ALGORITHM,
        iv: iv,
      },
      key,
      dataBuffer
    )

    return {
      encrypted: this.arrayBufferToBase64(encryptedBuffer),
      iv: this.arrayBufferToBase64(iv),
    }
  }

  // ë°ì´í„° ë³µí˜¸í™”
  static async decrypt(encrypted: string, iv: string, key: CryptoKey): Promise<string> {
    const encryptedBuffer = this.base64ToArrayBuffer(encrypted)
    const ivBuffer = this.base64ToArrayBuffer(iv)

    const decryptedBuffer = await crypto.subtle.decrypt(
      {
        name: this.ALGORITHM,
        iv: ivBuffer,
      },
      key,
      encryptedBuffer
    )

    const decoder = new TextDecoder()
    return decoder.decode(decryptedBuffer)
  }

  // ìœ í‹¸ë¦¬í‹° ë©”ì„œë“œë“¤
  private static arrayBufferToBase64(buffer: ArrayBuffer): string {
    const bytes = new Uint8Array(buffer)
    let binary = ''
    for (let i = 0; i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i])
    }
    return btoa(binary)
  }

  private static base64ToArrayBuffer(base64: string): ArrayBuffer {
    const binaryString = atob(base64)
    const bytes = new Uint8Array(binaryString.length)
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i)
    }
    return bytes.buffer
  }
}

// ë³´ì•ˆ ìŠ¤í† ë¦¬ì§€ í´ë˜ìŠ¤
export class SecureStorage {
  private key: CryptoKey | null = null

  async initialize() {
    // ê¸°ì¡´ í‚¤ê°€ ìˆëŠ”ì§€ í™•ì¸
    const storedKey = localStorage.getItem('encryption_key')
    
    if (storedKey) {
      try {
        this.key = await ClientSideEncryption.importKey(storedKey)
      } catch (error) {
        console.error('Failed to import stored key:', error)
        await this.generateNewKey()
      }
    } else {
      await this.generateNewKey()
    }
  }

  private async generateNewKey() {
    this.key = await ClientSideEncryption.generateKey()
    const exportedKey = await ClientSideEncryption.exportKey(this.key)
    localStorage.setItem('encryption_key', exportedKey)
  }

  async setItem(key: string, value: any): Promise<void> {
    if (!this.key) {
      throw new Error('Encryption key not initialized')
    }

    const serialized = JSON.stringify(value)
    const { encrypted, iv } = await ClientSideEncryption.encrypt(serialized, this.key)
    
    localStorage.setItem(key, JSON.stringify({ encrypted, iv }))
  }

  async getItem<T>(key: string): Promise<T | null> {
    if (!this.key) {
      throw new Error('Encryption key not initialized')
    }

    const stored = localStorage.getItem(key)
    if (!stored) return null

    try {
      const { encrypted, iv } = JSON.parse(stored)
      const decrypted = await ClientSideEncryption.decrypt(encrypted, iv, this.key)
      return JSON.parse(decrypted)
    } catch (error) {
      console.error('Failed to decrypt stored data:', error)
      return null
    }
  }

  removeItem(key: string): void {
    localStorage.removeItem(key)
  }

  async clear(): Promise<void> {
    localStorage.clear()
    await this.generateNewKey()
  }
}

// React Hook for secure storage
export const useSecureStorage = () => {
  const storageRef = useRef<SecureStorage>()
  const [isInitialized, setIsInitialized] = useState(false)

  useEffect(() => {
    const initStorage = async () => {
      storageRef.current = new SecureStorage()
      await storageRef.current.initialize()
      setIsInitialized(true)
    }

    initStorage().catch(console.error)
  }, [])

  const setSecureItem = useCallback(async (key: string, value: any) => {
    if (!storageRef.current || !isInitialized) {
      throw new Error('Secure storage not initialized')
    }
    return storageRef.current.setItem(key, value)
  }, [isInitialized])

  const getSecureItem = useCallback(async <T>(key: string): Promise<T | null> => {
    if (!storageRef.current || !isInitialized) {
      return null
    }
    return storageRef.current.getItem<T>(key)
  }, [isInitialized])

  const removeSecureItem = useCallback((key: string) => {
    if (!storageRef.current || !isInitialized) {
      return
    }
    storageRef.current.removeItem(key)
  }, [isInitialized])

  return {
    isInitialized,
    setSecureItem,
    getSecureItem,
    removeSecureItem
  }
}
```

### **6. ë³´ì•ˆ ëª¨ë‹ˆí„°ë§ ë° ì•Œë¦¼**

**ë³´ì•ˆ ì´ë²¤íŠ¸ ëª¨ë‹ˆí„°ë§**
```typescript
// src/lib/security/security-monitor.ts
export class SecurityMonitor {
  private static events: SecurityEvent[] = []
  private static readonly MAX_EVENTS = 1000

  // ë³´ì•ˆ ì´ë²¤íŠ¸ ë¡œê¹…
  static logSecurityEvent(event: {
    type: 'auth_failure' | 'xss_attempt' | 'csrf_violation' | 'suspicious_activity'
    severity: 'low' | 'medium' | 'high' | 'critical'
    details: any
    userAgent?: string
    ipAddress?: string
  }) {
    const securityEvent: SecurityEvent = {
      id: crypto.randomUUID(),
      timestamp: Date.now(),
      url: window.location.href,
      userAgent: navigator.userAgent,
      ...event
    }

    this.events.push(securityEvent)

    // ì´ë²¤íŠ¸ ìˆ˜ ì œí•œ
    if (this.events.length > this.MAX_EVENTS) {
      this.events.shift()
    }

    // ì‹¬ê°í•œ ì´ë²¤íŠ¸ëŠ” ì¦‰ì‹œ ë³´ê³ 
    if (event.severity === 'critical' || event.severity === 'high') {
      this.reportSecurityEvent(securityEvent)
    }

    // ë¸Œë¼ìš°ì € ì½˜ì†”ì—ë„ ê¸°ë¡
    if (process.env.NODE_ENV === 'development') {
      console.warn('Security Event:', securityEvent)
    }
  }

  // ì„œë²„ë¡œ ë³´ì•ˆ ì´ë²¤íŠ¸ ë³´ê³ 
  private static async reportSecurityEvent(event: SecurityEvent) {
    try {
      await fetch('/api/security/events', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(event),
        credentials: 'same-origin'
      })
    } catch (error) {
      console.error('Failed to report security event:', error)
    }
  }

  // ì˜ì‹¬ìŠ¤ëŸ¬ìš´ í™œë™ ê°ì§€
  static detectSuspiciousActivity() {
    // ì§§ì€ ì‹œê°„ ë‚´ ë§ì€ ì‹¤íŒ¨ ì‹œë„
    const recentFailures = this.events.filter(event => 
      event.type === 'auth_failure' && 
      Date.now() - event.timestamp < 60000 // 1ë¶„ ì´ë‚´
    )

    if (recentFailures.length >= 5) {
      this.logSecurityEvent({
        type: 'suspicious_activity',
        severity: 'high',
        details: {
          reason: 'Multiple authentication failures',
          count: recentFailures.length,
          timeframe: '1 minute'
        }
      })

      // ê³„ì • ì¼ì‹œ ì ê¸ˆ ë˜ëŠ” ì¶”ê°€ ë³´ì•ˆ ì¡°ì¹˜
      this.triggerSecurityMeasures('multiple_auth_failures')
    }

    // ë¹„ì •ìƒì ì¸ ë„¤ë¹„ê²Œì´ì…˜ íŒ¨í„´ ê°ì§€
    this.detectAbnormalNavigation()
  }

  private static detectAbnormalNavigation() {
    // êµ¬í˜„: ë¹ ë¥¸ ì—°ì† í˜ì´ì§€ ë³€ê²½, ë´‡ íŒ¨í„´ ë“± ê°ì§€
  }

  private static triggerSecurityMeasures(reason: string) {
    // CAPTCHA í‘œì‹œ
    // ê³„ì • ì¼ì‹œ ì ê¸ˆ
    // ê´€ë¦¬ì ì•Œë¦¼
    console.warn('Security measures triggered:', reason)
  }

  // ì •ê¸°ì ì¸ ë³´ì•ˆ ìƒíƒœ ì²´í¬
  static performSecurityCheck() {
    const issues: string[] = []

    // HTTPS í™•ì¸
    if (location.protocol !== 'https:' && process.env.NODE_ENV === 'production') {
      issues.push('Non-HTTPS connection detected')
    }

    // ê°œë°œì ë„êµ¬ ì—´ë¦¼ ê°ì§€
    if (this.isDevToolsOpen()) {
      issues.push('Developer tools are open')
      this.logSecurityEvent({
        type: 'suspicious_activity',
        severity: 'medium',
        details: { reason: 'Developer tools detected' }
      })
    }

    // ì½˜ì†” ëª…ë ¹ ì‹¤í–‰ ê°ì§€
    this.setupConsoleProtection()

    return issues
  }

  private static isDevToolsOpen(): boolean {
    const devtools = {
      open: false,
      orientation: null as 'vertical' | 'horizontal' | null
    }

    const threshold = 160

    setInterval(() => {
      if (window.outerHeight - window.innerHeight > threshold || 
          window.outerWidth - window.innerWidth > threshold) {
        if (!devtools.open) {
          devtools.open = true
          devtools.orientation = (window.outerHeight - window.innerHeight > threshold) ? 'vertical' : 'horizontal'
        }
      } else {
        devtools.open = false
        devtools.orientation = null
      }
    }, 500)

    return devtools.open
  }

  private static setupConsoleProtection() {
    // ì½˜ì†” ì›Œë‹ ë©”ì‹œì§€
    const warningStyle = 'color: red; font-size: 20px; font-weight: bold;'
    console.log('%cğŸš¨ ë³´ì•ˆ ê²½ê³ ', warningStyle)
    console.log('%cì´ ì½˜ì†”ì€ ê°œë°œìë¥¼ ìœ„í•œ ê²ƒì…ë‹ˆë‹¤. ì•…ì˜ì ì¸ ì½”ë“œë¥¼ ì‹¤í–‰í•˜ì§€ ë§ˆì„¸ìš”!', warningStyle)

    // ì½˜ì†” ëª…ë ¹ ê°ì§€ (ê°„ë‹¨í•œ ì˜ˆì‹œ)
    const originalLog = console.log
    console.log = function(...args) {
      if (typeof args[0] === 'string' && args[0].includes('document.cookie')) {
        SecurityMonitor.logSecurityEvent({
          type: 'suspicious_activity',
          severity: 'high',
          details: { reason: 'Suspicious console activity', command: args[0] }
        })
      }
      return originalLog.apply(console, args)
    }
  }
}

interface SecurityEvent {
  id: string
  timestamp: number
  type: 'auth_failure' | 'xss_attempt' | 'csrf_violation' | 'suspicious_activity'
  severity: 'low' | 'medium' | 'high' | 'critical'
  details: any
  url: string
  userAgent: string
}

// React Hook for security monitoring
export const useSecurityMonitoring = () => {
  useEffect(() => {
    // ì»´í¬ë„ŒíŠ¸ ë§ˆìš´íŠ¸ ì‹œ ë³´ì•ˆ ì²´í¬ ì‹œì‘
    const securityCheckInterval = setInterval(() => {
      SecurityMonitor.performSecurityCheck()
      SecurityMonitor.detectSuspiciousActivity()
    }, 30000) // 30ì´ˆë§ˆë‹¤ ì²´í¬

    return () => {
      clearInterval(securityCheckInterval)
    }
  }, [])

  const logSecurityEvent = useCallback((event: Parameters<typeof SecurityMonitor.logSecurityEvent>[0]) => {
    SecurityMonitor.logSecurityEvent(event)
  }, [])

  return { logSecurityEvent }
}
```

---

## ğŸ“Š **ë³´ì•ˆ ëŒ€ì‹œë³´ë“œ**

### **ë³´ì•ˆ ë©”íŠ¸ë¦­ ìˆ˜ì§‘**
```typescript
// src/lib/security/security-metrics.ts
export const collectSecurityMetrics = () => {
  return {
    authFailureRate: calculateAuthFailureRate(),
    xssAttempts: countXSSAttempts(),
    csrfViolations: countCSRFViolations(),
    suspiciousActivity: countSuspiciousActivity(),
    cspViolations: countCSPViolations()
  }
}
```

---

## âœ… **Definition of Done**

### **ê¸°ëŠ¥ ìš”êµ¬ì‚¬í•­**
- [ ] XSS ë°©ì–´ ì‹œìŠ¤í…œ êµ¬í˜„
- [ ] CSRF í† í° ë³´í˜¸
- [ ] JWT í† í° ë³´ì•ˆ ê´€ë¦¬
- [ ] Content Security Policy
- [ ] í´ë¼ì´ì–¸íŠ¸ ì‚¬ì´ë“œ ì•”í˜¸í™”

### **ê¸°ìˆ  ìš”êµ¬ì‚¬í•­**
- [ ] DOMPurifyë¥¼ í™œìš©í•œ HTML sanitization
- [ ] Web Crypto API í™œìš©
- [ ] ë³´ì•ˆ í—¤ë” ì„¤ì •
- [ ] í† í° ìë™ ê°±ì‹ 

### **ë³´ì•ˆ ìš”êµ¬ì‚¬í•­**
- [ ] OWASP Top 10 ë°©ì–´
- [ ] ë°ì´í„° ì•”í˜¸í™” ì „ì†¡
- [ ] ì•ˆì „í•œ í† í° ì €ì¥
- [ ] ë³´ì•ˆ ì´ë²¤íŠ¸ ë¡œê¹…

### **ëª¨ë‹ˆí„°ë§ ìš”êµ¬ì‚¬í•­**
- [ ] ë³´ì•ˆ ì´ë²¤íŠ¸ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§
- [ ] ì˜ì‹¬ìŠ¤ëŸ¬ìš´ í™œë™ ê°ì§€
- [ ] ìë™ ë³´ì•ˆ ì¡°ì¹˜
- [ ] ë³´ì•ˆ ë©”íŠ¸ë¦­ ìˆ˜ì§‘

---

## ğŸ“š **ê´€ë ¨ ë¬¸ì„œ ì°¸ì¡°**

- [10. Security Best Practices](../ui-architecture/10-security-best-practices.md)
- [20. Error Handling](../ui-architecture/20-error-handling.md)
- [21. Observability & Monitoring](../ui-architecture/21-observability-monitoring.md)

---

**ì´ ìŠ¤í† ë¦¬ëŠ” ë°”ë¡œìº˜ë¦°ë”ì˜ ì¢…í•©ì ì¸ ë³´ì•ˆ ì‹œìŠ¤í…œ êµ¬í˜„ì„ ìœ„í•œ ê¸°ìˆ  ê°€ì´ë“œì…ë‹ˆë‹¤. ë‹¤ì¸µ ë°©ì–´ ì²´ê³„ë¥¼ í†µí•´ ì‚¬ìš©ì ë°ì´í„°ì™€ ì‹œìŠ¤í…œì„ ì•ˆì „í•˜ê²Œ ë³´í˜¸í•©ë‹ˆë‹¤.**