# Story 2.8: 보안 모범 사례 구현

## 📋 문서 정보
- **스토리 버전**: 2.0
- **작성일**: 2025-08-28
- **작성자**: Bob (Scrum Master Agent)  
- **프로젝트명**: 바로캘린더 (Baro Calendar)
- **Epic**: 프론트엔드 보안 강화
- **상태**: Ready for Development

---

## 🎯 **스토리 목표**

**완전한 프론트엔드 보안 시스템 구현**
- XSS/CSRF 방어 메커니즘
- 안전한 인증 및 토큰 관리
- 데이터 암호화 및 검증
- Content Security Policy 구현
- 보안 취약점 스캔 자동화

---

## 👤 **사용자 스토리**

**사용자로서, 나는:**
1. 개인 데이터가 안전하게 보호되기를 원한다
2. 세션 하이재킹이나 계정 탈취를 당하지 않고 싶다
3. 악의적인 스크립트로부터 보호받고 싶다
4. 민감한 정보가 암호화되어 전송되기를 원한다
5. 보안 사고 발생 시 즉시 알림을 받고 싶다

---

## 🏗️ **기술적 구현 요구사항**

### **1. XSS 방어 시스템**

**XSS 방어 및 입력 검증**
```typescript
// src/lib/security/xss-protection.ts
import DOMPurify from 'dompurify'

export class XSSProtection {
  // HTML 콘텐츠 sanitization
  static sanitizeHTML(html: string, options?: {
    allowedTags?: string[]
    allowedAttributes?: Record<string, string[]>
  }): string {
    const config = {
      ALLOWED_TAGS: options?.allowedTags || [
        'b', 'i', 'u', 'strong', 'em', 'p', 'br', 'ul', 'ol', 'li'
      ],
      ALLOWED_ATTR: options?.allowedAttributes || {
        'a': ['href', 'title'],
        'img': ['src', 'alt']
      },
      FORBID_SCRIPT: true,
      FORBID_TAGS: ['script', 'object', 'embed', 'form'],
      FORBID_ATTR: ['onerror', 'onload', 'onclick']
    }
    
    return DOMPurify.sanitize(html, config)
  }

  // 사용자 입력 검증
  static validateUserInput(input: string, type: 'text' | 'email' | 'url' | 'filename'): {
    isValid: boolean
    sanitized: string
    errors: string[]
  } {
    const errors: string[] = []
    let sanitized = input.trim()

    // 기본 XSS 패턴 검사
    const xssPatterns = [
      /<script[^>]*>.*?<\/script>/gi,
      /javascript:/gi,
      /on\w+\s*=/gi,
      /<iframe[^>]*>.*?<\/iframe>/gi,
      /data:text\/html/gi
    ]

    for (const pattern of xssPatterns) {
      if (pattern.test(sanitized)) {
        errors.push('Potentially malicious content detected')
        break
      }
    }

    // 타입별 검증
    switch (type) {
      case 'email':
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
        if (!emailRegex.test(sanitized)) {
          errors.push('Invalid email format')
        }
        break

      case 'url':
        try {
          const url = new URL(sanitized)
          if (!['http:', 'https:'].includes(url.protocol)) {
            errors.push('Only HTTP/HTTPS URLs are allowed')
          }
        } catch {
          errors.push('Invalid URL format')
        }
        break

      case 'filename':
        const dangerousChars = /[<>:"/\\|?*\x00-\x1f]/
        if (dangerousChars.test(sanitized)) {
          errors.push('Filename contains invalid characters')
        }
        break

      case 'text':
        // SQL Injection 패턴 검사
        const sqlPatterns = [
          /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|UNION)\b)/gi,
          /('|(\\)|;|--|\||`)/g
        ]
        
        for (const pattern of sqlPatterns) {
          if (pattern.test(sanitized)) {
            errors.push('Potentially malicious SQL pattern detected')
            break
          }
        }
        break
    }

    // HTML 엔코딩
    sanitized = sanitized
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#x27;')

    return {
      isValid: errors.length === 0,
      sanitized,
      errors
    }
  }

  // React 컴포넌트용 안전한 HTML 렌더링
  static createSafeHTML(html: string) {
    return {
      __html: this.sanitizeHTML(html)
    }
  }
}

// React Hook for input validation
export const useSecureInput = () => {
  const validateAndSanitize = useCallback((
    input: string,
    type: Parameters<typeof XSSProtection.validateUserInput>[1]
  ) => {
    return XSSProtection.validateUserInput(input, type)
  }, [])

  return { validateAndSanitize }
}

// Secure Input Component
interface SecureInputProps extends React.InputHTMLAttributes<HTMLInputElement> {
  validationType?: 'text' | 'email' | 'url' | 'filename'
  onValidationChange?: (isValid: boolean, errors: string[]) => void
}

export const SecureInput: React.FC<SecureInputProps> = ({
  validationType = 'text',
  onValidationChange,
  onChange,
  ...props
}) => {
  const { validateAndSanitize } = useSecureInput()
  const [validationErrors, setValidationErrors] = useState<string[]>([])

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { isValid, sanitized, errors } = validateAndSanitize(e.target.value, validationType)
    
    setValidationErrors(errors)
    onValidationChange?.(isValid, errors)

    // 안전한 값으로 이벤트 업데이트
    const sanitizedEvent = {
      ...e,
      target: {
        ...e.target,
        value: sanitized
      }
    }
    
    onChange?.(sanitizedEvent)
  }

  return (
    <div>
      <input
        {...props}
        onChange={handleChange}
        className={cn(props.className, validationErrors.length > 0 && 'border-destructive')}
      />
      {validationErrors.length > 0 && (
        <div className="text-sm text-destructive mt-1">
          {validationErrors.map((error, index) => (
            <div key={index}>{error}</div>
          ))}
        </div>
      )}
    </div>
  )
}
```

### **2. CSRF 방어 시스템**

**CSRF 토큰 관리**
```typescript
// src/lib/security/csrf-protection.ts
export class CSRFProtection {
  private static tokenKey = 'csrf-token'
  private static headerName = 'X-CSRF-Token'

  // CSRF 토큰 생성
  static generateToken(): string {
    const array = new Uint8Array(32)
    crypto.getRandomValues(array)
    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('')
  }

  // 토큰 저장
  static setToken(token: string): void {
    sessionStorage.setItem(this.tokenKey, token)
    
    // 메타 태그에도 설정 (서버에서 초기 설정된 토큰 사용)
    let metaTag = document.querySelector('meta[name="csrf-token"]') as HTMLMetaElement
    if (!metaTag) {
      metaTag = document.createElement('meta')
      metaTag.name = 'csrf-token'
      document.head.appendChild(metaTag)
    }
    metaTag.content = token
  }

  // 토큰 조회
  static getToken(): string | null {
    // 세션 스토리지에서 먼저 확인
    let token = sessionStorage.getItem(this.tokenKey)
    
    // 없으면 메타 태그에서 확인
    if (!token) {
      const metaTag = document.querySelector('meta[name="csrf-token"]') as HTMLMetaElement
      token = metaTag?.content || null
    }
    
    return token
  }

  // HTTP 요청에 CSRF 토큰 추가
  static addTokenToHeaders(headers: HeadersInit = {}): HeadersInit {
    const token = this.getToken()
    if (!token) {
      console.warn('CSRF token not found')
      return headers
    }

    return {
      ...headers,
      [this.headerName]: token
    }
  }

  // 폼에 CSRF 토큰 추가
  static addTokenToForm(formData: FormData): FormData {
    const token = this.getToken()
    if (token) {
      formData.append('_csrf', token)
    }
    return formData
  }

  // 토큰 유효성 검증
  static async validateToken(token: string): Promise<boolean> {
    try {
      const response = await fetch('/api/csrf/validate', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          ...this.addTokenToHeaders()
        },
        body: JSON.stringify({ token })
      })
      
      return response.ok
    } catch (error) {
      console.error('CSRF token validation failed:', error)
      return false
    }
  }
}

// HTTP 클라이언트에 CSRF 보호 통합
export const secureApiClient = {
  async request<T>(url: string, options: RequestInit = {}): Promise<T> {
    const headers = CSRFProtection.addTokenToHeaders(options.headers)
    
    const response = await fetch(url, {
      ...options,
      headers,
      credentials: 'same-origin' // CSRF 방어를 위해 same-origin만 허용
    })

    // CSRF 토큰 만료 시 새 토큰 요청
    if (response.status === 403) {
      const newToken = await this.refreshCSRFToken()
      if (newToken) {
        const retryHeaders = CSRFProtection.addTokenToHeaders(options.headers)
        const retryResponse = await fetch(url, {
          ...options,
          headers: retryHeaders
        })
        
        if (retryResponse.ok) {
          return retryResponse.json()
        }
      }
    }

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`)
    }

    return response.json()
  },

  async refreshCSRFToken(): Promise<string | null> {
    try {
      const response = await fetch('/api/csrf/token', {
        method: 'GET',
        credentials: 'same-origin'
      })
      
      if (response.ok) {
        const { token } = await response.json()
        CSRFProtection.setToken(token)
        return token
      }
    } catch (error) {
      console.error('Failed to refresh CSRF token:', error)
    }
    
    return null
  }
}

// React Hook for CSRF protection
export const useCSRFProtection = () => {
  const [token, setToken] = useState<string | null>(null)

  useEffect(() => {
    // 컴포넌트 마운트 시 토큰 초기화
    const initToken = async () => {
      let currentToken = CSRFProtection.getToken()
      
      if (!currentToken) {
        currentToken = await secureApiClient.refreshCSRFToken()
      }
      
      setToken(currentToken)
    }

    initToken()
  }, [])

  const refreshToken = useCallback(async () => {
    const newToken = await secureApiClient.refreshCSRFToken()
    setToken(newToken)
    return newToken
  }, [])

  return {
    token,
    refreshToken,
    addToHeaders: CSRFProtection.addTokenToHeaders,
    addToForm: CSRFProtection.addTokenToForm
  }
}
```

### **3. 인증 및 토큰 보안**

**JWT 토큰 보안 관리**
```typescript
// src/lib/security/token-manager.ts
export class SecureTokenManager {
  private static readonly ACCESS_TOKEN_KEY = 'access_token'
  private static readonly REFRESH_TOKEN_KEY = 'refresh_token'
  private static readonly TOKEN_EXPIRY_KEY = 'token_expiry'

  // 토큰 저장 (HttpOnly 쿠키 권장, 여기서는 secure storage 구현)
  static setTokens(accessToken: string, refreshToken: string, expiryTime?: number) {
    try {
      // Access token은 메모리에만 저장 (더 안전)
      this.setSecureItem(this.ACCESS_TOKEN_KEY, accessToken, 'memory')
      
      // Refresh token은 암호화하여 localStorage에 저장
      this.setSecureItem(this.REFRESH_TOKEN_KEY, refreshToken, 'encrypted')
      
      // 만료 시간 저장
      if (expiryTime) {
        localStorage.setItem(this.TOKEN_EXPIRY_KEY, expiryTime.toString())
      }
    } catch (error) {
      console.error('Failed to store tokens:', error)
    }
  }

  static getAccessToken(): string | null {
    return this.getSecureItem(this.ACCESS_TOKEN_KEY, 'memory')
  }

  static getRefreshToken(): string | null {
    return this.getSecureItem(this.REFRESH_TOKEN_KEY, 'encrypted')
  }

  static isTokenExpired(): boolean {
    const expiryTime = localStorage.getItem(this.TOKEN_EXPIRY_KEY)
    if (!expiryTime) return true
    
    return Date.now() >= parseInt(expiryTime, 10)
  }

  static clearTokens(): void {
    this.removeSecureItem(this.ACCESS_TOKEN_KEY, 'memory')
    this.removeSecureItem(this.REFRESH_TOKEN_KEY, 'encrypted')
    localStorage.removeItem(this.TOKEN_EXPIRY_KEY)
  }

  // 메모리 기반 저장소 (페이지 새로고침 시 초기화됨)
  private static memoryStorage = new Map<string, string>()

  private static setSecureItem(key: string, value: string, type: 'memory' | 'encrypted'): void {
    if (type === 'memory') {
      this.memoryStorage.set(key, value)
    } else {
      // 간단한 암호화 (실제로는 더 강력한 암호화 사용)
      const encrypted = this.encrypt(value)
      localStorage.setItem(key, encrypted)
    }
  }

  private static getSecureItem(key: string, type: 'memory' | 'encrypted'): string | null {
    if (type === 'memory') {
      return this.memoryStorage.get(key) || null
    } else {
      const encrypted = localStorage.getItem(key)
      if (!encrypted) return null
      
      try {
        return this.decrypt(encrypted)
      } catch {
        return null
      }
    }
  }

  private static removeSecureItem(key: string, type: 'memory' | 'encrypted'): void {
    if (type === 'memory') {
      this.memoryStorage.delete(key)
    } else {
      localStorage.removeItem(key)
    }
  }

  // 간단한 암호화/복호화 (실제로는 Web Crypto API 사용)
  private static encrypt(text: string): string {
    return btoa(text) // 실제로는 더 강력한 암호화 필요
  }

  private static decrypt(encrypted: string): string {
    return atob(encrypted) // 실제로는 복호화 로직 필요
  }

  // 자동 토큰 갱신
  static async refreshTokens(): Promise<boolean> {
    const refreshToken = this.getRefreshToken()
    if (!refreshToken) return false

    try {
      const response = await fetch('/api/auth/refresh', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ refreshToken })
      })

      if (response.ok) {
        const { accessToken, refreshToken: newRefreshToken, expiresIn } = await response.json()
        
        const expiryTime = Date.now() + (expiresIn * 1000)
        this.setTokens(accessToken, newRefreshToken, expiryTime)
        
        return true
      }
    } catch (error) {
      console.error('Token refresh failed:', error)
    }

    // 갱신 실패 시 토큰 정리
    this.clearTokens()
    return false
  }
}

// Axios/Fetch 인터셉터
export const createAuthenticatedClient = () => {
  const client = axios.create()

  // 요청 인터셉터 - 토큰 자동 추가
  client.interceptors.request.use(
    async (config) => {
      // 토큰 만료 확인 및 갱신
      if (SecureTokenManager.isTokenExpired()) {
        const refreshed = await SecureTokenManager.refreshTokens()
        if (!refreshed) {
          // 로그아웃 처리
          window.location.href = '/login'
          return Promise.reject(new Error('Authentication required'))
        }
      }

      const token = SecureTokenManager.getAccessToken()
      if (token) {
        config.headers.Authorization = `Bearer ${token}`
      }

      return config
    },
    (error) => Promise.reject(error)
  )

  // 응답 인터셉터 - 401 에러 처리
  client.interceptors.response.use(
    (response) => response,
    async (error) => {
      const originalRequest = error.config

      if (error.response?.status === 401 && !originalRequest._retry) {
        originalRequest._retry = true

        const refreshed = await SecureTokenManager.refreshTokens()
        if (refreshed) {
          const token = SecureTokenManager.getAccessToken()
          originalRequest.headers.Authorization = `Bearer ${token}`
          return client(originalRequest)
        } else {
          // 리프레시 토큰도 만료된 경우
          SecureTokenManager.clearTokens()
          window.location.href = '/login'
        }
      }

      return Promise.reject(error)
    }
  )

  return client
}
```

### **4. Content Security Policy**

**CSP 헤더 구성**
```typescript
// src/lib/security/csp-config.ts
export const generateCSPConfig = (environment: 'development' | 'production' = 'production') => {
  const config = {
    'default-src': ["'self'"],
    'script-src': [
      "'self'",
      "'unsafe-inline'", // Next.js 인라인 스크립트를 위해 필요
      environment === 'development' ? "'unsafe-eval'" : null,
      'https://vercel.live', // Vercel analytics
    ].filter(Boolean),
    'style-src': [
      "'self'",
      "'unsafe-inline'", // styled-components를 위해 필요
      'https://fonts.googleapis.com',
    ],
    'img-src': [
      "'self'",
      'data:', // base64 이미지
      'https://*.vercel.app',
      'https://images.unsplash.com', // 외부 이미지 소스
    ],
    'font-src': [
      "'self'",
      'https://fonts.gstatic.com',
    ],
    'connect-src': [
      "'self'",
      environment === 'development' ? 'ws://localhost:3000' : null,
      'https://api.baro-calendar.com',
      'wss://ws.baro-calendar.com',
    ].filter(Boolean),
    'frame-src': [
      "'none'" // iframe 완전 차단
    ],
    'object-src': [
      "'none'" // object, embed 태그 차단
    ],
    'base-uri': [
      "'self'"
    ],
    'form-action': [
      "'self'"
    ],
    'upgrade-insecure-requests': environment === 'production' ? [] : null,
  }

  // CSP 헤더 문자열 생성
  return Object.entries(config)
    .filter(([_, value]) => value !== null)
    .map(([directive, sources]) => {
      if (Array.isArray(sources) && sources.length > 0) {
        return `${directive} ${sources.join(' ')}`
      } else if (!Array.isArray(sources)) {
        return directive
      }
      return null
    })
    .filter(Boolean)
    .join('; ')
}

// Next.js 미들웨어에서 CSP 헤더 설정
export const cspMiddleware = (req: NextRequest) => {
  const response = NextResponse.next()
  
  const csp = generateCSPConfig(process.env.NODE_ENV as any)
  
  response.headers.set('Content-Security-Policy', csp)
  response.headers.set('X-Content-Type-Options', 'nosniff')
  response.headers.set('X-Frame-Options', 'DENY')
  response.headers.set('X-XSS-Protection', '1; mode=block')
  response.headers.set('Referrer-Policy', 'strict-origin-when-cross-origin')
  response.headers.set('Permissions-Policy', 'camera=(), microphone=(), geolocation=()')
  
  return response
}

// CSP 위반 리포팅
export const setupCSPReporting = () => {
  if (typeof window !== 'undefined') {
    document.addEventListener('securitypolicyviolation', (e) => {
      const violation = {
        blockedURI: e.blockedURI,
        violatedDirective: e.violatedDirective,
        originalPolicy: e.originalPolicy,
        documentURI: e.documentURI,
        lineNumber: e.lineNumber,
        columnNumber: e.columnNumber,
        sourceFile: e.sourceFile,
        timestamp: Date.now()
      }

      // 위반 사항을 서버로 전송
      fetch('/api/security/csp-violation', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(violation)
      }).catch(console.error)
    })
  }
}
```

### **5. 데이터 암호화 및 보안 저장**

**클라이언트 사이드 암호화**
```typescript
// src/lib/security/encryption.ts
export class ClientSideEncryption {
  private static readonly ALGORITHM = 'AES-GCM'
  private static readonly KEY_LENGTH = 256

  // 암호화 키 생성
  static async generateKey(): Promise<CryptoKey> {
    return await crypto.subtle.generateKey(
      {
        name: this.ALGORITHM,
        length: this.KEY_LENGTH,
      },
      true, // extractable
      ['encrypt', 'decrypt']
    )
  }

  // 키를 저장 가능한 형태로 내보내기
  static async exportKey(key: CryptoKey): Promise<string> {
    const exported = await crypto.subtle.exportKey('raw', key)
    return this.arrayBufferToBase64(exported)
  }

  // 저장된 키 가져오기
  static async importKey(keyString: string): Promise<CryptoKey> {
    const keyBuffer = this.base64ToArrayBuffer(keyString)
    return await crypto.subtle.importKey(
      'raw',
      keyBuffer,
      {
        name: this.ALGORITHM,
        length: this.KEY_LENGTH,
      },
      true,
      ['encrypt', 'decrypt']
    )
  }

  // 데이터 암호화
  static async encrypt(data: string, key: CryptoKey): Promise<{
    encrypted: string
    iv: string
  }> {
    const encoder = new TextEncoder()
    const dataBuffer = encoder.encode(data)
    
    const iv = crypto.getRandomValues(new Uint8Array(12)) // 96-bit IV for GCM
    
    const encryptedBuffer = await crypto.subtle.encrypt(
      {
        name: this.ALGORITHM,
        iv: iv,
      },
      key,
      dataBuffer
    )

    return {
      encrypted: this.arrayBufferToBase64(encryptedBuffer),
      iv: this.arrayBufferToBase64(iv),
    }
  }

  // 데이터 복호화
  static async decrypt(encrypted: string, iv: string, key: CryptoKey): Promise<string> {
    const encryptedBuffer = this.base64ToArrayBuffer(encrypted)
    const ivBuffer = this.base64ToArrayBuffer(iv)

    const decryptedBuffer = await crypto.subtle.decrypt(
      {
        name: this.ALGORITHM,
        iv: ivBuffer,
      },
      key,
      encryptedBuffer
    )

    const decoder = new TextDecoder()
    return decoder.decode(decryptedBuffer)
  }

  // 유틸리티 메서드들
  private static arrayBufferToBase64(buffer: ArrayBuffer): string {
    const bytes = new Uint8Array(buffer)
    let binary = ''
    for (let i = 0; i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i])
    }
    return btoa(binary)
  }

  private static base64ToArrayBuffer(base64: string): ArrayBuffer {
    const binaryString = atob(base64)
    const bytes = new Uint8Array(binaryString.length)
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i)
    }
    return bytes.buffer
  }
}

// 보안 스토리지 클래스
export class SecureStorage {
  private key: CryptoKey | null = null

  async initialize() {
    // 기존 키가 있는지 확인
    const storedKey = localStorage.getItem('encryption_key')
    
    if (storedKey) {
      try {
        this.key = await ClientSideEncryption.importKey(storedKey)
      } catch (error) {
        console.error('Failed to import stored key:', error)
        await this.generateNewKey()
      }
    } else {
      await this.generateNewKey()
    }
  }

  private async generateNewKey() {
    this.key = await ClientSideEncryption.generateKey()
    const exportedKey = await ClientSideEncryption.exportKey(this.key)
    localStorage.setItem('encryption_key', exportedKey)
  }

  async setItem(key: string, value: any): Promise<void> {
    if (!this.key) {
      throw new Error('Encryption key not initialized')
    }

    const serialized = JSON.stringify(value)
    const { encrypted, iv } = await ClientSideEncryption.encrypt(serialized, this.key)
    
    localStorage.setItem(key, JSON.stringify({ encrypted, iv }))
  }

  async getItem<T>(key: string): Promise<T | null> {
    if (!this.key) {
      throw new Error('Encryption key not initialized')
    }

    const stored = localStorage.getItem(key)
    if (!stored) return null

    try {
      const { encrypted, iv } = JSON.parse(stored)
      const decrypted = await ClientSideEncryption.decrypt(encrypted, iv, this.key)
      return JSON.parse(decrypted)
    } catch (error) {
      console.error('Failed to decrypt stored data:', error)
      return null
    }
  }

  removeItem(key: string): void {
    localStorage.removeItem(key)
  }

  async clear(): Promise<void> {
    localStorage.clear()
    await this.generateNewKey()
  }
}

// React Hook for secure storage
export const useSecureStorage = () => {
  const storageRef = useRef<SecureStorage>()
  const [isInitialized, setIsInitialized] = useState(false)

  useEffect(() => {
    const initStorage = async () => {
      storageRef.current = new SecureStorage()
      await storageRef.current.initialize()
      setIsInitialized(true)
    }

    initStorage().catch(console.error)
  }, [])

  const setSecureItem = useCallback(async (key: string, value: any) => {
    if (!storageRef.current || !isInitialized) {
      throw new Error('Secure storage not initialized')
    }
    return storageRef.current.setItem(key, value)
  }, [isInitialized])

  const getSecureItem = useCallback(async <T>(key: string): Promise<T | null> => {
    if (!storageRef.current || !isInitialized) {
      return null
    }
    return storageRef.current.getItem<T>(key)
  }, [isInitialized])

  const removeSecureItem = useCallback((key: string) => {
    if (!storageRef.current || !isInitialized) {
      return
    }
    storageRef.current.removeItem(key)
  }, [isInitialized])

  return {
    isInitialized,
    setSecureItem,
    getSecureItem,
    removeSecureItem
  }
}
```

### **6. 보안 모니터링 및 알림**

**보안 이벤트 모니터링**
```typescript
// src/lib/security/security-monitor.ts
export class SecurityMonitor {
  private static events: SecurityEvent[] = []
  private static readonly MAX_EVENTS = 1000

  // 보안 이벤트 로깅
  static logSecurityEvent(event: {
    type: 'auth_failure' | 'xss_attempt' | 'csrf_violation' | 'suspicious_activity'
    severity: 'low' | 'medium' | 'high' | 'critical'
    details: any
    userAgent?: string
    ipAddress?: string
  }) {
    const securityEvent: SecurityEvent = {
      id: crypto.randomUUID(),
      timestamp: Date.now(),
      url: window.location.href,
      userAgent: navigator.userAgent,
      ...event
    }

    this.events.push(securityEvent)

    // 이벤트 수 제한
    if (this.events.length > this.MAX_EVENTS) {
      this.events.shift()
    }

    // 심각한 이벤트는 즉시 보고
    if (event.severity === 'critical' || event.severity === 'high') {
      this.reportSecurityEvent(securityEvent)
    }

    // 브라우저 콘솔에도 기록
    if (process.env.NODE_ENV === 'development') {
      console.warn('Security Event:', securityEvent)
    }
  }

  // 서버로 보안 이벤트 보고
  private static async reportSecurityEvent(event: SecurityEvent) {
    try {
      await fetch('/api/security/events', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(event),
        credentials: 'same-origin'
      })
    } catch (error) {
      console.error('Failed to report security event:', error)
    }
  }

  // 의심스러운 활동 감지
  static detectSuspiciousActivity() {
    // 짧은 시간 내 많은 실패 시도
    const recentFailures = this.events.filter(event => 
      event.type === 'auth_failure' && 
      Date.now() - event.timestamp < 60000 // 1분 이내
    )

    if (recentFailures.length >= 5) {
      this.logSecurityEvent({
        type: 'suspicious_activity',
        severity: 'high',
        details: {
          reason: 'Multiple authentication failures',
          count: recentFailures.length,
          timeframe: '1 minute'
        }
      })

      // 계정 일시 잠금 또는 추가 보안 조치
      this.triggerSecurityMeasures('multiple_auth_failures')
    }

    // 비정상적인 네비게이션 패턴 감지
    this.detectAbnormalNavigation()
  }

  private static detectAbnormalNavigation() {
    // 구현: 빠른 연속 페이지 변경, 봇 패턴 등 감지
  }

  private static triggerSecurityMeasures(reason: string) {
    // CAPTCHA 표시
    // 계정 일시 잠금
    // 관리자 알림
    console.warn('Security measures triggered:', reason)
  }

  // 정기적인 보안 상태 체크
  static performSecurityCheck() {
    const issues: string[] = []

    // HTTPS 확인
    if (location.protocol !== 'https:' && process.env.NODE_ENV === 'production') {
      issues.push('Non-HTTPS connection detected')
    }

    // 개발자 도구 열림 감지
    if (this.isDevToolsOpen()) {
      issues.push('Developer tools are open')
      this.logSecurityEvent({
        type: 'suspicious_activity',
        severity: 'medium',
        details: { reason: 'Developer tools detected' }
      })
    }

    // 콘솔 명령 실행 감지
    this.setupConsoleProtection()

    return issues
  }

  private static isDevToolsOpen(): boolean {
    const devtools = {
      open: false,
      orientation: null as 'vertical' | 'horizontal' | null
    }

    const threshold = 160

    setInterval(() => {
      if (window.outerHeight - window.innerHeight > threshold || 
          window.outerWidth - window.innerWidth > threshold) {
        if (!devtools.open) {
          devtools.open = true
          devtools.orientation = (window.outerHeight - window.innerHeight > threshold) ? 'vertical' : 'horizontal'
        }
      } else {
        devtools.open = false
        devtools.orientation = null
      }
    }, 500)

    return devtools.open
  }

  private static setupConsoleProtection() {
    // 콘솔 워닝 메시지
    const warningStyle = 'color: red; font-size: 20px; font-weight: bold;'
    console.log('%c🚨 보안 경고', warningStyle)
    console.log('%c이 콘솔은 개발자를 위한 것입니다. 악의적인 코드를 실행하지 마세요!', warningStyle)

    // 콘솔 명령 감지 (간단한 예시)
    const originalLog = console.log
    console.log = function(...args) {
      if (typeof args[0] === 'string' && args[0].includes('document.cookie')) {
        SecurityMonitor.logSecurityEvent({
          type: 'suspicious_activity',
          severity: 'high',
          details: { reason: 'Suspicious console activity', command: args[0] }
        })
      }
      return originalLog.apply(console, args)
    }
  }
}

interface SecurityEvent {
  id: string
  timestamp: number
  type: 'auth_failure' | 'xss_attempt' | 'csrf_violation' | 'suspicious_activity'
  severity: 'low' | 'medium' | 'high' | 'critical'
  details: any
  url: string
  userAgent: string
}

// React Hook for security monitoring
export const useSecurityMonitoring = () => {
  useEffect(() => {
    // 컴포넌트 마운트 시 보안 체크 시작
    const securityCheckInterval = setInterval(() => {
      SecurityMonitor.performSecurityCheck()
      SecurityMonitor.detectSuspiciousActivity()
    }, 30000) // 30초마다 체크

    return () => {
      clearInterval(securityCheckInterval)
    }
  }, [])

  const logSecurityEvent = useCallback((event: Parameters<typeof SecurityMonitor.logSecurityEvent>[0]) => {
    SecurityMonitor.logSecurityEvent(event)
  }, [])

  return { logSecurityEvent }
}
```

---

## 📊 **보안 대시보드**

### **보안 메트릭 수집**
```typescript
// src/lib/security/security-metrics.ts
export const collectSecurityMetrics = () => {
  return {
    authFailureRate: calculateAuthFailureRate(),
    xssAttempts: countXSSAttempts(),
    csrfViolations: countCSRFViolations(),
    suspiciousActivity: countSuspiciousActivity(),
    cspViolations: countCSPViolations()
  }
}
```

---

## ✅ **Definition of Done**

### **기능 요구사항**
- [ ] XSS 방어 시스템 구현
- [ ] CSRF 토큰 보호
- [ ] JWT 토큰 보안 관리
- [ ] Content Security Policy
- [ ] 클라이언트 사이드 암호화

### **기술 요구사항**
- [ ] DOMPurify를 활용한 HTML sanitization
- [ ] Web Crypto API 활용
- [ ] 보안 헤더 설정
- [ ] 토큰 자동 갱신

### **보안 요구사항**
- [ ] OWASP Top 10 방어
- [ ] 데이터 암호화 전송
- [ ] 안전한 토큰 저장
- [ ] 보안 이벤트 로깅

### **모니터링 요구사항**
- [ ] 보안 이벤트 실시간 모니터링
- [ ] 의심스러운 활동 감지
- [ ] 자동 보안 조치
- [ ] 보안 메트릭 수집

---

## 📚 **관련 문서 참조**

- [10. Security Best Practices](../ui-architecture/10-security-best-practices.md)
- [20. Error Handling](../ui-architecture/20-error-handling.md)
- [21. Observability & Monitoring](../ui-architecture/21-observability-monitoring.md)

---

**이 스토리는 바로캘린더의 종합적인 보안 시스템 구현을 위한 기술 가이드입니다. 다층 방어 체계를 통해 사용자 데이터와 시스템을 안전하게 보호합니다.**