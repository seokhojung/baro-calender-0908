# Story 2.4: ëª¨ë°”ì¼ ë°˜ì‘í˜• ë° PWA êµ¬í˜„

## ğŸ“‹ ë¬¸ì„œ ì •ë³´
- **ìŠ¤í† ë¦¬ ë²„ì „**: 2.0
- **ì‘ì„±ì¼**: 2025-08-28
- **ì‘ì„±ì**: Bob (Scrum Master Agent)  
- **í”„ë¡œì íŠ¸ëª…**: ë°”ë¡œìº˜ë¦°ë” (Baro Calendar)
- **Epic**: í”„ë¡ íŠ¸ì—”ë“œ ëª¨ë°”ì¼ ìµœì í™”
- **ìƒíƒœ**: Ready for Development

---

## ğŸ¯ **ìŠ¤í† ë¦¬ ëª©í‘œ**

**ì™„ì „í•œ ëª¨ë°”ì¼ ë°˜ì‘í˜• ë° PWA êµ¬í˜„**
- ëª¨ë°”ì¼ í¼ìŠ¤íŠ¸ ë°˜ì‘í˜• ë””ìì¸
- PWA ê¸°ëŠ¥ (ì˜¤í”„ë¼ì¸, ì„¤ì¹˜, í‘¸ì‹œ ì•Œë¦¼)
- í„°ì¹˜ ì œìŠ¤ì²˜ ë° ìŠ¤ì™€ì´í”„ ì¸í„°ë™ì…˜
- ì ì‘í˜• ë ˆì´ì•„ì›ƒ ë° ë„¤ë¹„ê²Œì´ì…˜
- ëª¨ë°”ì¼ ì„±ëŠ¥ ìµœì í™”

---

## ğŸ‘¤ **ì‚¬ìš©ì ìŠ¤í† ë¦¬**

**ì‚¬ìš©ìë¡œì„œ, ë‚˜ëŠ”:**
1. ëª¨ë°”ì¼ ë””ë°”ì´ìŠ¤ì—ì„œë„ í¸ë¦¬í•˜ê²Œ ìº˜ë¦°ë”ë¥¼ ì‚¬ìš©í•˜ê³  ì‹¶ë‹¤
2. ì•±ì²˜ëŸ¼ ì„¤ì¹˜í•˜ì—¬ í™ˆ í™”ë©´ì—ì„œ ë°”ë¡œ ì ‘ê·¼í•˜ê³  ì‹¶ë‹¤
3. ì˜¤í”„ë¼ì¸ì—ì„œë„ ì¼ì •ì„ í™•ì¸í•˜ê³  ì‘ì„±í•˜ê³  ì‹¶ë‹¤
4. í„°ì¹˜ ì œìŠ¤ì²˜ë¡œ ì§ê´€ì ìœ¼ë¡œ ì¡°ì‘í•˜ê³  ì‹¶ë‹¤
5. í‘¸ì‹œ ì•Œë¦¼ìœ¼ë¡œ ì¤‘ìš”í•œ ì¼ì •ì„ ë†“ì¹˜ì§€ ì•Šê³  ì‹¶ë‹¤

---

## ğŸ—ï¸ **ê¸°ìˆ ì  êµ¬í˜„ ìš”êµ¬ì‚¬í•­**

### **1. PWA ë§¤ë‹ˆí˜ìŠ¤íŠ¸ ë° ì„œë¹„ìŠ¤ ì›Œì»¤**

**PWA Manifest Configuration**
```json
// public/manifest.json
{
  "name": "ë°”ë¡œìº˜ë¦°ë” - Baro Calendar",
  "short_name": "ë°”ë¡œìº˜ë¦°ë”",
  "description": "í”„ë¡œì íŠ¸ ê¸°ë°˜ ìŠ¤ë§ˆíŠ¸ ì¼ì • ê´€ë¦¬ ì‹œìŠ¤í…œ",
  "start_url": "/",
  "display": "standalone",
  "theme_color": "#3B82F6",
  "background_color": "#ffffff",
  "orientation": "portrait",
  "categories": ["productivity", "business"],
  "icons": [
    {
      "src": "/icons/icon-72x72.png",
      "sizes": "72x72",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/icons/icon-96x96.png",
      "sizes": "96x96",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/icons/icon-128x128.png",
      "sizes": "128x128",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/icons/icon-144x144.png",
      "sizes": "144x144",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/icons/icon-152x152.png",
      "sizes": "152x152",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/icons/icon-384x384.png",
      "sizes": "384x384",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any maskable"
    }
  ],
  "screenshots": [
    {
      "src": "/screenshots/mobile-1.png",
      "sizes": "750x1334",
      "type": "image/png",
      "label": "Calendar Month View"
    },
    {
      "src": "/screenshots/mobile-2.png",
      "sizes": "750x1334",
      "type": "image/png",
      "label": "Event Creation"
    }
  ],
  "shortcuts": [
    {
      "name": "New Event",
      "short_name": "New",
      "description": "Create a new calendar event",
      "url": "/event/new",
      "icons": [{ "src": "/icons/new-event.png", "sizes": "192x192" }]
    },
    {
      "name": "Today",
      "short_name": "Today",
      "description": "View today's schedule",
      "url": "/today",
      "icons": [{ "src": "/icons/today.png", "sizes": "192x192" }]
    }
  ],
  "related_applications": [],
  "prefer_related_applications": false
}
```

**Service Worker Implementation**
```typescript
// public/sw.ts
/// <reference lib="webworker" />
declare const self: ServiceWorkerGlobalScope

const CACHE_NAME = 'baro-calendar-v1'
const STATIC_CACHE = 'static-v1'
const DYNAMIC_CACHE = 'dynamic-v1'

// Assets to cache on install
const STATIC_ASSETS = [
  '/',
  '/offline.html',
  '/css/app.css',
  '/js/app.js',
  '/icons/icon-192x192.png',
  '/fonts/inter-var.woff2'
]

// Install event - cache static assets
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(STATIC_CACHE).then((cache) => {
      return cache.addAll(STATIC_ASSETS)
    })
  )
  self.skipWaiting()
})

// Activate event - clean up old caches
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames
          .filter((name) => name !== CACHE_NAME && name !== STATIC_CACHE)
          .map((name) => caches.delete(name))
      )
    })
  )
  self.clients.claim()
})

// Fetch event - network first, cache fallback
self.addEventListener('fetch', (event) => {
  const { request } = event
  const url = new URL(request.url)
  
  // API calls - network first with cache fallback
  if (url.pathname.startsWith('/api/')) {
    event.respondWith(networkFirstStrategy(request))
    return
  }
  
  // Static assets - cache first
  if (isStaticAsset(url.pathname)) {
    event.respondWith(cacheFirstStrategy(request))
    return
  }
  
  // Default - network first
  event.respondWith(networkFirstStrategy(request))
})

// Cache strategies
async function cacheFirstStrategy(request: Request): Promise<Response> {
  const cached = await caches.match(request)
  if (cached) return cached
  
  try {
    const response = await fetch(request)
    if (response.ok) {
      const cache = await caches.open(DYNAMIC_CACHE)
      cache.put(request, response.clone())
    }
    return response
  } catch (error) {
    return caches.match('/offline.html') || new Response('Offline')
  }
}

async function networkFirstStrategy(request: Request): Promise<Response> {
  try {
    const response = await fetch(request)
    if (response.ok) {
      const cache = await caches.open(DYNAMIC_CACHE)
      cache.put(request, response.clone())
    }
    return response
  } catch (error) {
    const cached = await caches.match(request)
    return cached || new Response('Offline')
  }
}

function isStaticAsset(path: string): boolean {
  return /\.(js|css|png|jpg|jpeg|svg|woff2?)$/i.test(path)
}

// Background sync for offline actions
self.addEventListener('sync', (event) => {
  if (event.tag === 'sync-events') {
    event.waitUntil(syncOfflineEvents())
  }
})

async function syncOfflineEvents() {
  const db = await openDB('offline-events')
  const events = await db.getAll('pending')
  
  for (const event of events) {
    try {
      await fetch('/api/events', {
        method: 'POST',
        body: JSON.stringify(event),
        headers: { 'Content-Type': 'application/json' }
      })
      await db.delete('pending', event.id)
    } catch (error) {
      console.error('Sync failed for event:', event.id)
    }
  }
}

// Push notifications
self.addEventListener('push', (event) => {
  const data = event.data?.json() || {}
  
  event.waitUntil(
    self.registration.showNotification(data.title || 'ë°”ë¡œìº˜ë¦°ë” ì•Œë¦¼', {
      body: data.body || 'ìƒˆë¡œìš´ ì•Œë¦¼ì´ ìˆìŠµë‹ˆë‹¤',
      icon: '/icons/icon-192x192.png',
      badge: '/icons/badge-72x72.png',
      vibrate: [200, 100, 200],
      tag: data.tag || 'default',
      requireInteraction: data.requireInteraction || false,
      actions: data.actions || [
        { action: 'view', title: 'ë³´ê¸°' },
        { action: 'dismiss', title: 'ë‹«ê¸°' }
      ],
      data: data.payload
    })
  )
})

self.addEventListener('notificationclick', (event) => {
  event.notification.close()
  
  if (event.action === 'view') {
    event.waitUntil(
      clients.openWindow(event.notification.data?.url || '/')
    )
  }
})
```

### **2. ëª¨ë°”ì¼ ë°˜ì‘í˜• ìº˜ë¦°ë” ë·°**

**Mobile Calendar Component**
```typescript
// src/components/mobile/MobileCalendar.tsx
import React, { useState, useRef } from 'react'
import { useSwipeable } from 'react-swipeable'
import { useLongPress } from '@/hooks/useLongPress'
import { format, startOfMonth, endOfMonth } from 'date-fns'
import { CalendarEvent } from '@/types/calendar'
import { useCalendarStore } from '@/stores/calendarStore'

interface MobileCalendarProps {
  onEventClick?: (event: CalendarEvent) => void
  onDateClick?: (date: Date) => void
}

export const MobileCalendar: React.FC<MobileCalendarProps> = ({
  onEventClick,
  onDateClick
}) => {
  const {
    currentDate,
    events,
    navigateNext,
    navigatePrevious,
    viewMode
  } = useCalendarStore()
  
  const [isTransitioning, setIsTransitioning] = useState(false)
  const containerRef = useRef<HTMLDivElement>(null)
  
  // Swipe handlers
  const swipeHandlers = useSwipeable({
    onSwipedLeft: () => handleSwipe('next'),
    onSwipedRight: () => handleSwipe('prev'),
    onSwipedUp: () => handleViewChange('week'),
    onSwipedDown: () => handleViewChange('month'),
    preventScrollOnSwipe: true,
    trackMouse: false,
    trackTouch: true,
    delta: 50
  })
  
  const handleSwipe = (direction: 'next' | 'prev') => {
    if (isTransitioning) return
    
    setIsTransitioning(true)
    
    // Add animation class
    containerRef.current?.classList.add(
      direction === 'next' ? 'slide-left' : 'slide-right'
    )
    
    setTimeout(() => {
      if (direction === 'next') {
        navigateNext()
      } else {
        navigatePrevious()
      }
      
      // Remove animation class
      containerRef.current?.classList.remove('slide-left', 'slide-right')
      setIsTransitioning(false)
    }, 300)
  }
  
  const handleViewChange = (newView: 'week' | 'month') => {
    // Haptic feedback
    if ('vibrate' in navigator) {
      navigator.vibrate(10)
    }
    
    useCalendarStore.setState({ viewMode: newView })
  }
  
  return (
    <div className="mobile-calendar h-full flex flex-col">
      {/* Compact Header */}
      <MobileCalendarHeader />
      
      {/* Calendar Content */}
      <div
        ref={containerRef}
        {...swipeHandlers}
        className="flex-1 overflow-hidden relative"
      >
        {viewMode === 'month' ? (
          <MobileMonthView
            events={events}
            currentDate={currentDate}
            onEventClick={onEventClick}
            onDateClick={onDateClick}
          />
        ) : (
          <MobileWeekView
            events={events}
            currentDate={currentDate}
            onEventClick={onEventClick}
          />
        )}
        
        {/* Touch indicators */}
        <TouchIndicators />
      </div>
      
      {/* Quick Add Button */}
      <MobileQuickAddButton />
    </div>
  )
}

// Mobile Month View Component
const MobileMonthView: React.FC<{
  events: CalendarEvent[]
  currentDate: Date
  onEventClick?: (event: CalendarEvent) => void
  onDateClick?: (date: Date) => void
}> = ({ events, currentDate, onEventClick, onDateClick }) => {
  const weeks = getCalendarWeeks(currentDate)
  
  return (
    <div className="grid grid-rows-6 h-full">
      {/* Weekday headers */}
      <div className="grid grid-cols-7 text-center text-xs font-medium text-muted-foreground border-b">
        {['S', 'M', 'T', 'W', 'T', 'F', 'S'].map((day) => (
          <div key={day} className="py-2">
            {day}
          </div>
        ))}
      </div>
      
      {/* Calendar days */}
      {weeks.map((week, weekIndex) => (
        <div key={weekIndex} className="grid grid-cols-7 border-b">
          {week.map((date, dayIndex) => (
            <MobileDayCell
              key={dayIndex}
              date={date}
              events={getEventsForDate(events, date)}
              isCurrentMonth={isSameMonth(date, currentDate)}
              onDateClick={onDateClick}
              onEventClick={onEventClick}
            />
          ))}
        </div>
      ))}
    </div>
  )
}

// Mobile Day Cell Component
const MobileDayCell: React.FC<{
  date: Date
  events: CalendarEvent[]
  isCurrentMonth: boolean
  onDateClick?: (date: Date) => void
  onEventClick?: (event: CalendarEvent) => void
}> = ({ date, events, isCurrentMonth, onDateClick, onEventClick }) => {
  const longPressHandlers = useLongPress(() => {
    // Long press to create event
    onDateClick?.(date)
  }, 500)
  
  return (
    <div
      {...longPressHandlers}
      onClick={() => onDateClick?.(date)}
      className={cn(
        "relative p-1 min-h-[60px] border-r",
        !isCurrentMonth && "bg-muted/30 text-muted-foreground",
        isToday(date) && "bg-primary/10"
      )}
    >
      {/* Date number */}
      <div className={cn(
        "text-xs font-medium",
        isToday(date) && "text-primary"
      )}>
        {format(date, 'd')}
      </div>
      
      {/* Event dots */}
      <div className="flex flex-wrap gap-0.5 mt-1">
        {events.slice(0, 3).map((event) => (
          <div
            key={event.id}
            onClick={(e) => {
              e.stopPropagation()
              onEventClick?.(event)
            }}
            className="w-1.5 h-1.5 rounded-full"
            style={{ backgroundColor: event.projectColor }}
          />
        ))}
        {events.length > 3 && (
          <span className="text-[8px] text-muted-foreground">
            +{events.length - 3}
          </span>
        )}
      </div>
    </div>
  )
}
```

### **3. í„°ì¹˜ ì œìŠ¤ì²˜ ë° ì¸í„°ë™ì…˜**

**Touch Gesture Handlers**
```typescript
// src/hooks/useTouchGestures.ts
import { useRef, useEffect } from 'react'

interface TouchGestureOptions {
  onSwipeLeft?: () => void
  onSwipeRight?: () => void
  onSwipeUp?: () => void
  onSwipeDown?: () => void
  onPinchZoom?: (scale: number) => void
  onLongPress?: (position: { x: number; y: number }) => void
  threshold?: number
  longPressDelay?: number
}

export const useTouchGestures = (
  elementRef: React.RefObject<HTMLElement>,
  options: TouchGestureOptions
) => {
  const touchStart = useRef<{ x: number; y: number; time: number } | null>(null)
  const longPressTimer = useRef<NodeJS.Timeout | null>(null)
  const pinchStart = useRef<number | null>(null)
  
  useEffect(() => {
    const element = elementRef.current
    if (!element) return
    
    const threshold = options.threshold || 50
    const longPressDelay = options.longPressDelay || 500
    
    const handleTouchStart = (e: TouchEvent) => {
      if (e.touches.length === 1) {
        const touch = e.touches[0]
        touchStart.current = {
          x: touch.clientX,
          y: touch.clientY,
          time: Date.now()
        }
        
        // Set up long press
        longPressTimer.current = setTimeout(() => {
          if (touchStart.current && options.onLongPress) {
            options.onLongPress({
              x: touchStart.current.x,
              y: touchStart.current.y
            })
            
            // Haptic feedback
            if ('vibrate' in navigator) {
              navigator.vibrate(50)
            }
          }
        }, longPressDelay)
      } else if (e.touches.length === 2) {
        // Pinch gesture start
        const distance = getPinchDistance(e.touches)
        pinchStart.current = distance
      }
    }
    
    const handleTouchMove = (e: TouchEvent) => {
      // Cancel long press on move
      if (longPressTimer.current) {
        clearTimeout(longPressTimer.current)
        longPressTimer.current = null
      }
      
      if (e.touches.length === 2 && pinchStart.current) {
        // Handle pinch zoom
        const currentDistance = getPinchDistance(e.touches)
        const scale = currentDistance / pinchStart.current
        options.onPinchZoom?.(scale)
      }
    }
    
    const handleTouchEnd = (e: TouchEvent) => {
      // Clear long press timer
      if (longPressTimer.current) {
        clearTimeout(longPressTimer.current)
        longPressTimer.current = null
      }
      
      if (!touchStart.current) return
      
      const touch = e.changedTouches[0]
      const deltaX = touch.clientX - touchStart.current.x
      const deltaY = touch.clientY - touchStart.current.y
      const deltaTime = Date.now() - touchStart.current.time
      
      // Detect swipe (must be quick and exceed threshold)
      if (deltaTime < 300) {
        if (Math.abs(deltaX) > Math.abs(deltaY)) {
          // Horizontal swipe
          if (Math.abs(deltaX) > threshold) {
            if (deltaX > 0) {
              options.onSwipeRight?.()
            } else {
              options.onSwipeLeft?.()
            }
          }
        } else {
          // Vertical swipe
          if (Math.abs(deltaY) > threshold) {
            if (deltaY > 0) {
              options.onSwipeDown?.()
            } else {
              options.onSwipeUp?.()
            }
          }
        }
      }
      
      touchStart.current = null
      pinchStart.current = null
    }
    
    element.addEventListener('touchstart', handleTouchStart, { passive: false })
    element.addEventListener('touchmove', handleTouchMove, { passive: false })
    element.addEventListener('touchend', handleTouchEnd, { passive: false })
    
    return () => {
      element.removeEventListener('touchstart', handleTouchStart)
      element.removeEventListener('touchmove', handleTouchMove)
      element.removeEventListener('touchend', handleTouchEnd)
      
      if (longPressTimer.current) {
        clearTimeout(longPressTimer.current)
      }
    }
  }, [elementRef, options])
}

function getPinchDistance(touches: TouchList): number {
  const dx = touches[0].clientX - touches[1].clientX
  const dy = touches[0].clientY - touches[1].clientY
  return Math.sqrt(dx * dx + dy * dy)
}
```

### **4. ì ì‘í˜• ë„¤ë¹„ê²Œì´ì…˜**

**Adaptive Navigation Component**
```typescript
// src/components/mobile/MobileNavigation.tsx
import React, { useState } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
import { 
  Calendar, 
  Plus, 
  Search, 
  Menu, 
  User,
  Home,
  Settings
} from 'lucide-react'

export const MobileNavigation: React.FC = () => {
  const [activeTab, setActiveTab] = useState('calendar')
  const [isMenuOpen, setIsMenuOpen] = useState(false)
  
  return (
    <>
      {/* Bottom Navigation Bar */}
      <nav className="fixed bottom-0 left-0 right-0 bg-background border-t z-50 safe-area-pb">
        <div className="flex justify-around items-center h-16">
          <NavItem
            icon={<Home />}
            label="Home"
            isActive={activeTab === 'home'}
            onClick={() => setActiveTab('home')}
          />
          <NavItem
            icon={<Calendar />}
            label="Calendar"
            isActive={activeTab === 'calendar'}
            onClick={() => setActiveTab('calendar')}
          />
          <NavItem
            icon={<Plus />}
            label="Add"
            isActive={false}
            onClick={() => openQuickAdd()}
            isAccent
          />
          <NavItem
            icon={<Search />}
            label="Search"
            isActive={activeTab === 'search'}
            onClick={() => setActiveTab('search')}
          />
          <NavItem
            icon={<Menu />}
            label="Menu"
            isActive={activeTab === 'menu'}
            onClick={() => setIsMenuOpen(true)}
          />
        </div>
      </nav>
      
      {/* Slide-out Menu */}
      <AnimatePresence>
        {isMenuOpen && (
          <MobileMenu onClose={() => setIsMenuOpen(false)} />
        )}
      </AnimatePresence>
    </>
  )
}

const NavItem: React.FC<{
  icon: React.ReactNode
  label: string
  isActive: boolean
  onClick: () => void
  isAccent?: boolean
}> = ({ icon, label, isActive, onClick, isAccent }) => {
  return (
    <button
      onClick={onClick}
      className={cn(
        "flex flex-col items-center justify-center p-2 rounded-lg transition-colors",
        isActive && "text-primary",
        isAccent && "bg-primary text-primary-foreground rounded-full p-3 -mt-4"
      )}
    >
      <div className={cn(
        "transition-transform",
        isActive && "scale-110"
      )}>
        {icon}
      </div>
      {!isAccent && (
        <span className="text-[10px] mt-1">{label}</span>
      )}
    </button>
  )
}

const MobileMenu: React.FC<{ onClose: () => void }> = ({ onClose }) => {
  return (
    <>
      {/* Backdrop */}
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
        onClick={onClose}
        className="fixed inset-0 bg-black/50 z-50"
      />
      
      {/* Menu Panel */}
      <motion.div
        initial={{ x: '100%' }}
        animate={{ x: 0 }}
        exit={{ x: '100%' }}
        transition={{ type: 'spring', damping: 20 }}
        className="fixed right-0 top-0 bottom-0 w-80 bg-background shadow-xl z-50"
      >
        <div className="p-4">
          <h2 className="text-lg font-semibold mb-4">Menu</h2>
          {/* Menu items */}
        </div>
      </motion.div>
    </>
  )
}
```

### **5. í‘¸ì‹œ ì•Œë¦¼ ê´€ë¦¬**

**Push Notification Manager**
```typescript
// src/lib/notifications/push-manager.ts
export class PushNotificationManager {
  private registration: ServiceWorkerRegistration | null = null
  private subscription: PushSubscription | null = null
  
  async initialize() {
    // Check if Push API is supported
    if (!('PushManager' in window)) {
      console.warn('Push notifications not supported')
      return false
    }
    
    // Get service worker registration
    this.registration = await navigator.serviceWorker.ready
    
    // Check existing subscription
    this.subscription = await this.registration.pushManager.getSubscription()
    
    return !!this.subscription
  }
  
  async requestPermission(): Promise<NotificationPermission> {
    const permission = await Notification.requestPermission()
    
    if (permission === 'granted') {
      await this.subscribe()
    }
    
    return permission
  }
  
  async subscribe() {
    if (!this.registration) {
      throw new Error('Service worker not registered')
    }
    
    try {
      this.subscription = await this.registration.pushManager.subscribe({
        userVisibleOnly: true,
        applicationServerKey: this.urlBase64ToUint8Array(
          process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY!
        )
      })
      
      // Send subscription to server
      await this.sendSubscriptionToServer(this.subscription)
      
      return this.subscription
    } catch (error) {
      console.error('Failed to subscribe to push notifications:', error)
      throw error
    }
  }
  
  async unsubscribe() {
    if (!this.subscription) return
    
    try {
      await this.subscription.unsubscribe()
      await this.removeSubscriptionFromServer()
      this.subscription = null
    } catch (error) {
      console.error('Failed to unsubscribe:', error)
    }
  }
  
  async sendTestNotification() {
    if (!this.registration) return
    
    const notification = await this.registration.showNotification(
      'í…ŒìŠ¤íŠ¸ ì•Œë¦¼',
      {
        body: 'í‘¸ì‹œ ì•Œë¦¼ì´ ì •ìƒì ìœ¼ë¡œ ì‘ë™í•©ë‹ˆë‹¤!',
        icon: '/icons/icon-192x192.png',
        badge: '/icons/badge-72x72.png',
        vibrate: [200, 100, 200],
        tag: 'test',
        requireInteraction: false,
        actions: [
          { action: 'view', title: 'ë³´ê¸°' },
          { action: 'dismiss', title: 'ë‹«ê¸°' }
        ]
      }
    )
  }
  
  private async sendSubscriptionToServer(subscription: PushSubscription) {
    const response = await fetch('/api/notifications/subscribe', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(subscription)
    })
    
    if (!response.ok) {
      throw new Error('Failed to send subscription to server')
    }
  }
  
  private async removeSubscriptionFromServer() {
    await fetch('/api/notifications/unsubscribe', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' }
    })
  }
  
  private urlBase64ToUint8Array(base64String: string): Uint8Array {
    const padding = '='.repeat((4 - base64String.length % 4) % 4)
    const base64 = (base64String + padding)
      .replace(/\-/g, '+')
      .replace(/_/g, '/')
    
    const rawData = window.atob(base64)
    const outputArray = new Uint8Array(rawData.length)
    
    for (let i = 0; i < rawData.length; ++i) {
      outputArray[i] = rawData.charCodeAt(i)
    }
    
    return outputArray
  }
  
  isSubscribed(): boolean {
    return !!this.subscription
  }
  
  getSubscription(): PushSubscription | null {
    return this.subscription
  }
}

// Hook for using push notifications
export const usePushNotifications = () => {
  const [permission, setPermission] = useState<NotificationPermission>('default')
  const [isSubscribed, setIsSubscribed] = useState(false)
  const managerRef = useRef<PushNotificationManager>()
  
  useEffect(() => {
    const initPush = async () => {
      managerRef.current = new PushNotificationManager()
      const subscribed = await managerRef.current.initialize()
      setIsSubscribed(subscribed)
      setPermission(Notification.permission)
    }
    
    initPush()
  }, [])
  
  const subscribe = async () => {
    if (!managerRef.current) return
    
    const perm = await managerRef.current.requestPermission()
    setPermission(perm)
    setIsSubscribed(perm === 'granted')
  }
  
  const unsubscribe = async () => {
    if (!managerRef.current) return
    
    await managerRef.current.unsubscribe()
    setIsSubscribed(false)
  }
  
  return {
    permission,
    isSubscribed,
    subscribe,
    unsubscribe,
    sendTest: () => managerRef.current?.sendTestNotification()
  }
}
```

### **6. ëª¨ë°”ì¼ ì„±ëŠ¥ ìµœì í™”**

**Mobile Performance Optimizations**
```typescript
// src/lib/mobile/performance.ts
export class MobilePerformanceOptimizer {
  // Detect device capabilities
  static getDeviceCapabilities() {
    return {
      hasTouch: 'ontouchstart' in window,
      hasPointer: 'PointerEvent' in window,
      deviceMemory: (navigator as any).deviceMemory || 4,
      hardwareConcurrency: navigator.hardwareConcurrency || 2,
      connection: (navigator as any).connection,
      saveData: (navigator as any).connection?.saveData || false
    }
  }
  
  // Adaptive loading based on device
  static getLoadingStrategy() {
    const caps = this.getDeviceCapabilities()
    
    if (caps.saveData || caps.deviceMemory < 4) {
      return 'minimal' // Load minimum resources
    }
    
    if (caps.deviceMemory < 8) {
      return 'standard' // Standard loading
    }
    
    return 'full' // Load all features
  }
  
  // Viewport optimization
  static optimizeViewport() {
    const viewport = document.querySelector('meta[name="viewport"]')
    if (viewport) {
      viewport.setAttribute('content', 
        'width=device-width, initial-scale=1, maximum-scale=5, user-scalable=yes, viewport-fit=cover'
      )
    }
  }
  
  // Image loading optimization
  static lazyLoadImages() {
    if ('IntersectionObserver' in window) {
      const images = document.querySelectorAll('img[data-src]')
      const imageObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const img = entry.target as HTMLImageElement
            img.src = img.dataset.src!
            img.removeAttribute('data-src')
            imageObserver.unobserve(img)
          }
        })
      })
      
      images.forEach(img => imageObserver.observe(img))
    }
  }
  
  // Touch event optimization
  static optimizeTouchEvents() {
    // Add passive listeners for better scroll performance
    document.addEventListener('touchstart', () => {}, { passive: true })
    document.addEventListener('touchmove', () => {}, { passive: true })
    
    // Disable touch delay
    const style = document.createElement('style')
    style.textContent = `
      * {
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
      }
      
      button, a, [role="button"] {
        touch-action: manipulation;
      }
    `
    document.head.appendChild(style)
  }
}

// Hook for responsive design
export const useResponsiveDesign = () => {
  const [viewport, setViewport] = useState({
    width: 0,
    height: 0,
    isMobile: false,
    isTablet: false,
    isDesktop: false,
    orientation: 'portrait' as 'portrait' | 'landscape'
  })
  
  useEffect(() => {
    const updateViewport = () => {
      const width = window.innerWidth
      const height = window.innerHeight
      
      setViewport({
        width,
        height,
        isMobile: width < 768,
        isTablet: width >= 768 && width < 1024,
        isDesktop: width >= 1024,
        orientation: width > height ? 'landscape' : 'portrait'
      })
    }
    
    updateViewport()
    window.addEventListener('resize', updateViewport)
    window.addEventListener('orientationchange', updateViewport)
    
    return () => {
      window.removeEventListener('resize', updateViewport)
      window.removeEventListener('orientationchange', updateViewport)
    }
  }, [])
  
  return viewport
}
```

---

## ğŸ¨ **ì‚¬ìš©ì ê²½í—˜ (UX) ì„¤ê³„**

### **1. ì„¤ì¹˜ í”„ë¡¬í”„íŠ¸**

```typescript
// src/components/pwa/InstallPrompt.tsx
export const InstallPrompt: React.FC = () => {
  const [deferredPrompt, setDeferredPrompt] = useState<any>(null)
  const [showPrompt, setShowPrompt] = useState(false)
  
  useEffect(() => {
    const handler = (e: any) => {
      e.preventDefault()
      setDeferredPrompt(e)
      setShowPrompt(true)
    }
    
    window.addEventListener('beforeinstallprompt', handler)
    return () => window.removeEventListener('beforeinstallprompt', handler)
  }, [])
  
  const handleInstall = async () => {
    if (!deferredPrompt) return
    
    deferredPrompt.prompt()
    const { outcome } = await deferredPrompt.userChoice
    
    if (outcome === 'accepted') {
      console.log('App installed')
    }
    
    setDeferredPrompt(null)
    setShowPrompt(false)
  }
  
  if (!showPrompt) return null
  
  return (
    <motion.div
      initial={{ y: 100, opacity: 0 }}
      animate={{ y: 0, opacity: 1 }}
      exit={{ y: 100, opacity: 0 }}
      className="fixed bottom-20 left-4 right-4 bg-primary text-primary-foreground p-4 rounded-lg shadow-lg z-50"
    >
      <h3 className="font-semibold mb-2">ì•±ìœ¼ë¡œ ì„¤ì¹˜í•˜ê¸°</h3>
      <p className="text-sm mb-3">
        í™ˆ í™”ë©´ì— ì¶”ê°€í•˜ì—¬ ë” ë¹ ë¥´ê²Œ ì ‘ê·¼í•˜ì„¸ìš”
      </p>
      <div className="flex gap-2">
        <Button variant="secondary" size="sm" onClick={handleInstall}>
          ì„¤ì¹˜
        </Button>
        <Button 
          variant="ghost" 
          size="sm" 
          onClick={() => setShowPrompt(false)}
        >
          ë‚˜ì¤‘ì—
        </Button>
      </div>
    </motion.div>
  )
}
```

---

## ğŸ“Š **ì„±ëŠ¥ ìµœì í™”**

### **Critical CSS ì¸ë¼ì¸**

```typescript
// src/lib/critical-css.ts
export const getCriticalCSS = () => `
  /* Critical CSS for immediate render */
  :root {
    --primary: #3B82F6;
    --background: #ffffff;
    --foreground: #0f172a;
  }
  
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    background: var(--background);
    color: var(--foreground);
  }
  
  .skeleton {
    background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
    background-size: 200% 100%;
    animation: loading 1.5s infinite;
  }
  
  @keyframes loading {
    0% { background-position: 200% 0; }
    100% { background-position: -200% 0; }
  }
`
```

---

## âœ… **Definition of Done**

### **ê¸°ëŠ¥ ìš”êµ¬ì‚¬í•­**
- [ ] PWA ë§¤ë‹ˆí˜ìŠ¤íŠ¸ ë° ì„œë¹„ìŠ¤ ì›Œì»¤
- [ ] ëª¨ë°”ì¼ ë°˜ì‘í˜• ë ˆì´ì•„ì›ƒ
- [ ] í„°ì¹˜ ì œìŠ¤ì²˜ ì§€ì›
- [ ] ì˜¤í”„ë¼ì¸ ëª¨ë“œ
- [ ] í‘¸ì‹œ ì•Œë¦¼

### **ê¸°ìˆ  ìš”êµ¬ì‚¬í•­**
- [ ] Service Worker êµ¬í˜„
- [ ] IndexedDB ì˜¤í”„ë¼ì¸ ì €ì¥
- [ ] ì ì‘í˜• ë¡œë”© ì „ëµ
- [ ] ì„¤ì¹˜ í”„ë¡¬í”„íŠ¸

### **ì„±ëŠ¥ ìš”êµ¬ì‚¬í•­**
- [ ] Lighthouse PWA ì ìˆ˜ 90+
- [ ] First Paint < 1.5s
- [ ] TTI < 3.5s
- [ ] 60fps ìŠ¤í¬ë¡¤ ì„±ëŠ¥

### **í…ŒìŠ¤íŠ¸ ìš”êµ¬ì‚¬í•­**
- [ ] ë‹¤ì–‘í•œ ë””ë°”ì´ìŠ¤ í…ŒìŠ¤íŠ¸
- [ ] ì˜¤í”„ë¼ì¸ ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸
- [ ] í„°ì¹˜ ì œìŠ¤ì²˜ í…ŒìŠ¤íŠ¸
- [ ] PWA ì„¤ì¹˜ í…ŒìŠ¤íŠ¸

---

## ğŸ“š **ê´€ë ¨ ë¬¸ì„œ ì°¸ì¡°**

- [13. PWA & Mobile Responsive](../ui-architecture/13-pwa-mobile-responsive.md)
- [08. Runtime Performance](../ui-architecture/08-runtime-performance.md)
- [07. Theme & Responsive Design](../ui-architecture/07-theme-responsive-design.md)

---

**ì´ ìŠ¤í† ë¦¬ëŠ” ë°”ë¡œìº˜ë¦°ë”ì˜ ëª¨ë°”ì¼ ë°˜ì‘í˜• ë° PWA êµ¬í˜„ì„ ìœ„í•œ ì¢…í•©ì ì¸ ê¸°ìˆ  ê°€ì´ë“œì…ë‹ˆë‹¤. ë„¤ì´í‹°ë¸Œ ì•±ê³¼ ê°™ì€ ì‚¬ìš©ì ê²½í—˜ì„ ì›¹ì—ì„œ ì œê³µí•˜ì—¬ ì–¸ì œ ì–´ë””ì„œë‚˜ í¸ë¦¬í•˜ê²Œ ì¼ì •ì„ ê´€ë¦¬í•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤.**