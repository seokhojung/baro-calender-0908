# Story 2.4: Ï†ëÍ∑ºÏÑ± Íµ¨ÌòÑ ÏãúÏä§ÌÖú

## Status
Ready for Development

## Priority & Dependencies
- **Priority**: P1 (High)
- **Story Points**: 3
- **Dependencies**: [All UI Stories]
- **Blocked By**: None

## Success Metrics
- **Business KPI**: 
  - WCAG 2.2 AA Ï§ÄÏàòÎ•† 100%
  - Ïû•Ïï†Ïù∏ ÏÇ¨Ïö©Ïûê ÎπÑÏú® 5% Ï¶ùÍ∞Ä
  - Ï†ëÍ∑ºÏÑ± Í∞êÏÇ¨ Í≤∞Í≥º AÎì±Í∏â
- **Technical KPI**:
  - ÏÉâÏÉÅ ÎåÄÎπÑÎπÑ 4.5:1 Ïù¥ÏÉÅ
  - ÌÑ∞Ïπò ÌÉÄÍ≥É ÏµúÏÜå 44px
  - jest-axe ÌÖåÏä§Ìä∏ 100% ÌÜµÍ≥º
- **Definition of Success**: WCAG 2.2 AA ÏôÑÏ†Ñ Ï§ÄÏàò, ÏûêÎèô ÌÖåÏä§Ìä∏ ÌÜµÍ≥º

## Story
**As a** Ïû•Ïï†Í∞Ä ÏûàÎäî ÏÇ¨Ïö©Ïûê,
**I want** Ïä§ÌÅ¨Î¶∞ Î¶¨Îçî, ÌÇ§Î≥¥Îìú, Í≥†ÎåÄÎπÑ Î™®Îìú Îì±ÏúºÎ°ú ÏôÑÏ†ÑÌûà Ï†ëÍ∑º Í∞ÄÎä•Ìïú Ï∫òÎ¶∞ÎçîÎ•º ÏÇ¨Ïö©ÌïòÏó¨,
**so that** ÎàÑÍµ¨ÎÇò Ï∞®Î≥Ñ ÏóÜÏù¥ Ìé∏Î¶¨ÌïòÍ≤å ÏùºÏ†ïÏùÑ Í¥ÄÎ¶¨Ìï† Ïàò ÏûàÎã§.

## Acceptance Criteria

---

## üéØ **Ïä§ÌÜ†Î¶¨ Î™©Ìëú**

**ÏôÑÏ†ÑÌïú Ï†ëÍ∑ºÏÑ±(Accessibility) ÏãúÏä§ÌÖú Íµ¨ÌòÑ**
- WCAG 2.1 AA Í∏∞Ï§Ä Ï§ÄÏàò
- Ïä§ÌÅ¨Î¶∞ Î¶¨Îçî ÏôÑÏ†Ñ ÏßÄÏõê
- ÌÇ§Î≥¥Îìú Ï†ÑÏö© ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò
- ÏÉâÏÉÅ ÎåÄÎπÑÏú® Î∞è Í≥†ÎåÄÎπÑ Î™®Îìú
- Îã§Íµ≠Ïñ¥ Î∞è RTL ÏßÄÏõê

---

## üë§ **ÏÇ¨Ïö©Ïûê Ïä§ÌÜ†Î¶¨**

**ÏÇ¨Ïö©ÏûêÎ°úÏÑú, ÎÇòÎäî:**
1. Ïä§ÌÅ¨Î¶∞ Î¶¨ÎçîÎ•º ÏÇ¨Ïö©Ìï¥ÎèÑ Î™®Îì† Í∏∞Îä•Ïóê Ï†ëÍ∑ºÌïòÍ≥† Ïã∂Îã§
2. ÌÇ§Î≥¥ÎìúÎßåÏúºÎ°úÎèÑ ÏôÑÏ†ÑÌûà Ïï±ÏùÑ Ï°∞ÏûëÌïòÍ≥† Ïã∂Îã§
3. ÏãúÍ∞Å Ïû•Ïï†Í∞Ä ÏûàÏñ¥ÎèÑ Ï∂©Î∂ÑÌïú ÏÉâÏÉÅ ÎåÄÎπÑÎ°ú ÎÇ¥Ïö©ÏùÑ ÏùΩÍ≥† Ïã∂Îã§
4. Ïö¥Îèô Ïû•Ïï†Í∞Ä ÏûàÏñ¥ÎèÑ Ï∂©Î∂ÑÌïú ÏãúÍ∞ÑÏùÑ Í∞ñÍ≥† Ï°∞ÏûëÌïòÍ≥† Ïã∂Îã§
5. Îã§ÏñëÌïú Ïñ∏Ïñ¥ÏôÄ Î¨∏ÌôîÍ∂åÏóêÏÑú ÏûêÏó∞Ïä§ÎüΩÍ≤å ÏÇ¨Ïö©ÌïòÍ≥† Ïã∂Îã§

---

## üèóÔ∏è **Í∏∞Ïà†Ï†Å Íµ¨ÌòÑ ÏöîÍµ¨ÏÇ¨Ìï≠**

### **1. ARIA Î∞è ÏãúÎß®Ìã± HTML**

**Ï†ëÍ∑º Í∞ÄÎä•Ìïú Ï∫òÎ¶∞Îçî Ïª¥Ìè¨ÎÑåÌä∏**
```typescript
// src/components/accessibility/AccessibleCalendar.tsx
import React, { useRef, useEffect, useState } from 'react'
import { format, isSameDay, startOfMonth, endOfMonth } from 'date-fns'
import { useKeyboardNavigation } from '@/hooks/useKeyboardNavigation'
import { useScreenReader } from '@/hooks/useScreenReader'

interface AccessibleCalendarProps {
  selectedDate: Date | null
  onDateSelect: (date: Date) => void
  onEventSelect: (event: CalendarEvent) => void
  events: CalendarEvent[]
}

export const AccessibleCalendar: React.FC<AccessibleCalendarProps> = ({
  selectedDate,
  onDateSelect,
  onEventSelect,
  events
}) => {
  const [focusedDate, setFocusedDate] = useState(new Date())
  const [announcements, setAnnouncements] = useState<string>('')
  const gridRef = useRef<HTMLDivElement>(null)
  const { announce } = useScreenReader()
  
  // ÌÇ§Î≥¥Îìú ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò
  const { handleKeyDown } = useKeyboardNavigation({
    onArrowLeft: () => navigateDate(-1, 0),
    onArrowRight: () => navigateDate(1, 0),
    onArrowUp: () => navigateDate(0, -1),
    onArrowDown: () => navigateDate(0, 1),
    onEnter: () => handleDateSelect(focusedDate),
    onSpace: () => handleDateSelect(focusedDate),
    onHome: () => goToStartOfWeek(),
    onEnd: () => goToEndOfWeek(),
    onPageUp: () => navigateMonth(-1),
    onPageDown: () => navigateMonth(1),
  })
  
  const navigateDate = (dayDelta: number, weekDelta: number) => {
    const newDate = new Date(focusedDate)
    newDate.setDate(newDate.getDate() + dayDelta + (weekDelta * 7))
    setFocusedDate(newDate)
    
    // ÏùåÏÑ± ÏïàÎÇ¥
    const dateStr = format(newDate, 'EEEE, MMMM do, yyyy')
    const eventCount = getEventsForDate(events, newDate).length
    const announcement = eventCount > 0 
      ? `${dateStr}, ${eventCount} events`
      : dateStr
    
    announce(announcement)
  }
  
  const handleDateSelect = (date: Date) => {
    onDateSelect(date)
    const eventsOnDate = getEventsForDate(events, date)
    
    if (eventsOnDate.length > 0) {
      announce(`Selected ${format(date, 'MMMM do')}, ${eventsOnDate.length} events available`)
    } else {
      announce(`Selected ${format(date, 'MMMM do')}, no events`)
    }
  }
  
  return (
    <div className="accessible-calendar">
      {/* Skip link */}
      <a 
        href="#main-content" 
        className="sr-only focus:not-sr-only focus:absolute focus:top-4 focus:left-4 z-50 bg-primary text-primary-foreground px-4 py-2 rounded"
      >
        Skip to main content
      </a>
      
      {/* Calendar instructions */}
      <div id="calendar-instructions" className="sr-only">
        Use arrow keys to navigate dates. Press Enter or Space to select a date.
        Press Page Up or Page Down to navigate months.
        Press Home to go to start of week, End to go to end of week.
      </div>
      
      {/* Live region for announcements */}
      <div 
        aria-live="polite" 
        aria-atomic="true" 
        className="sr-only"
        role="status"
      >
        {announcements}
      </div>
      
      {/* Calendar header */}
      <header className="calendar-header mb-4">
        <h2 id="calendar-title" className="text-xl font-semibold">
          {format(focusedDate, 'MMMM yyyy')}
        </h2>
        <div className="calendar-nav" role="group" aria-label="Calendar navigation">
          <button
            onClick={() => navigateMonth(-1)}
            aria-label={`Previous month, ${format(addMonths(focusedDate, -1), 'MMMM yyyy')}`}
            className="btn btn-secondary"
          >
            <ChevronLeft aria-hidden="true" />
            <span className="sr-only">Previous month</span>
          </button>
          <button
            onClick={() => navigateMonth(1)}
            aria-label={`Next month, ${format(addMonths(focusedDate, 1), 'MMMM yyyy')}`}
            className="btn btn-secondary"
          >
            <ChevronRight aria-hidden="true" />
            <span className="sr-only">Next month</span>
          </button>
        </div>
      </header>
      
      {/* Calendar grid */}
      <div
        ref={gridRef}
        role="grid"
        aria-labelledby="calendar-title"
        aria-describedby="calendar-instructions"
        onKeyDown={handleKeyDown}
        tabIndex={0}
        className="calendar-grid focus:outline-none focus:ring-2 focus:ring-primary"
      >
        {/* Weekday headers */}
        <div role="row" className="weekday-headers">
          {['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'].map((day) => (
            <div
              key={day}
              role="columnheader"
              className="weekday-header font-medium text-center p-2"
              abbr={day.slice(0, 3)}
            >
              <span aria-hidden="true">{day.slice(0, 3)}</span>
              <span className="sr-only">{day}</span>
            </div>
          ))}
        </div>
        
        {/* Calendar days */}
        {getCalendarWeeks(focusedDate).map((week, weekIndex) => (
          <div key={weekIndex} role="row" className="calendar-week">
            {week.map((date, dayIndex) => {
              const dayEvents = getEventsForDate(events, date)
              const isCurrentMonth = isSameMonth(date, focusedDate)
              const isSelected = selectedDate && isSameDay(date, selectedDate)
              const isFocused = isSameDay(date, focusedDate)
              const isToday = isSameDay(date, new Date())
              
              return (
                <CalendarDay
                  key={dayIndex}
                  date={date}
                  events={dayEvents}
                  isCurrentMonth={isCurrentMonth}
                  isSelected={isSelected}
                  isFocused={isFocused}
                  isToday={isToday}
                  onSelect={handleDateSelect}
                  onEventSelect={onEventSelect}
                />
              )
            })}
          </div>
        ))}
      </div>
    </div>
  )
}

// Ï†ëÍ∑º Í∞ÄÎä•Ìïú ÎÇ†Ïßú ÏÖÄ Ïª¥Ìè¨ÎÑåÌä∏
const CalendarDay: React.FC<{
  date: Date
  events: CalendarEvent[]
  isCurrentMonth: boolean
  isSelected: boolean
  isFocused: boolean
  isToday: boolean
  onSelect: (date: Date) => void
  onEventSelect: (event: CalendarEvent) => void
}> = ({ 
  date, 
  events, 
  isCurrentMonth, 
  isSelected, 
  isFocused, 
  isToday,
  onSelect,
  onEventSelect 
}) => {
  const dayRef = useRef<HTMLDivElement>(null)
  
  // Ìè¨Ïª§Ïä§ Í¥ÄÎ¶¨
  useEffect(() => {
    if (isFocused && dayRef.current) {
      dayRef.current.focus()
    }
  }, [isFocused])
  
  const handleClick = () => {
    onSelect(date)
  }
  
  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault()
      handleClick()
    }
  }
  
  const dayLabel = format(date, 'MMMM d, yyyy')
  const eventsLabel = events.length > 0 ? `, ${events.length} events` : ''
  const stateLabels = [
    isToday && 'today',
    isSelected && 'selected',
    !isCurrentMonth && 'outside current month'
  ].filter(Boolean).join(', ')
  
  const fullLabel = `${dayLabel}${eventsLabel}${stateLabels ? `, ${stateLabels}` : ''}`
  
  return (
    <div
      ref={dayRef}
      role="gridcell"
      tabIndex={isFocused ? 0 : -1}
      aria-label={fullLabel}
      aria-selected={isSelected}
      aria-current={isToday ? 'date' : undefined}
      onClick={handleClick}
      onKeyDown={handleKeyDown}
      className={cn(
        'calendar-day p-2 border cursor-pointer',
        'focus:outline-none focus:ring-2 focus:ring-primary focus:ring-inset',
        !isCurrentMonth && 'text-muted-foreground bg-muted/30',
        isSelected && 'bg-primary text-primary-foreground',
        isToday && !isSelected && 'ring-1 ring-primary',
        isFocused && 'ring-2 ring-primary ring-offset-2'
      )}
    >
      {/* Date number */}
      <div className="text-sm font-medium mb-1" aria-hidden="true">
        {format(date, 'd')}
      </div>
      
      {/* Events */}
      {events.length > 0 && (
        <div className="space-y-1" role="list" aria-label={`${events.length} events`}>
          {events.slice(0, 3).map((event) => (
            <div
              key={event.id}
              role="listitem"
              className="text-xs p-1 rounded truncate cursor-pointer hover:opacity-80"
              style={{ backgroundColor: `${event.projectColor}20` }}
              onClick={(e) => {
                e.stopPropagation()
                onEventSelect(event)
              }}
              onKeyDown={(e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                  e.preventDefault()
                  e.stopPropagation()
                  onEventSelect(event)
                }
              }}
              tabIndex={0}
              aria-label={`${event.title} at ${format(event.startDate, 'h:mm a')}`}
            >
              {event.title}
            </div>
          ))}
          {events.length > 3 && (
            <div className="text-xs text-muted-foreground" aria-hidden="true">
              +{events.length - 3} more
            </div>
          )}
        </div>
      )}
    </div>
  )
}
```

### **2. ÌÇ§Î≥¥Îìú ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò ÏãúÏä§ÌÖú**

**Ï¢ÖÌï©Ï†ÅÏù∏ ÌÇ§Î≥¥Îìú ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò**
```typescript
// src/hooks/useKeyboardNavigation.ts
import { useEffect, useCallback, useRef } from 'react'

interface KeyboardNavigationOptions {
  onArrowLeft?: () => void
  onArrowRight?: () => void
  onArrowUp?: () => void
  onArrowDown?: () => void
  onEnter?: () => void
  onSpace?: () => void
  onEscape?: () => void
  onTab?: () => void
  onShiftTab?: () => void
  onHome?: () => void
  onEnd?: () => void
  onPageUp?: () => void
  onPageDown?: () => void
  disabled?: boolean
}

export const useKeyboardNavigation = (options: KeyboardNavigationOptions) => {
  const handleKeyDown = useCallback((e: KeyboardEvent | React.KeyboardEvent) => {
    if (options.disabled) return
    
    const { key, ctrlKey, metaKey, shiftKey } = e
    
    switch (key) {
      case 'ArrowLeft':
        e.preventDefault()
        options.onArrowLeft?.()
        break
        
      case 'ArrowRight':
        e.preventDefault()
        options.onArrowRight?.()
        break
        
      case 'ArrowUp':
        e.preventDefault()
        options.onArrowUp?.()
        break
        
      case 'ArrowDown':
        e.preventDefault()
        options.onArrowDown?.()
        break
        
      case 'Enter':
        options.onEnter?.()
        break
        
      case ' ':
        e.preventDefault()
        options.onSpace?.()
        break
        
      case 'Escape':
        options.onEscape?.()
        break
        
      case 'Tab':
        if (shiftKey) {
          options.onShiftTab?.()
        } else {
          options.onTab?.()
        }
        break
        
      case 'Home':
        e.preventDefault()
        options.onHome?.()
        break
        
      case 'End':
        e.preventDefault()
        options.onEnd?.()
        break
        
      case 'PageUp':
        e.preventDefault()
        options.onPageUp?.()
        break
        
      case 'PageDown':
        e.preventDefault()
        options.onPageDown?.()
        break
    }
  }, [options])
  
  return { handleKeyDown }
}

// Focus trap for modals
export const useFocusTrap = (isActive: boolean) => {
  const containerRef = useRef<HTMLDivElement>(null)
  const focusableElementsString = `
    a[href],
    area[href],
    input:not([disabled]):not([type="hidden"]),
    select:not([disabled]),
    textarea:not([disabled]),
    button:not([disabled]),
    iframe,
    object,
    embed,
    [tabindex]:not([tabindex="-1"]),
    [contenteditable]
  `
  
  useEffect(() => {
    if (!isActive || !containerRef.current) return
    
    const container = containerRef.current
    const focusableElements = container.querySelectorAll(focusableElementsString)
    const firstElement = focusableElements[0] as HTMLElement
    const lastElement = focusableElements[focusableElements.length - 1] as HTMLElement
    
    // Focus first element
    if (firstElement) {
      firstElement.focus()
    }
    
    const handleTab = (e: KeyboardEvent) => {
      if (e.key !== 'Tab') return
      
      if (e.shiftKey) {
        if (document.activeElement === firstElement) {
          e.preventDefault()
          lastElement?.focus()
        }
      } else {
        if (document.activeElement === lastElement) {
          e.preventDefault()
          firstElement?.focus()
        }
      }
    }
    
    container.addEventListener('keydown', handleTab)
    return () => container.removeEventListener('keydown', handleTab)
  }, [isActive])
  
  return containerRef
}
```

### **3. Ïä§ÌÅ¨Î¶∞ Î¶¨Îçî ÏßÄÏõê**

**Ïä§ÌÅ¨Î¶∞ Î¶¨Îçî ÏµúÏ†ÅÌôî**
```typescript
// src/hooks/useScreenReader.ts
import { useEffect, useRef, useState } from 'react'

export const useScreenReader = () => {
  const announceRef = useRef<HTMLDivElement>(null)
  const [isScreenReaderActive, setIsScreenReaderActive] = useState(false)
  
  // Ïä§ÌÅ¨Î¶∞ Î¶¨Îçî Í∞êÏßÄ
  useEffect(() => {
    // Îã§ÏñëÌïú Î∞©Î≤ïÏúºÎ°ú Ïä§ÌÅ¨Î¶∞ Î¶¨Îçî Í∞êÏßÄ
    const detectScreenReader = () => {
      // 1. Ïä§ÌÅ¨Î¶∞ Î¶¨Îçî User Agent ÌôïÏù∏
      const userAgent = navigator.userAgent.toLowerCase()
      const screenReaderUA = ['nvda', 'jaws', 'sapi', 'guide', 'cmds', 'supernova', 'mad', 'thunder']
      const hasScreenReaderUA = screenReaderUA.some(sr => userAgent.includes(sr))
      
      // 2. Ï†ëÍ∑ºÏÑ± API ÌôïÏù∏
      const hasA11yAPIs = 'speechSynthesis' in window || 'webkitSpeechSynthesis' in window
      
      // 3. prefers-reduced-motion ÌôïÏù∏ (Í∞ÑÏ†ë ÏßÄÌëú)
      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches
      
      return hasScreenReaderUA || hasA11yAPIs || prefersReducedMotion
    }
    
    setIsScreenReaderActive(detectScreenReader())
  }, [])
  
  const announce = useCallback((message: string, priority: 'polite' | 'assertive' = 'polite') => {
    if (!announceRef.current) return
    
    // Clear previous message
    announceRef.current.textContent = ''
    announceRef.current.setAttribute('aria-live', priority)
    
    // Add new message with slight delay
    setTimeout(() => {
      if (announceRef.current) {
        announceRef.current.textContent = message
      }
    }, 100)
  }, [])
  
  const announceNavigation = useCallback((from: string, to: string) => {
    announce(`Navigated from ${from} to ${to}`)
  }, [announce])
  
  const announceAction = useCallback((action: string, result?: string) => {
    const message = result ? `${action}. ${result}` : action
    announce(message, 'assertive')
  }, [announce])
  
  return {
    isScreenReaderActive,
    announce,
    announceNavigation,
    announceAction,
    announceRef
  }
}

// Live region component
export const LiveRegion: React.FC<{
  message: string
  level?: 'polite' | 'assertive'
  atomic?: boolean
}> = ({ message, level = 'polite', atomic = true }) => {
  return (
    <div
      aria-live={level}
      aria-atomic={atomic}
      className="sr-only"
      role="status"
    >
      {message}
    </div>
  )
}

// Screen reader only content
export const ScreenReaderOnly: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  return (
    <span className="sr-only">
      {children}
    </span>
  )
}
```

### **4. ÏÉâÏÉÅ Î∞è ÎåÄÎπÑ ÏµúÏ†ÅÌôî**

**ÏÉâÏÉÅ Ï†ëÍ∑ºÏÑ± Í¥ÄÎ¶¨**
```typescript
// src/lib/accessibility/color-contrast.ts
import { TinyColor } from '@ctrl/tinycolor'

export class ColorContrastManager {
  // WCAG AA Í∏∞Ï§Ä: 4.5:1 (ÏùºÎ∞ò ÌÖçÏä§Ìä∏), 3:1 (ÎåÄÌòï ÌÖçÏä§Ìä∏)
  // WCAG AAA Í∏∞Ï§Ä: 7:1 (ÏùºÎ∞ò ÌÖçÏä§Ìä∏), 4.5:1 (ÎåÄÌòï ÌÖçÏä§Ìä∏)
  
  static calculateContrast(foreground: string, background: string): number {
    const fg = new TinyColor(foreground)
    const bg = new TinyColor(background)
    
    const fgLuminance = fg.getLuminance()
    const bgLuminance = bg.getLuminance()
    
    const lighter = Math.max(fgLuminance, bgLuminance)
    const darker = Math.min(fgLuminance, bgLuminance)
    
    return (lighter + 0.05) / (darker + 0.05)
  }
  
  static meetsWCAG_AA(foreground: string, background: string, isLargeText = false): boolean {
    const contrast = this.calculateContrast(foreground, background)
    return isLargeText ? contrast >= 3 : contrast >= 4.5
  }
  
  static meetsWCAG_AAA(foreground: string, background: string, isLargeText = false): boolean {
    const contrast = this.calculateContrast(foreground, background)
    return isLargeText ? contrast >= 4.5 : contrast >= 7
  }
  
  // Ï∂©Î∂ÑÌïú ÎåÄÎπÑÎ•º ÏúÑÌï¥ ÏÉâÏÉÅ Ï°∞Ï†ï
  static adjustForContrast(
    foreground: string, 
    background: string, 
    targetRatio = 4.5
  ): string {
    let adjustedColor = new TinyColor(foreground)
    let currentRatio = this.calculateContrast(foreground, background)
    
    if (currentRatio >= targetRatio) {
      return foreground
    }
    
    const bgLuminance = new TinyColor(background).getLuminance()
    const shouldDarken = bgLuminance > 0.5
    
    let attempts = 0
    const maxAttempts = 100
    
    while (currentRatio < targetRatio && attempts < maxAttempts) {
      if (shouldDarken) {
        adjustedColor = adjustedColor.darken(2)
      } else {
        adjustedColor = adjustedColor.lighten(2)
      }
      
      currentRatio = this.calculateContrast(
        adjustedColor.toHexString(), 
        background
      )
      attempts++
    }
    
    return adjustedColor.toHexString()
  }
  
  // ÏÉâÎßπ ÏÇ¨Ïö©ÏûêÎ•º ÏúÑÌïú ÏÉâÏÉÅ ÏãúÎÆ¨Î†àÏù¥ÏÖò
  static simulateColorBlindness(color: string, type: 'protanopia' | 'deuteranopia' | 'tritanopia'): string {
    const tinyColor = new TinyColor(color)
    const rgb = tinyColor.toRgb()
    
    let r = rgb.r / 255
    let g = rgb.g / 255
    let b = rgb.b / 255
    
    // ÏÉâÎßπ Î≥ÄÌôò Îß§Ìä∏Î¶≠Ïä§ Ï†ÅÏö©
    switch (type) {
      case 'protanopia':
        // Ï†ÅÏÉâÎßπ
        r = 0.567 * r + 0.433 * g
        g = 0.558 * r + 0.442 * g
        break
        
      case 'deuteranopia':
        // ÎÖπÏÉâÎßπ
        r = 0.625 * r + 0.375 * g
        g = 0.7 * r + 0.3 * g
        break
        
      case 'tritanopia':
        // Ï≤≠ÏÉâÎßπ
        g = 0.95 * g + 0.05 * b
        b = 0.433 * g + 0.567 * b
        break
    }
    
    return new TinyColor({
      r: Math.round(r * 255),
      g: Math.round(g * 255),
      b: Math.round(b * 255)
    }).toHexString()
  }
}

// Ï†ëÍ∑ºÏÑ± ÏÉâÏÉÅ ÌåîÎ†àÌä∏ ÏÉùÏÑ±
export const generateAccessiblePalette = (baseColor: string) => {
  const base = new TinyColor(baseColor)
  
  return {
    // Í∏∞Î≥∏ ÏÉâÏÉÅ
    50: base.lighten(45).desaturate(30).toHexString(),
    100: base.lighten(35).desaturate(20).toHexString(),
    200: base.lighten(25).desaturate(10).toHexString(),
    300: base.lighten(15).toHexString(),
    400: base.lighten(7).toHexString(),
    500: base.toHexString(), // Í∏∞Ï§Ä ÏÉâÏÉÅ
    600: base.darken(7).toHexString(),
    700: base.darken(15).toHexString(),
    800: base.darken(25).saturate(10).toHexString(),
    900: base.darken(35).saturate(20).toHexString(),
    950: base.darken(45).saturate(30).toHexString(),
  }
}
```

### **5. Í≥†ÎåÄÎπÑ Î™®Îìú Î∞è ÌÖåÎßà**

**Ï†ëÍ∑ºÏÑ± ÌÖåÎßà ÏãúÏä§ÌÖú**
```typescript
// src/components/accessibility/AccessibilitySettings.tsx
import React from 'react'
import { useThemeStore } from '@/stores/themeStore'
import { ColorContrastManager } from '@/lib/accessibility/color-contrast'

export const AccessibilitySettings: React.FC = () => {
  const {
    highContrast,
    reducedMotion,
    fontSize,
    setHighContrast,
    setReducedMotion,
    setFontSize,
  } = useThemeStore()
  
  return (
    <div className="accessibility-settings space-y-6">
      <h2 className="text-lg font-semibold">Ï†ëÍ∑ºÏÑ± ÏÑ§Ï†ï</h2>
      
      {/* Í≥†ÎåÄÎπÑ Î™®Îìú */}
      <div className="space-y-2">
        <div className="flex items-center justify-between">
          <div>
            <label htmlFor="high-contrast" className="font-medium">
              Í≥†ÎåÄÎπÑ Î™®Îìú
            </label>
            <p className="text-sm text-muted-foreground">
              Îçî ÎÜíÏùÄ ÏÉâÏÉÅ ÎåÄÎπÑÎ°ú Í∞ÄÎèÖÏÑ±ÏùÑ Ìñ•ÏÉÅÏãúÌÇµÎãàÎã§
            </p>
          </div>
          <Switch
            id="high-contrast"
            checked={highContrast}
            onCheckedChange={setHighContrast}
            aria-describedby="high-contrast-description"
          />
        </div>
        
        {/* ÎåÄÎπÑ ÎØ∏Î¶¨Î≥¥Í∏∞ */}
        <ContrastPreview enabled={highContrast} />
      </div>
      
      {/* Ïï†ÎãàÎ©îÏù¥ÏÖò Ï§ÑÏù¥Í∏∞ */}
      <div className="space-y-2">
        <div className="flex items-center justify-between">
          <div>
            <label htmlFor="reduced-motion" className="font-medium">
              Ïï†ÎãàÎ©îÏù¥ÏÖò Ï§ÑÏù¥Í∏∞
            </label>
            <p className="text-sm text-muted-foreground">
              Î™®ÏÖò ÎØºÍ∞êÏÑ±Ïù¥ ÏûàÎäî Í≤ΩÏö∞ Ïï†ÎãàÎ©îÏù¥ÏÖòÏùÑ ÏµúÏÜåÌôîÌï©ÎãàÎã§
            </p>
          </div>
          <Switch
            id="reduced-motion"
            checked={reducedMotion}
            onCheckedChange={setReducedMotion}
          />
        </div>
      </div>
      
      {/* Ìè∞Ìä∏ ÌÅ¨Í∏∞ */}
      <div className="space-y-2">
        <label className="font-medium">Ìè∞Ìä∏ ÌÅ¨Í∏∞</label>
        <div className="grid grid-cols-3 gap-2">
          {(['small', 'medium', 'large'] as const).map((size) => (
            <button
              key={size}
              onClick={() => setFontSize(size)}
              className={cn(
                "p-2 border rounded text-center",
                fontSize === size && "bg-primary text-primary-foreground"
              )}
              aria-pressed={fontSize === size}
            >
              <div className={cn(
                "font-medium",
                size === 'small' && "text-sm",
                size === 'medium' && "text-base",
                size === 'large' && "text-lg"
              )}>
                {size === 'small' && 'ÏûëÍ≤å'}
                {size === 'medium' && 'Î≥¥ÌÜµ'}
                {size === 'large' && 'ÌÅ¨Í≤å'}
              </div>
            </button>
          ))}
        </div>
      </div>
      
      {/* ÌÇ§Î≥¥Îìú Îã®Ï∂ïÌÇ§ ÏïàÎÇ¥ */}
      <KeyboardShortcuts />
    </div>
  )
}

const ContrastPreview: React.FC<{ enabled: boolean }> = ({ enabled }) => {
  const textColor = enabled ? '#000000' : '#374151'
  const bgColor = enabled ? '#ffffff' : '#f9fafb'
  const primaryColor = enabled ? '#0000ff' : '#3b82f6'
  
  const contrast1 = ColorContrastManager.calculateContrast(textColor, bgColor)
  const contrast2 = ColorContrastManager.calculateContrast(primaryColor, bgColor)
  
  return (
    <div className="border rounded p-4" style={{ backgroundColor: bgColor }}>
      <p style={{ color: textColor }} className="mb-2">
        ÏùºÎ∞ò ÌÖçÏä§Ìä∏ (ÎåÄÎπÑ: {contrast1.toFixed(1)}:1)
      </p>
      <p style={{ color: primaryColor }} className="font-medium">
        Í∞ïÏ°∞ ÌÖçÏä§Ìä∏ (ÎåÄÎπÑ: {contrast2.toFixed(1)}:1)
      </p>
    </div>
  )
}

const KeyboardShortcuts: React.FC = () => {
  const shortcuts = [
    { key: 'Tab', description: 'Îã§Ïùå ÏöîÏÜåÎ°ú Ïù¥Îèô' },
    { key: 'Shift + Tab', description: 'Ïù¥Ï†Ñ ÏöîÏÜåÎ°ú Ïù¥Îèô' },
    { key: 'ÌôîÏÇ¥Ìëú ÌÇ§', description: 'Ï∫òÎ¶∞Îçî ÎÇ†Ïßú ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò' },
    { key: 'Enter / Space', description: 'ÏÑ†ÌÉù ÎòêÎäî ÌôúÏÑ±Ìôî' },
    { key: 'Escape', description: 'Î™®Îã¨ Îã´Í∏∞ ÎòêÎäî Ï∑®ÏÜå' },
    { key: 'Home / End', description: 'Ï£ºÏùò ÏãúÏûë/ÎÅùÏúºÎ°ú Ïù¥Îèô' },
    { key: 'Page Up/Down', description: 'Ïõî ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò' },
  ]
  
  return (
    <details className="space-y-2">
      <summary className="font-medium cursor-pointer">
        ÌÇ§Î≥¥Îìú Îã®Ï∂ïÌÇ§ ÏïàÎÇ¥
      </summary>
      <div className="mt-2 space-y-2">
        {shortcuts.map((shortcut, index) => (
          <div key={index} className="flex justify-between text-sm">
            <kbd className="px-2 py-1 bg-muted rounded text-xs font-mono">
              {shortcut.key}
            </kbd>
            <span className="text-muted-foreground">{shortcut.description}</span>
          </div>
        ))}
      </div>
    </details>
  )
}
```

### **6. Îã§Íµ≠Ïñ¥ Î∞è RTL ÏßÄÏõê**

**Íµ≠Ï†úÌôî Î∞è Î∞©Ìñ• ÏßÄÏõê**
```typescript
// src/lib/accessibility/internationalization.ts
import { useRouter } from 'next/router'
import { useEffect } from 'react'

export const useInternationalization = () => {
  const router = useRouter()
  const { locale, locales, defaultLocale } = router
  
  // RTL Ïñ∏Ïñ¥ Î™©Î°ù
  const rtlLanguages = ['ar', 'he', 'fa', 'ur']
  const isRTL = rtlLanguages.includes(locale?.split('-')[0] || '')
  
  // Î¨∏ÏÑú Î∞©Ìñ• ÏÑ§Ï†ï
  useEffect(() => {
    document.dir = isRTL ? 'rtl' : 'ltr'
    document.lang = locale || defaultLocale || 'en'
  }, [locale, isRTL, defaultLocale])
  
  return {
    locale,
    locales,
    defaultLocale,
    isRTL,
    switchLocale: (newLocale: string) => {
      router.push(router.pathname, router.asPath, { locale: newLocale })
    }
  }
}

// RTL ÎåÄÏùë Ïä§ÌÉÄÏùº Ïú†Ìã∏Î¶¨Ìã∞
export const rtlStyles = {
  marginLeft: (value: string) => ({
    marginLeft: value,
    '[dir="rtl"] &': { marginRight: value, marginLeft: 'auto' }
  }),
  marginRight: (value: string) => ({
    marginRight: value,
    '[dir="rtl"] &': { marginLeft: value, marginRight: 'auto' }
  }),
  paddingLeft: (value: string) => ({
    paddingLeft: value,
    '[dir="rtl"] &': { paddingRight: value, paddingLeft: '0' }
  }),
  paddingRight: (value: string) => ({
    paddingRight: value,
    '[dir="rtl"] &': { paddingLeft: value, paddingRight: '0' }
  }),
  textAlign: (align: 'left' | 'right') => ({
    textAlign: align,
    '[dir="rtl"] &': { textAlign: align === 'left' ? 'right' : 'left' }
  }),
}
```

---

## üìä **Ï†ëÍ∑ºÏÑ± ÌÖåÏä§Ìä∏**

### **ÏûêÎèôÌôîÎêú Ï†ëÍ∑ºÏÑ± ÌÖåÏä§Ìä∏**
```typescript
// src/lib/accessibility/testing.ts
import { axe, toHaveNoViolations } from 'jest-axe'

expect.extend(toHaveNoViolations)

export const runAccessibilityTests = async (element: HTMLElement) => {
  const results = await axe(element, {
    rules: {
      // WCAG AA ÏàòÏ§Ä Í∑úÏπô
      'color-contrast': { enabled: true },
      'focus-order-semantics': { enabled: true },
      'keyboard': { enabled: true },
      'label': { enabled: true },
      'region': { enabled: true },
    }
  })
  
  expect(results).toHaveNoViolations()
  
  return results
}

// ÌÇ§Î≥¥Îìú ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò ÌÖåÏä§Ìä∏
export const testKeyboardNavigation = (container: HTMLElement) => {
  const focusableElements = container.querySelectorAll(
    'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
  )
  
  // Î™®Îì† focusable ÏöîÏÜåÍ∞Ä ÌÇ§Î≥¥ÎìúÎ°ú Ï†ëÍ∑º Í∞ÄÎä•ÌïúÏßÄ ÌôïÏù∏
  focusableElements.forEach((element) => {
    expect(element).toHaveAttribute('tabindex')
    expect(parseInt(element.getAttribute('tabindex') || '0')).toBeGreaterThanOrEqual(0)
  })
}
```

---

## ‚úÖ **Definition of Done**

### **Í∏∞Îä• ÏöîÍµ¨ÏÇ¨Ìï≠**
- [ ] ARIA Î†àÏù¥Î∏î Î∞è Ïó≠Ìï† ÏôÑÏ†Ñ Íµ¨ÌòÑ
- [ ] ÌÇ§Î≥¥Îìú Ï†ÑÏö© ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò ÏßÄÏõê
- [ ] Ïä§ÌÅ¨Î¶∞ Î¶¨Îçî ÏôÑÏ†Ñ ÏßÄÏõê
- [ ] Í≥†ÎåÄÎπÑ Î™®Îìú Î∞è ÏÉâÏÉÅ Ï†ëÍ∑ºÏÑ±
- [ ] Îã§Íµ≠Ïñ¥ Î∞è RTL ÏßÄÏõê

### **Í∏∞Ïà† ÏöîÍµ¨ÏÇ¨Ìï≠**
- [ ] WCAG 2.1 AA Í∏∞Ï§Ä Ï§ÄÏàò
- [ ] ÏûêÎèôÌôîÎêú Ï†ëÍ∑ºÏÑ± ÌÖåÏä§Ìä∏
- [ ] ÏãúÎß®Ìã± HTML Íµ¨Ï°∞
- [ ] Focus trap Î∞è Í¥ÄÎ¶¨

### **ÏÇ¨Ïö©ÏÑ± ÏöîÍµ¨ÏÇ¨Ìï≠**
- [ ] Î™®Îì† Í∏∞Îä•Ïóê ÌÇ§Î≥¥Îìú Ï†ëÍ∑º Í∞ÄÎä•
- [ ] Î™ÖÌôïÌïú Ìè¨Ïª§Ïä§ Ïù∏ÎîîÏºÄÏù¥ÌÑ∞
- [ ] Ï∂©Î∂ÑÌïú ÌÑ∞Ïπò ÌÉÄÍ≤ü ÌÅ¨Í∏∞ (44x44px)
- [ ] Ïù¥Ìï¥ÌïòÍ∏∞ Ïâ¨Ïö¥ ÏóêÎü¨ Î©îÏãúÏßÄ

### **ÌÖåÏä§Ìä∏ ÏöîÍµ¨ÏÇ¨Ìï≠**
- [ ] axe-core Ï†ëÍ∑ºÏÑ± ÌÖåÏä§Ìä∏ ÌÜµÍ≥º
- [ ] Ïä§ÌÅ¨Î¶∞ Î¶¨Îçî ÌÖåÏä§Ìä∏ (NVDA, JAWS)
- [ ] ÌÇ§Î≥¥Îìú Ï†ÑÏö© ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò ÌÖåÏä§Ìä∏
- [ ] ÏÉâÏÉÅ ÎåÄÎπÑÏú® Í≤ÄÏ¶ù

---

## üìö **Í¥ÄÎ†® Î¨∏ÏÑú Ï∞∏Ï°∞**

- [11. Accessibility Implementation](../ui-architecture/11-accessibility-implementation.md)
- [05. Design System Foundations](../ui-architecture/05-design-system-foundations.md)
- [12. Monitoring & Testing](../ui-architecture/12-monitoring-testing.md)

---

**Ïù¥ Ïä§ÌÜ†Î¶¨Îäî Î∞îÎ°úÏ∫òÎ¶∞ÎçîÏùò Ï†ëÍ∑ºÏÑ± Íµ¨ÌòÑÏùÑ ÏúÑÌïú Ï¢ÖÌï©Ï†ÅÏù∏ Í∏∞Ïà† Í∞ÄÏù¥ÎìúÏûÖÎãàÎã§. Î™®Îì† ÏÇ¨Ïö©ÏûêÍ∞Ä Ïû•Ïï† Ïó¨Î∂ÄÏóê Í¥ÄÍ≥ÑÏóÜÏù¥ ÎèôÎì±ÌïòÍ≤å ÏÑúÎπÑÏä§Î•º Ïù¥Ïö©Ìï† Ïàò ÏûàÎèÑÎ°ù Ìè¨Ïö©Ï†ÅÏù∏ ÏÇ¨Ïö©Ïûê Í≤ΩÌóòÏùÑ Ï†úÍ≥µÌï©ÎãàÎã§.**