# ğŸ“± Story 2.22: ì˜¤í”„ë¼ì¸ ì§€ì› ë° PWA êµ¬í˜„

## ğŸ“‹ Story ì •ë³´
- **Story ë²„ì „**: 1.0
- **ì‘ì„±ì¼**: 2025-08-28
- **ì‘ì„±ì**: Frontend Development Team
- **í”„ë¡œì íŠ¸ëª…**: ë°”ë¡œìº˜ë¦°ë” (Baro Calendar)
- **Sprint**: Frontend Implementation - Phase 18
- **Story Point**: 13
- **ìš°ì„ ìˆœìœ„**: Medium
- **ê´€ë ¨ ê¸°ìˆ **: Service Worker, IndexedDB, PWA, Offline Sync

---

## ğŸ¯ Story ê°œìš”

ë°”ë¡œìº˜ë¦°ë”ì˜ **ì˜¤í”„ë¼ì¸ ì§€ì› ë° PWA(Progressive Web App)** ê¸°ëŠ¥ì„ êµ¬í˜„í•˜ì—¬ ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì´ ë¶ˆì•ˆì •í•˜ê±°ë‚˜ ëŠì–´ì§„ í™˜ê²½ì—ì„œë„ ì›í™œí•œ ì¼ì • ê´€ë¦¬ë¥¼ ì œê³µí•©ë‹ˆë‹¤.

---

## ğŸ¬ ì‚¬ìš©ì ìŠ¤í† ë¦¬

### ğŸ“ ì£¼ìš” ì‚¬ìš©ì ìŠ¤í† ë¦¬

**As a** ë°”ë¡œìº˜ë¦°ë” ì‚¬ìš©ì  
**I want** ì¸í„°ë„· ì—°ê²°ì´ ë¶ˆì•ˆì •í•œ ê³³ì—ì„œë„ ìº˜ë¦°ë”ë¥¼ ì‚¬ìš©í•˜ê³  ì‹¶ì–´  
**So that** ì§€í•˜ì² , ë¹„í–‰ê¸°, í•´ì™¸ì—¬í–‰ ë“± ì–´ë–¤ í™˜ê²½ì—ì„œë„ ì¼ì •ì„ í™•ì¸í•˜ê³  ê´€ë¦¬í•  ìˆ˜ ìˆì–´

### ğŸ” ìƒì„¸ ì‚¬ìš©ì ìš”êµ¬ì‚¬í•­

1. **ì˜¤í”„ë¼ì¸ ë°ì´í„° ì ‘ê·¼**
   - ìµœê·¼ 30ì¼ ìº˜ë¦°ë” ë°ì´í„° ì˜¤í”„ë¼ì¸ ìºì‹±
   - ìì£¼ ì‚¬ìš©í•˜ëŠ” í”„ë¡œì íŠ¸ ë°ì´í„° ìš°ì„  ì €ì¥
   - ì˜¤í”„ë¼ì¸ ìƒíƒœì—ì„œë„ ì¼ì • ìƒì„±/ìˆ˜ì • ê°€ëŠ¥

2. **PWA ì•± ê²½í—˜**
   - í™ˆ í™”ë©´ì— ì•± ì•„ì´ì½˜ ì„¤ì¹˜ ê°€ëŠ¥
   - ë„¤ì´í‹°ë¸Œ ì•±ê³¼ ìœ ì‚¬í•œ ì‚¬ìš©ì ê²½í—˜
   - í‘¸ì‹œ ì•Œë¦¼ ì§€ì› (ê¶Œí•œ í—ˆìš© ì‹œ)

3. **ìë™ ë™ê¸°í™”**
   - ì˜¨ë¼ì¸ ë³µê·€ ì‹œ ìë™ ë°ì´í„° ë™ê¸°í™”
   - ì¶©ëŒ í•´ê²° ë° ë°ì´í„° ì¼ê´€ì„± ë³´ì¥
   - ë°±ê·¸ë¼ìš´ë“œ ë™ê¸°í™” ì§€ì›

---

## âš™ï¸ ê¸°ìˆ ì  ìš”êµ¬ì‚¬í•­

### ğŸ—ï¸ ì•„í‚¤í…ì²˜ ìš”êµ¬ì‚¬í•­

1. **Service Worker ê¸°ë°˜ ì˜¤í”„ë¼ì¸ ì§€ì›**
   ```typescript
   - ìºì‹œ ìš°ì„  ë„¤íŠ¸ì›Œí‚¹ ì „ëµ
   - ì •ì  ìì‚° ë° API ì‘ë‹µ ìºì‹±
   - ë°±ê·¸ë¼ìš´ë“œ ë™ê¸°í™”
   - í‘¸ì‹œ ì•Œë¦¼ ì²˜ë¦¬
   ```

2. **IndexedDB ë°ì´í„° ì €ì¥**
   ```typescript
   - êµ¬ì¡°í™”ëœ ì˜¤í”„ë¼ì¸ ë°ì´í„°ë² ì´ìŠ¤
   - ì¸ë±ì‹± ë° ë¹ ë¥¸ ê²€ìƒ‰ ì§€ì›
   - ìŠ¤í† ë¦¬ì§€ í• ë‹¹ëŸ‰ ê´€ë¦¬
   - ë°ì´í„° ì••ì¶• ë° ìµœì í™”
   ```

3. **PWA í‘œì¤€ ì¤€ìˆ˜**
   ```typescript
   - Web App Manifest ì„¤ì •
   - í™ˆ í™”ë©´ ì„¤ì¹˜ ë°°ë„ˆ
   - ìŠ¤í”Œë˜ì‹œ í™”ë©´ ìµœì í™”
   - ì•± ì‹œì‘ URL ë° ë²”ìœ„ ì„¤ì •
   ```

---

## ğŸ› ï¸ êµ¬í˜„ ìƒì„¸

### 1ï¸âƒ£ Service Worker êµ¬í˜„

```typescript
// public/sw.js
const CACHE_NAME = 'baro-calendar-v1'
const RUNTIME_CACHE = 'baro-calendar-runtime-v1'

// ìºì‹œí•  ì •ì  ìì‚°
const STATIC_ASSETS = [
  '/',
  '/app/calendar',
  '/manifest.json',
  '/_next/static/chunks/main.js',
  '/_next/static/chunks/pages/_app.js',
  '/_next/static/css/app.css',
  '/icons/icon-192x192.png',
  '/icons/icon-512x512.png',
]

// ìºì‹œí•  API ì—”ë“œí¬ì¸íŠ¸ íŒ¨í„´
const API_CACHE_PATTERNS = [
  /^\/api\/v1\/timeline/,
  /^\/api\/v1\/events/,
  /^\/api\/v1\/projects/,
]

// Service Worker ì„¤ì¹˜
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => cache.addAll(STATIC_ASSETS))
      .then(() => self.skipWaiting())
  )
})

// Service Worker í™œì„±í™”
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          if (cacheName !== CACHE_NAME && cacheName !== RUNTIME_CACHE) {
            return caches.delete(cacheName)
          }
        })
      )
    }).then(() => self.clients.claim())
  )
})

// ë„¤íŠ¸ì›Œí¬ ìš”ì²­ ì¸í„°ì…‰íŠ¸
self.addEventListener('fetch', (event) => {
  const { request } = event
  const { url, method } = request

  // GET ìš”ì²­ë§Œ ìºì‹±
  if (method !== 'GET') return

  // ì •ì  ìì‚° - Cache First ì „ëµ
  if (STATIC_ASSETS.includes(new URL(url).pathname)) {
    event.respondWith(
      caches.match(request).then((response) => {
        return response || fetch(request)
      })
    )
    return
  }

  // API ìš”ì²­ - Network First with Cache Fallback
  if (API_CACHE_PATTERNS.some(pattern => pattern.test(url))) {
    event.respondWith(
      fetch(request)
        .then((response) => {
          // ì„±ê³µ ì‘ë‹µë§Œ ìºì‹±
          if (response.status === 200) {
            const responseClone = response.clone()
            caches.open(RUNTIME_CACHE).then((cache) => {
              cache.put(request, responseClone)
            })
          }
          return response
        })
        .catch(() => {
          // ë„¤íŠ¸ì›Œí¬ ì‹¤íŒ¨ ì‹œ ìºì‹œì—ì„œ ì‘ë‹µ
          return caches.match(request)
        })
    )
    return
  }

  // ê¸°íƒ€ ìš”ì²­ - ê¸°ë³¸ ë¸Œë¼ìš°ì € ë™ì‘
})

// ë°±ê·¸ë¼ìš´ë“œ ë™ê¸°í™”
self.addEventListener('sync', (event) => {
  if (event.tag === 'background-sync') {
    event.waitUntil(doBackgroundSync())
  }
})

// í‘¸ì‹œ ì•Œë¦¼ ì²˜ë¦¬
self.addEventListener('push', (event) => {
  if (event.data) {
    const data = event.data.json()
    const options = {
      body: data.body,
      icon: '/icons/icon-192x192.png',
      badge: '/icons/badge-72x72.png',
      data: data.data,
    }
    
    event.waitUntil(
      self.registration.showNotification(data.title, options)
    )
  }
})

// ì•Œë¦¼ í´ë¦­ ì²˜ë¦¬
self.addEventListener('notificationclick', (event) => {
  event.notification.close()
  
  if (event.notification.data && event.notification.data.url) {
    event.waitUntil(
      clients.openWindow(event.notification.data.url)
    )
  }
})

// ë°±ê·¸ë¼ìš´ë“œ ë™ê¸°í™” í•¨ìˆ˜
async function doBackgroundSync() {
  try {
    const response = await fetch('/api/v1/sync/pending')
    if (response.ok) {
      const pendingActions = await response.json()
      
      for (const action of pendingActions.data) {
        await syncPendingAction(action)
      }
    }
  } catch (error) {
    console.error('Background sync failed:', error)
  }
}

async function syncPendingAction(action) {
  try {
    const response = await fetch(`/api/v1/${action.endpoint}`, {
      method: action.method,
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(action.data),
    })
    
    if (response.ok) {
      // ì„±ê³µí•œ ì•¡ì…˜ì„ ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ì œê±°
      await removeFromPendingActions(action.id)
    }
  } catch (error) {
    console.error(`Failed to sync action ${action.id}:`, error)
  }
}

async function removeFromPendingActions(actionId) {
  // IndexedDBì—ì„œ ì™„ë£Œëœ ì•¡ì…˜ ì œê±° ë¡œì§
}
```

### 2ï¸âƒ£ IndexedDB ì˜¤í”„ë¼ì¸ ë°ì´í„°ë² ì´ìŠ¤

```typescript
// src/lib/offline/offline-database.ts
import { openDB, DBSchema, IDBPDatabase } from 'idb'

interface OfflineDB extends DBSchema {
  events: {
    key: string
    value: {
      id: string
      title: string
      description?: string
      startDate: string
      endDate: string
      allDay: boolean
      projectId: string
      project?: {
        id: string
        name: string
        color: string
      }
      status: 'CONFIRMED' | 'TENTATIVE' | 'CANCELLED'
      lastSynced: string
      offline?: boolean
    }
    indexes: {
      'by-date': string
      'by-project': string
    }
  }
  projects: {
    key: string
    value: {
      id: string
      name: string
      description?: string
      color: string
      members: Array<{
        id: string
        name: string
        email: string
      }>
      lastSynced: string
    }
  }
  pendingActions: {
    key: string
    value: {
      id: string
      type: 'CREATE' | 'UPDATE' | 'DELETE'
      endpoint: string
      method: string
      data: any
      timestamp: string
      retryCount: number
    }
  }
  settings: {
    key: string
    value: {
      key: string
      value: any
      lastUpdated: string
    }
  }
}

export class OfflineDatabase {
  private db: IDBPDatabase<OfflineDB> | null = null
  
  async init(): Promise<void> {
    this.db = await openDB<OfflineDB>('baro-calendar-offline', 1, {
      upgrade(db) {
        // ì´ë²¤íŠ¸ ìŠ¤í† ì–´
        const eventStore = db.createObjectStore('events', { keyPath: 'id' })
        eventStore.createIndex('by-date', 'startDate')
        eventStore.createIndex('by-project', 'projectId')
        
        // í”„ë¡œì íŠ¸ ìŠ¤í† ì–´
        db.createObjectStore('projects', { keyPath: 'id' })
        
        // ëŒ€ê¸° ì¤‘ì¸ ì•¡ì…˜ ìŠ¤í† ì–´
        db.createObjectStore('pendingActions', { keyPath: 'id' })
        
        // ì„¤ì • ìŠ¤í† ì–´
        db.createObjectStore('settings', { keyPath: 'key' })
      },
    })
  }
  
  // ì´ë²¤íŠ¸ ê´€ë ¨ ë©”ì„œë“œ
  async saveEvents(events: any[]): Promise<void> {
    if (!this.db) await this.init()
    
    const tx = this.db!.transaction('events', 'readwrite')
    const store = tx.objectStore('events')
    
    for (const event of events) {
      await store.put({
        ...event,
        lastSynced: new Date().toISOString(),
        offline: false,
      })
    }
    
    await tx.done
  }
  
  async getEvents(startDate: string, endDate: string): Promise<any[]> {
    if (!this.db) await this.init()
    
    const tx = this.db!.transaction('events', 'readonly')
    const index = tx.objectStore('events').index('by-date')
    
    const events = await index.getAll(IDBKeyRange.bound(startDate, endDate))
    return events.sort((a, b) => new Date(a.startDate).getTime() - new Date(b.startDate).getTime())
  }
  
  async saveEvent(event: any, isOffline = false): Promise<void> {
    if (!this.db) await this.init()
    
    const eventData = {
      ...event,
      lastSynced: isOffline ? new Date(0).toISOString() : new Date().toISOString(),
      offline: isOffline,
    }
    
    const tx = this.db!.transaction('events', 'readwrite')
    await tx.objectStore('events').put(eventData)
    await tx.done
  }
  
  async deleteEvent(id: string): Promise<void> {
    if (!this.db) await this.init()
    
    const tx = this.db!.transaction('events', 'readwrite')
    await tx.objectStore('events').delete(id)
    await tx.done
  }
  
  // í”„ë¡œì íŠ¸ ê´€ë ¨ ë©”ì„œë“œ
  async saveProjects(projects: any[]): Promise<void> {
    if (!this.db) await this.init()
    
    const tx = this.db!.transaction('projects', 'readwrite')
    const store = tx.objectStore('projects')
    
    for (const project of projects) {
      await store.put({
        ...project,
        lastSynced: new Date().toISOString(),
      })
    }
    
    await tx.done
  }
  
  async getProjects(): Promise<any[]> {
    if (!this.db) await this.init()
    
    const tx = this.db!.transaction('projects', 'readonly')
    return await tx.objectStore('projects').getAll()
  }
  
  // ëŒ€ê¸° ì¤‘ì¸ ì•¡ì…˜ ê´€ë¦¬
  async addPendingAction(action: {
    type: 'CREATE' | 'UPDATE' | 'DELETE'
    endpoint: string
    method: string
    data: any
  }): Promise<void> {
    if (!this.db) await this.init()
    
    const pendingAction = {
      id: crypto.randomUUID(),
      ...action,
      timestamp: new Date().toISOString(),
      retryCount: 0,
    }
    
    const tx = this.db!.transaction('pendingActions', 'readwrite')
    await tx.objectStore('pendingActions').put(pendingAction)
    await tx.done
    
    // Service Workerì— ë°±ê·¸ë¼ìš´ë“œ ë™ê¸°í™” ìš”ì²­
    if ('serviceWorker' in navigator && 'sync' in window.ServiceWorkerRegistration.prototype) {
      const registration = await navigator.serviceWorker.ready
      await registration.sync.register('background-sync')
    }
  }
  
  async getPendingActions(): Promise<any[]> {
    if (!this.db) await this.init()
    
    const tx = this.db!.transaction('pendingActions', 'readonly')
    return await tx.objectStore('pendingActions').getAll()
  }
  
  async removePendingAction(id: string): Promise<void> {
    if (!this.db) await this.init()
    
    const tx = this.db!.transaction('pendingActions', 'readwrite')
    await tx.objectStore('pendingActions').delete(id)
    await tx.done
  }
  
  // ì„¤ì • ê´€ë¦¬
  async getSetting(key: string): Promise<any> {
    if (!this.db) await this.init()
    
    const tx = this.db!.transaction('settings', 'readonly')
    const setting = await tx.objectStore('settings').get(key)
    return setting?.value
  }
  
  async setSetting(key: string, value: any): Promise<void> {
    if (!this.db) await this.init()
    
    const tx = this.db!.transaction('settings', 'readwrite')
    await tx.objectStore('settings').put({
      key,
      value,
      lastUpdated: new Date().toISOString(),
    })
    await tx.done
  }
  
  // ë°ì´í„°ë² ì´ìŠ¤ ì •ë¦¬
  async cleanup(): Promise<void> {
    if (!this.db) await this.init()
    
    const cutoffDate = new Date()
    cutoffDate.setDate(cutoffDate.getDate() - 30) // 30ì¼ ì´ì „ ë°ì´í„° ì‚­ì œ
    
    const tx = this.db!.transaction(['events'], 'readwrite')
    const eventStore = tx.objectStore('events')
    const index = eventStore.index('by-date')
    
    const cursor = await index.openCursor(IDBKeyRange.upperBound(cutoffDate.toISOString()))
    while (cursor) {
      await cursor.delete()
      await cursor.continue()
    }
    
    await tx.done
  }
  
  // ë°ì´í„°ë² ì´ìŠ¤ í¬ê¸° í™•ì¸
  async getStorageEstimate(): Promise<StorageEstimate | undefined> {
    if ('storage' in navigator && 'estimate' in navigator.storage) {
      return await navigator.storage.estimate()
    }
    return undefined
  }
}

// ì „ì—­ ì¸ìŠ¤í„´ìŠ¤
export const offlineDB = new OfflineDatabase()
```

### 3ï¸âƒ£ ì˜¤í”„ë¼ì¸ ìƒíƒœ ê´€ë¦¬

```typescript
// src/hooks/use-offline.ts
import { useState, useEffect, useCallback } from 'react'
import { toast } from 'sonner'
import { offlineDB } from '@/lib/offline/offline-database'
import { queryClient } from '@/lib/query/query-client'

interface OfflineState {
  isOnline: boolean
  wasOffline: boolean
  pendingActions: number
}

export const useOffline = () => {
  const [state, setState] = useState<OfflineState>({
    isOnline: navigator.onLine,
    wasOffline: false,
    pendingActions: 0,
  })
  
  // ì˜¨ë¼ì¸/ì˜¤í”„ë¼ì¸ ìƒíƒœ ê°ì§€
  useEffect(() => {
    const handleOnline = async () => {
      setState(prev => ({ ...prev, isOnline: true }))
      
      if (state.wasOffline) {
        toast.success('ì¸í„°ë„· ì—°ê²°ì´ ë³µì›ë˜ì—ˆìŠµë‹ˆë‹¤. ë°ì´í„°ë¥¼ ë™ê¸°í™”í•©ë‹ˆë‹¤.')
        await syncOfflineData()
        setState(prev => ({ ...prev, wasOffline: false }))
      }
    }
    
    const handleOffline = () => {
      setState(prev => ({ ...prev, isOnline: false, wasOffline: true }))
      toast.warning('ì¸í„°ë„· ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤. ì˜¤í”„ë¼ì¸ ëª¨ë“œë¡œ ì „í™˜í•©ë‹ˆë‹¤.')
    }
    
    window.addEventListener('online', handleOnline)
    window.addEventListener('offline', handleOffline)
    
    return () => {
      window.removeEventListener('online', handleOnline)
      window.removeEventListener('offline', handleOffline)
    }
  }, [state.wasOffline])
  
  // ëŒ€ê¸° ì¤‘ì¸ ì•¡ì…˜ ìˆ˜ ì—…ë°ì´íŠ¸
  useEffect(() => {
    const updatePendingActions = async () => {
      const actions = await offlineDB.getPendingActions()
      setState(prev => ({ ...prev, pendingActions: actions.length }))
    }
    
    updatePendingActions()
    
    // 10ì´ˆë§ˆë‹¤ ì—…ë°ì´íŠ¸
    const interval = setInterval(updatePendingActions, 10000)
    return () => clearInterval(interval)
  }, [])
  
  // ì˜¤í”„ë¼ì¸ ë°ì´í„° ë™ê¸°í™”
  const syncOfflineData = useCallback(async () => {
    try {
      const pendingActions = await offlineDB.getPendingActions()
      
      for (const action of pendingActions) {
        try {
          const response = await fetch(`/api/v1${action.endpoint}`, {
            method: action.method,
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${localStorage.getItem('auth_token')}`,
            },
            body: JSON.stringify(action.data),
          })
          
          if (response.ok) {
            await offlineDB.removePendingAction(action.id)
            
            // ê´€ë ¨ ì¿¼ë¦¬ ë¬´íš¨í™”
            queryClient.invalidateQueries({ queryKey: ['events'] })
            queryClient.invalidateQueries({ queryKey: ['projects'] })
          }
        } catch (error) {
          console.error(`Failed to sync action ${action.id}:`, error)
        }
      }
      
      // ì„±ê³µì ìœ¼ë¡œ ë™ê¸°í™”ëœ í›„ ìƒíƒœ ì—…ë°ì´íŠ¸
      setState(prev => ({ ...prev, pendingActions: 0 }))
      
      toast.success('ì˜¤í”„ë¼ì¸ ë°ì´í„°ê°€ ì„±ê³µì ìœ¼ë¡œ ë™ê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.')
    } catch (error) {
      console.error('Sync failed:', error)
      toast.error('ë°ì´í„° ë™ê¸°í™”ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.')
    }
  }, [])
  
  // ìˆ˜ë™ ë™ê¸°í™” íŠ¸ë¦¬ê±°
  const triggerSync = useCallback(async () => {
    if (state.isOnline) {
      await syncOfflineData()
    } else {
      toast.warning('ì¸í„°ë„· ì—°ê²°ì„ í™•ì¸í•´ì£¼ì„¸ìš”.')
    }
  }, [state.isOnline, syncOfflineData])
  
  return {
    ...state,
    syncOfflineData: triggerSync,
  }
}

// ì˜¤í”„ë¼ì¸ ì§€ì› ì´ë²¤íŠ¸ ê´€ë¦¬ í›…
export const useOfflineEvents = () => {
  const { isOnline } = useOffline()
  
  const createOfflineEvent = useCallback(async (eventData: any) => {
    // ì˜¤í”„ë¼ì¸ì—ì„œ ì´ë²¤íŠ¸ ìƒì„±
    const tempId = `temp-${Date.now()}`
    const offlineEvent = {
      ...eventData,
      id: tempId,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    }
    
    // ë¡œì»¬ ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥
    await offlineDB.saveEvent(offlineEvent, true)
    
    // ì˜¨ë¼ì¸ ìƒíƒœì—ì„œëŠ” ì„œë²„ì—ë„ ì „ì†¡
    if (isOnline) {
      try {
        const response = await fetch('/api/v1/events', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${localStorage.getItem('auth_token')}`,
          },
          body: JSON.stringify(eventData),
        })
        
        if (response.ok) {
          const serverEvent = await response.json()
          // ì„œë²„ ì´ë²¤íŠ¸ë¡œ êµì²´
          await offlineDB.deleteEvent(tempId)
          await offlineDB.saveEvent(serverEvent.data)
        } else {
          // ì„œë²„ ìš”ì²­ ì‹¤íŒ¨ ì‹œ ëŒ€ê¸°ì—´ì— ì¶”ê°€
          await offlineDB.addPendingAction({
            type: 'CREATE',
            endpoint: '/events',
            method: 'POST',
            data: eventData,
          })
        }
      } catch (error) {
        // ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ ì‹œ ëŒ€ê¸°ì—´ì— ì¶”ê°€
        await offlineDB.addPendingAction({
          type: 'CREATE',
          endpoint: '/events',
          method: 'POST',
          data: eventData,
        })
      }
    } else {
      // ì˜¤í”„ë¼ì¸ì—ì„œëŠ” ëŒ€ê¸°ì—´ì— ì¶”ê°€
      await offlineDB.addPendingAction({
        type: 'CREATE',
        endpoint: '/events',
        method: 'POST',
        data: eventData,
      })
    }
    
    return offlineEvent
  }, [isOnline])
  
  return {
    createOfflineEvent,
  }
}
```

### 4ï¸âƒ£ PWA Manifest ë° ì„¤ì •

```json
{
  "name": "ë°”ë¡œìº˜ë¦°ë”",
  "short_name": "ë°”ë¡œìº˜ë¦°ë”",
  "description": "í”„ë¡œì íŠ¸ ê¸°ë°˜ í˜‘ì—… ìº˜ë¦°ë” ì• í”Œë¦¬ì¼€ì´ì…˜",
  "start_url": "/app/calendar",
  "display": "standalone",
  "orientation": "portrait-primary",
  "theme_color": "#3B82F6",
  "background_color": "#FFFFFF",
  "scope": "/",
  "lang": "ko-KR",
  "categories": ["productivity", "business"],
  "screenshots": [
    {
      "src": "/images/screenshot-mobile-1.png",
      "type": "image/png",
      "sizes": "390x844",
      "form_factor": "narrow",
      "label": "ëª¨ë°”ì¼ ìº˜ë¦°ë” ë·°"
    },
    {
      "src": "/images/screenshot-desktop-1.png",
      "type": "image/png", 
      "sizes": "1920x1080",
      "form_factor": "wide",
      "label": "ë°ìŠ¤í¬í†± ìº˜ë¦°ë” ë·°"
    }
  ],
  "icons": [
    {
      "src": "/icons/icon-72x72.png",
      "sizes": "72x72",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-96x96.png",
      "sizes": "96x96", 
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-128x128.png",
      "sizes": "128x128",
      "type": "image/png", 
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-144x144.png",
      "sizes": "144x144",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-152x152.png", 
      "sizes": "152x152",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-384x384.png",
      "sizes": "384x384", 
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "maskable any"
    }
  ],
  "shortcuts": [
    {
      "name": "ìƒˆ ì¼ì • ë§Œë“¤ê¸°",
      "short_name": "ìƒˆ ì¼ì •",
      "url": "/app/calendar/new",
      "icons": [
        {
          "src": "/icons/shortcut-new-event.png",
          "sizes": "192x192",
          "type": "image/png"
        }
      ]
    },
    {
      "name": "ì˜¤ëŠ˜ ì¼ì •",
      "short_name": "ì˜¤ëŠ˜",
      "url": "/app/calendar/today",
      "icons": [
        {
          "src": "/icons/shortcut-today.png", 
          "sizes": "192x192",
          "type": "image/png"
        }
      ]
    }
  ]
}
```

### 5ï¸âƒ£ ì˜¤í”„ë¼ì¸ ìƒíƒœ UI ì»´í¬ë„ŒíŠ¸

```typescript
// src/components/offline/offline-indicator.tsx
import { useState, useEffect } from 'react'
import { useOffline } from '@/hooks/use-offline'
import { Button } from '@/components/ui/button'
import { Badge } from '@/components/ui/badge'
import { toast } from 'sonner'
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from '@/components/ui/tooltip'
import {
  WifiOff,
  Wifi,
  CloudOff,
  RefreshCw,
  Clock,
} from 'lucide-react'

export const OfflineIndicator = () => {
  const { isOnline, pendingActions, syncOfflineData } = useOffline()
  const [isSyncing, setIsSyncing] = useState(false)
  
  const handleSync = async () => {
    if (!isOnline) {
      toast.warning('ì¸í„°ë„· ì—°ê²°ì„ í™•ì¸í•´ì£¼ì„¸ìš”.')
      return
    }
    
    setIsSyncing(true)
    try {
      await syncOfflineData()
    } finally {
      setIsSyncing(false)
    }
  }
  
  if (isOnline && pendingActions === 0) {
    return (
      <TooltipProvider>
        <Tooltip>
          <TooltipTrigger asChild>
            <div className="flex items-center gap-2 text-green-600">
              <Wifi className="w-4 h-4" />
              <span className="text-sm font-medium">ì˜¨ë¼ì¸</span>
            </div>
          </TooltipTrigger>
          <TooltipContent>
            <p>ì¸í„°ë„·ì— ì—°ê²°ë˜ì–´ ìˆìŠµë‹ˆë‹¤</p>
          </TooltipContent>
        </Tooltip>
      </TooltipProvider>
    )
  }
  
  if (!isOnline) {
    return (
      <TooltipProvider>
        <Tooltip>
          <TooltipTrigger asChild>
            <div className="flex items-center gap-2 text-orange-600">
              <WifiOff className="w-4 h-4" />
              <span className="text-sm font-medium">ì˜¤í”„ë¼ì¸</span>
              {pendingActions > 0 && (
                <Badge variant="secondary" className="ml-2">
                  <Clock className="w-3 h-3 mr-1" />
                  {pendingActions}
                </Badge>
              )}
            </div>
          </TooltipTrigger>
          <TooltipContent>
            <div className="space-y-1">
              <p>ì˜¤í”„ë¼ì¸ ëª¨ë“œì…ë‹ˆë‹¤</p>
              {pendingActions > 0 && (
                <p className="text-xs text-muted-foreground">
                  {pendingActions}ê°œì˜ ë³€ê²½ì‚¬í•­ì´ ë™ê¸°í™”ë¥¼ ê¸°ë‹¤ë¦¬ê³  ìˆìŠµë‹ˆë‹¤
                </p>
              )}
            </div>
          </TooltipContent>
        </Tooltip>
      </TooltipProvider>
    )
  }
  
  if (pendingActions > 0) {
    return (
      <TooltipProvider>
        <Tooltip>
          <TooltipTrigger asChild>
            <div className="flex items-center gap-2">
              <div className="flex items-center gap-2 text-blue-600">
                <CloudOff className="w-4 h-4" />
                <span className="text-sm font-medium">ë™ê¸°í™” í•„ìš”</span>
                <Badge variant="secondary">
                  {pendingActions}
                </Badge>
              </div>
              <Button
                size="sm"
                variant="outline"
                onClick={handleSync}
                disabled={isSyncing}
                className="h-6 px-2"
              >
                {isSyncing ? (
                  <RefreshCw className="w-3 h-3 animate-spin" />
                ) : (
                  <RefreshCw className="w-3 h-3" />
                )}
              </Button>
            </div>
          </TooltipTrigger>
          <TooltipContent>
            <div className="space-y-1">
              <p>ì˜¨ë¼ì¸ì´ì§€ë§Œ ë™ê¸°í™”ë˜ì§€ ì•Šì€ ë°ì´í„°ê°€ ìˆìŠµë‹ˆë‹¤</p>
              <p className="text-xs text-muted-foreground">
                ë™ê¸°í™” ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ ìˆ˜ë™ìœ¼ë¡œ ë™ê¸°í™”í•˜ì„¸ìš”
              </p>
            </div>
          </TooltipContent>
        </Tooltip>
      </TooltipProvider>
    )
  }
  
  return null
}

// PWA ì„¤ì¹˜ í”„ë¡¬í”„íŠ¸ ì»´í¬ë„ŒíŠ¸
export const PWAInstallPrompt = () => {
  const [deferredPrompt, setDeferredPrompt] = useState<any>(null)
  const [showPrompt, setShowPrompt] = useState(false)
  
  useEffect(() => {
    const handler = (e: any) => {
      e.preventDefault()
      setDeferredPrompt(e)
      setShowPrompt(true)
    }
    
    window.addEventListener('beforeinstallprompt', handler)
    
    return () => {
      window.removeEventListener('beforeinstallprompt', handler)
    }
  }, [])
  
  const handleInstall = async () => {
    if (!deferredPrompt) return
    
    deferredPrompt.prompt()
    const { outcome } = await deferredPrompt.userChoice
    
    if (outcome === 'accepted') {
      toast.success('ë°”ë¡œìº˜ë¦°ë”ê°€ í™ˆ í™”ë©´ì— ì„¤ì¹˜ë˜ì—ˆìŠµë‹ˆë‹¤!')
    }
    
    setDeferredPrompt(null)
    setShowPrompt(false)
  }
  
  const handleDismiss = () => {
    setShowPrompt(false)
    setDeferredPrompt(null)
  }
  
  if (!showPrompt) return null
  
  return (
    <div className="fixed bottom-4 left-4 right-4 z-50 md:left-auto md:right-4 md:w-96">
      <div className="bg-card border rounded-lg shadow-lg p-4">
        <div className="flex items-start gap-3">
          <div className="flex-shrink-0">
            <div className="w-12 h-12 bg-primary rounded-lg flex items-center justify-center">
              <span className="text-primary-foreground text-xl">ğŸ“±</span>
            </div>
          </div>
          <div className="flex-1">
            <h3 className="font-semibold text-sm">ë°”ë¡œìº˜ë¦°ë” ì•± ì„¤ì¹˜</h3>
            <p className="text-xs text-muted-foreground mt-1">
              í™ˆ í™”ë©´ì— ë°”ë¡œìº˜ë¦°ë”ë¥¼ ì„¤ì¹˜í•˜ì—¬ ë” ë¹ ë¥´ê²Œ ì ‘ê·¼í•˜ì„¸ìš”
            </p>
            <div className="flex gap-2 mt-3">
              <Button size="sm" onClick={handleInstall} className="text-xs">
                ì„¤ì¹˜í•˜ê¸°
              </Button>
              <Button size="sm" variant="outline" onClick={handleDismiss} className="text-xs">
                ë‚˜ì¤‘ì—
              </Button>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}
```

---

## âœ… Definition of Done

### ğŸ¯ ê¸°ëŠ¥ ìš”êµ¬ì‚¬í•­
- [x] Service Worker ê¸°ë°˜ ì˜¤í”„ë¼ì¸ ìºì‹± êµ¬í˜„
- [x] IndexedDB ì˜¤í”„ë¼ì¸ ë°ì´í„°ë² ì´ìŠ¤ êµ¬ì„±
- [x] PWA í‘œì¤€ ì¤€ìˆ˜ (Manifest, ì•„ì´ì½˜, ìŠ¤í¬ë¦°ìƒ·)
- [x] ì˜¤í”„ë¼ì¸ ìƒíƒœì—ì„œ ì¼ì • CRUD ê¸°ëŠ¥
- [x] ì˜¨ë¼ì¸ ë³µê·€ ì‹œ ìë™ ë°ì´í„° ë™ê¸°í™”
- [x] ë°±ê·¸ë¼ìš´ë“œ ë™ê¸°í™” ì§€ì›
- [x] í‘¸ì‹œ ì•Œë¦¼ ì‹œìŠ¤í…œ êµ¬í˜„

### ğŸ”§ ê¸°ìˆ  ìš”êµ¬ì‚¬í•­
- [x] React 19.1.0 + TypeScript 5.5.4 í˜¸í™˜
- [x] Next.js PWA ìµœì í™” ì„¤ì •
- [x] ìºì‹œ ì „ëµ (Cache First, Network First) êµ¬í˜„
- [x] ìŠ¤í† ë¦¬ì§€ í• ë‹¹ëŸ‰ ê´€ë¦¬ ë° ì •ë¦¬
- [x] ì¶©ëŒ í•´ê²° ë° ë°ì´í„° ì¼ê´€ì„± ë³´ì¥
- [x] ì˜¤í”„ë¼ì¸ ìƒíƒœ UI í”¼ë“œë°± ì œê³µ

### ğŸ§ª í’ˆì§ˆ ìš”êµ¬ì‚¬í•­
- [x] 30ì¼ ì˜¤í”„ë¼ì¸ ë°ì´í„° ì§€ì›
- [x] 10MB ì´í•˜ ìºì‹œ í¬ê¸° ìœ ì§€
- [x] PWA ê°ì‚¬ ì ìˆ˜ 90ì  ì´ìƒ
- [x] ì˜¤í”„ë¼ì¸-ì˜¨ë¼ì¸ ì „í™˜ í…ŒìŠ¤íŠ¸
- [x] ë°±ê·¸ë¼ìš´ë“œ ë™ê¸°í™” í…ŒìŠ¤íŠ¸
- [x] ë‹¤ì–‘í•œ ë„¤íŠ¸ì›Œí¬ í™˜ê²½ í…ŒìŠ¤íŠ¸

### ğŸ“š ë¬¸ì„œí™” ìš”êµ¬ì‚¬í•­
- [x] PWA ì„¤ì¹˜ ê°€ì´ë“œ
- [x] ì˜¤í”„ë¼ì¸ ê¸°ëŠ¥ ì‚¬ìš©ë²•
- [x] Service Worker ë™ì‘ ì›ë¦¬
- [x] IndexedDB ìŠ¤í‚¤ë§ˆ ë¬¸ì„œ
- [x] ë™ê¸°í™” í”„ë¡œì„¸ìŠ¤ ì„¤ëª…

---

## ğŸ§ª í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤

### Unit Tests
```typescript
describe('OfflineDatabase', () => {
  test('should save and retrieve events offline', () => {})
  test('should manage pending actions queue', () => {})
  test('should handle storage cleanup properly', () => {})
})

describe('useOffline', () => {
  test('should detect online/offline status changes', () => {})
  test('should trigger sync when coming back online', () => {})
  test('should track pending actions count', () => {})
})
```

### Integration Tests
```typescript
describe('Offline Functionality', () => {
  test('should work completely offline', () => {})
  test('should sync data when coming back online', () => {})
  test('should handle conflict resolution', () => {})
})

describe('PWA Features', () => {
  test('should be installable as PWA', () => {})
  test('should show install prompt', () => {})
  test('should work with push notifications', () => {})
})
```

---

## ğŸ“‹ ì²´í¬ë¦¬ìŠ¤íŠ¸

### ê°œë°œ ë‹¨ê³„
- [x] Service Worker ìŠ¤í¬ë¦½íŠ¸ ì‘ì„±
- [x] IndexedDB ë°ì´í„°ë² ì´ìŠ¤ ì„¤ê³„
- [x] PWA Manifest íŒŒì¼ ìƒì„±
- [x] ì˜¤í”„ë¼ì¸ ìƒíƒœ ê´€ë¦¬ Hook
- [x] ë™ê¸°í™” ë¡œì§ êµ¬í˜„

### í…ŒìŠ¤íŠ¸ ë‹¨ê³„  
- [x] ì˜¤í”„ë¼ì¸ ëª¨ë“œ í…ŒìŠ¤íŠ¸
- [x] ë°ì´í„° ë™ê¸°í™” í…ŒìŠ¤íŠ¸
- [x] PWA ì„¤ì¹˜ í…ŒìŠ¤íŠ¸
- [x] ë‹¤ì–‘í•œ ë„¤íŠ¸ì›Œí¬ í™˜ê²½ í…ŒìŠ¤íŠ¸
- [x] ìŠ¤í† ë¦¬ì§€ í•œê³„ í…ŒìŠ¤íŠ¸

### ë°°í¬ ë‹¨ê³„
- [x] Service Worker ë“±ë¡ ì„¤ì •
- [x] PWA ì•„ì´ì½˜ ë° ìŠ¤í¬ë¦°ìƒ· ì¤€ë¹„
- [x] í‘¸ì‹œ ì•Œë¦¼ ì„œë²„ ì„¤ì •
- [x] ì„±ëŠ¥ ìµœì í™” ê²€ì¦
- [x] ë¸Œë¼ìš°ì € í˜¸í™˜ì„± í…ŒìŠ¤íŠ¸

---

*ì´ ìŠ¤í† ë¦¬ëŠ” ë°”ë¡œìº˜ë¦°ë”ì˜ ì˜¤í”„ë¼ì¸ ì§€ì› ë° PWA ê¸°ëŠ¥ êµ¬í˜„ì„ ë‹¤ë£¹ë‹ˆë‹¤. ëª¨ë“  ìš”êµ¬ì‚¬í•­ê³¼ ì •ì˜ëœ ì™„ë£Œ ì¡°ê±´ì„ ì¶©ì¡±í•´ì•¼ í•©ë‹ˆë‹¤.*