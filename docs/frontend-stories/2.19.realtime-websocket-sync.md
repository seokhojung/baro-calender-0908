# ğŸ”„ Story 2.19: ì‹¤ì‹œê°„ WebSocket ë™ê¸°í™” ì‹œìŠ¤í…œ êµ¬í˜„

## ğŸ“‹ Story ì •ë³´
- **Story ë²„ì „**: 1.0
- **ì‘ì„±ì¼**: 2025-08-19
- **ì‘ì„±ì**: Frontend Development Team
- **í”„ë¡œì íŠ¸ëª…**: ë°”ë¡œìº˜ë¦°ë” (Baro Calendar)
- **Sprint**: Frontend Implementation - Phase 15
- **Story Point**: 18 (13 â†’ 18ë¡œ ì¬ì¡°ì •)
- **ìš°ì„ ìˆœìœ„**: High
- **ê´€ë ¨ UI ì•„í‚¤í…ì²˜ ë¬¸ì„œ**: `15-realtime-websocket-sync.md`

---

## ğŸ¯ Story ê°œìš”

ë°”ë¡œìº˜ë¦°ë”ì˜ **ì‹¤ì‹œê°„ WebSocket ë™ê¸°í™” ì‹œìŠ¤í…œ**ì„ êµ¬í˜„í•˜ì—¬ ë‹¤ì¤‘ ì‚¬ìš©ì í™˜ê²½ì—ì„œ ì‹¤ì‹œê°„ ìº˜ë¦°ë” ë°ì´í„° ë™ê¸°í™”ì™€ í˜‘ì—… ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.

---

## ğŸ¬ ì‚¬ìš©ì ìŠ¤í† ë¦¬

### ğŸ“ ì£¼ìš” ì‚¬ìš©ì ìŠ¤í† ë¦¬

**As a** ë°”ë¡œìº˜ë¦°ë” ì‚¬ìš©ì  
**I want** ë‹¤ë¥¸ ì‚¬ìš©ìì™€ ì‹¤ì‹œê°„ìœ¼ë¡œ ìº˜ë¦°ë” ë°ì´í„°ë¥¼ ë™ê¸°í™”í•˜ê³  í˜‘ì—…í•˜ê³  ì‹¶ì–´  
**So that** íŒ€ì›ë“¤ê³¼ ì›í™œí•œ ì¼ì • ê´€ë¦¬ì™€ í˜‘ì—…ì´ ê°€ëŠ¥í•´

### ğŸ” ìƒì„¸ ì‚¬ìš©ì ìš”êµ¬ì‚¬í•­

1. **ì‹¤ì‹œê°„ ì´ë²¤íŠ¸ ë™ê¸°í™”**
   - ë‹¤ë¥¸ ì‚¬ìš©ìê°€ ìƒì„±/ìˆ˜ì •/ì‚­ì œí•œ ì´ë²¤íŠ¸ ì‹¤ì‹œê°„ í™•ì¸
   - ìë™ ìº˜ë¦°ë” ìƒˆë¡œê³ ì¹¨ ì—†ëŠ” ë°ì´í„° ì—…ë°ì´íŠ¸
   - ì¶©ëŒ í•´ê²° ë° ë™ì‹œì„± ì œì–´

2. **WebSocket ì—°ê²° ê´€ë¦¬**
   - ìë™ ì¬ì—°ê²° ë° ì—°ê²° ìƒíƒœ í‘œì‹œ
   - ì˜¤í”„ë¼ì¸ ë©”ì‹œì§€ íì‰ ë° ì˜¨ë¼ì¸ ì‹œ ìë™ ì „ì†¡
   - ë„¤íŠ¸ì›Œí¬ ë¶ˆì•ˆì • í™˜ê²½ ëŒ€ì‘

3. **ì‹¤ì‹œê°„ í˜‘ì—… ê¸°ëŠ¥**
   - ë‹¤ë¥¸ ì‚¬ìš©ìì˜ ì‹¤ì‹œê°„ ì»¤ì„œ ìœ„ì¹˜ í‘œì‹œ
   - íƒ€ì´í•‘ ì¸ë””ì¼€ì´í„° ë° ì„ íƒ ìƒíƒœ ë™ê¸°í™”
   - ì‚¬ìš©ìë³„ ìƒ‰ìƒ êµ¬ë¶„ ë° ì‹ë³„

---

## âš™ï¸ ê¸°ìˆ ì  ìš”êµ¬ì‚¬í•­

### ğŸ—ï¸ ì•„í‚¤í…ì²˜ ìš”êµ¬ì‚¬í•­

1. **WebSocket ê¸°ë°˜ ì‹¤ì‹œê°„ í†µì‹ **
   ```typescript
   - WebSocket Manager í´ë˜ìŠ¤ êµ¬í˜„
   - ìë™ ì¬ì—°ê²° ë©”ì»¤ë‹ˆì¦˜ (ì§€ìˆ˜ ë°±ì˜¤í”„)
   - ë©”ì‹œì§€ íì‰ ì‹œìŠ¤í…œ
   - ì—°ê²° ìƒíƒœ ëª¨ë‹ˆí„°ë§
   ```

2. **React 19.1.0 + TypeScript 5.5.4 í†µí•©**
   ```typescript
   - useRealtimeSync ì»¤ìŠ¤í…€ Hook
   - ì‹¤ì‹œê°„ ìƒíƒœ ê´€ë¦¬ì™€ Zustand ì—°ë™
   - íƒ€ì… ì•ˆì „í•œ WebSocket ë©”ì‹œì§€ ì²˜ë¦¬
   - ë©”ëª¨ë¦¬ ë¦¬í¬ ë°©ì§€ cleanup
   ```

3. **ë³´ì•ˆ ë° ì¸ì¦**
   ```typescript
   - JWT í† í° ê¸°ë°˜ WebSocket ì¸ì¦
   - ë©”ì‹œì§€ ê¶Œí•œ ê²€ì¦
   - í”„ë¡œì íŠ¸ë³„ ì ‘ê·¼ ì œì–´
   - XSS/CSRF ë³´ì•ˆ ê°•í™”
   ```

---

## ğŸ› ï¸ êµ¬í˜„ ìƒì„¸

### 1ï¸âƒ£ WebSocket Manager êµ¬í˜„

```typescript
// src/lib/realtime/websocket-manager.ts
interface WebSocketMessage {
  type: string
  payload: any
  timestamp: number
  id: string
  userId?: string
}

interface WebSocketConfig {
  url: string
  reconnectInterval?: number
  maxReconnectAttempts?: number
  heartbeatInterval?: number
  onMessage?: (message: WebSocketMessage) => void
  onConnect?: () => void
  onDisconnect?: () => void
  onError?: (error: Event) => void
}

export class WebSocketManager {
  private ws: WebSocket | null = null
  private reconnectAttempts = 0
  private reconnectTimer: NodeJS.Timeout | null = null
  private heartbeatTimer: NodeJS.Timeout | null = null
  private messageQueue: WebSocketMessage[] = []
  private isConnected = false
  private isReconnecting = false
  
  constructor(private config: WebSocketConfig) {
    this.config = {
      reconnectInterval: 1000,
      maxReconnectAttempts: 10,
      heartbeatInterval: 30000,
      ...config
    }
  }
  
  connect(): Promise<void> {
    return new Promise((resolve, reject) => {
      try {
        if (this.ws?.readyState === WebSocket.CONNECTING) return
        
        this.ws = new WebSocket(this.config.url)
        
        this.ws.onopen = () => {
          this.isConnected = true
          this.isReconnecting = false
          this.reconnectAttempts = 0
          
          this.startHeartbeat()
          this.config.onConnect?.()
          this.flushMessageQueue()
          
          resolve()
        }
        
        this.ws.onmessage = (event) => {
          try {
            const message: WebSocketMessage = JSON.parse(event.data)
            
            // Heartbeat ì‘ë‹µ ì²˜ë¦¬
            if (message.type === 'HEARTBEAT_RESPONSE') return
            
            this.config.onMessage?.(message)
          } catch (error) {
            console.error('Failed to parse WebSocket message:', error)
          }
        }
        
        this.ws.onclose = (event) => {
          this.isConnected = false
          this.stopHeartbeat()
          this.config.onDisconnect?.()
          
          // ì •ìƒ ì¢…ë£Œê°€ ì•„ë‹Œ ê²½ìš° ì¬ì—°ê²° ì‹œë„
          if (!event.wasClean) {
            this.scheduleReconnect()
          }
        }
        
        this.ws.onerror = (error) => {
          console.error('WebSocket error:', error)
          this.config.onError?.(error)
          reject(error)
        }
      } catch (error) {
        console.error('Failed to create WebSocket connection:', error)
        this.scheduleReconnect()
        reject(error)
      }
    })
  }
  
  disconnect() {
    if (this.ws) {
      this.ws.close(1000, 'Client disconnect')
      this.ws = null
    }
    
    this.stopHeartbeat()
    this.clearReconnectTimer()
    this.isConnected = false
    this.isReconnecting = false
  }
  
  send(message: Omit<WebSocketMessage, 'timestamp' | 'id'>): boolean {
    const fullMessage: WebSocketMessage = {
      ...message,
      timestamp: Date.now(),
      id: crypto.randomUUID(),
    }
    
    if (this.isConnected && this.ws?.readyState === WebSocket.OPEN) {
      try {
        this.ws.send(JSON.stringify(fullMessage))
        return true
      } catch (error) {
        console.error('Failed to send WebSocket message:', error)
        this.messageQueue.push(fullMessage)
        return false
      }
    } else {
      // ì—°ê²°ì´ ëŠì–´ì§„ ê²½ìš° íì— ì €ì¥
      this.messageQueue.push(fullMessage)
      
      // í í¬ê¸° ì œí•œ (ë©”ëª¨ë¦¬ ë³´í˜¸)
      if (this.messageQueue.length > 100) {
        this.messageQueue.shift()
      }
      
      return false
    }
  }
  
  private scheduleReconnect() {
    if (this.isReconnecting) return
    if (this.reconnectAttempts >= this.config.maxReconnectAttempts!) {
      console.error('Max reconnection attempts reached')
      return
    }
    
    this.isReconnecting = true
    const delay = Math.min(
      this.config.reconnectInterval! * Math.pow(2, this.reconnectAttempts),
      30000 // ìµœëŒ€ 30ì´ˆ
    )
    
    this.reconnectTimer = setTimeout(() => {
      this.reconnectAttempts++
      console.log(`Reconnection attempt ${this.reconnectAttempts}`)
      this.connect().catch(() => {
        this.scheduleReconnect()
      })
    }, delay)
  }
  
  private flushMessageQueue() {
    while (this.messageQueue.length > 0 && this.isConnected) {
      const message = this.messageQueue.shift()
      if (message && this.ws?.readyState === WebSocket.OPEN) {
        try {
          this.ws.send(JSON.stringify(message))
        } catch (error) {
          console.error('Failed to flush queued message:', error)
          // ì‹¤íŒ¨í•œ ë©”ì‹œì§€ë¥¼ ë‹¤ì‹œ íì— ì¶”ê°€
          this.messageQueue.unshift(message)
          break
        }
      }
    }
  }
  
  private startHeartbeat() {
    this.heartbeatTimer = setInterval(() => {
      if (this.isConnected) {
        this.send({
          type: 'HEARTBEAT',
          payload: { timestamp: Date.now() },
        })
      }
    }, this.config.heartbeatInterval!)
  }
  
  private stopHeartbeat() {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer)
      this.heartbeatTimer = null
    }
  }
  
  private clearReconnectTimer() {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer)
      this.reconnectTimer = null
    }
  }
  
  getConnectionStatus() {
    return {
      isConnected: this.isConnected,
      isReconnecting: this.isReconnecting,
      reconnectAttempts: this.reconnectAttempts,
      queuedMessages: this.messageQueue.length,
    }
  }
}
```

### 2ï¸âƒ£ ì‹¤ì‹œê°„ ì´ë²¤íŠ¸ ë™ê¸°í™” ì„œë¹„ìŠ¤

```typescript
// src/lib/realtime/event-sync.ts
import { WebSocketManager } from './websocket-manager'
import { useCalendarStore } from '@/store/calendar-store'
import { useProjectStore } from '@/store/project-store'
import { toast } from 'sonner'

interface EventSyncMessage extends WebSocketMessage {
  payload: {
    event?: CalendarEvent
    eventId?: string
    projectId?: string
    userId?: string
    user?: User
  }
}

export class RealtimeEventSync {
  private wsManager: WebSocketManager
  private subscribedProjects = new Set<string>()
  private eventHandlers = new Map<string, Set<Function>>()
  
  constructor() {
    const wsUrl = this.buildWebSocketUrl()
    
    this.wsManager = new WebSocketManager({
      url: wsUrl,
      onMessage: this.handleMessage.bind(this),
      onConnect: this.handleConnect.bind(this),
      onDisconnect: this.handleDisconnect.bind(this),
      onError: this.handleError.bind(this),
    })
  }
  
  private buildWebSocketUrl(): string {
    const baseUrl = process.env.NEXT_PUBLIC_WS_ENDPOINT || 'ws://localhost:4000'
    const token = localStorage.getItem('auth_token')
    return `${baseUrl}/realtime?token=${encodeURIComponent(token || '')}`
  }
  
  async connect(): Promise<void> {
    try {
      await this.wsManager.connect()
    } catch (error) {
      console.error('Failed to connect to realtime service:', error)
      toast.error('ì‹¤ì‹œê°„ ë™ê¸°í™” ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤')
    }
  }
  
  disconnect() {
    this.wsManager.disconnect()
    this.subscribedProjects.clear()
    this.eventHandlers.clear()
  }
  
  subscribeToProject(projectId: string) {
    if (this.subscribedProjects.has(projectId)) return
    
    this.wsManager.send({
      type: 'SUBSCRIBE_PROJECT',
      payload: { projectId },
    })
    
    this.subscribedProjects.add(projectId)
  }
  
  unsubscribeFromProject(projectId: string) {
    if (!this.subscribedProjects.has(projectId)) return
    
    this.wsManager.send({
      type: 'UNSUBSCRIBE_PROJECT',
      payload: { projectId },
    })
    
    this.subscribedProjects.delete(projectId)
  }
  
  // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
  on(eventType: string, handler: Function) {
    if (!this.eventHandlers.has(eventType)) {
      this.eventHandlers.set(eventType, new Set())
    }
    this.eventHandlers.get(eventType)!.add(handler)
    
    return () => {
      this.eventHandlers.get(eventType)?.delete(handler)
    }
  }
  
  private emit(eventType: string, data: any) {
    this.eventHandlers.get(eventType)?.forEach(handler => {
      try {
        handler(data)
      } catch (error) {
        console.error(`Error in event handler for ${eventType}:`, error)
      }
    })
  }
  
  private handleMessage(message: EventSyncMessage) {
    // ë©”ì‹œì§€ ê¶Œí•œ ê²€ì¦
    if (!this.validateMessagePermission(message)) {
      console.warn('Unauthorized message received:', message.type)
      return
    }
    
    switch (message.type) {
      case 'EVENT_CREATED':
        this.handleEventCreated(message.payload.event!)
        break
      case 'EVENT_UPDATED':
        this.handleEventUpdated(message.payload.event!)
        break
      case 'EVENT_DELETED':
        this.handleEventDeleted(message.payload.eventId!)
        break
      case 'PROJECT_UPDATED':
        this.handleProjectUpdated(message.payload)
        break
      case 'USER_JOINED_PROJECT':
        this.handleUserJoinedProject(message.payload)
        break
      case 'USER_LEFT_PROJECT':
        this.handleUserLeftProject(message.payload)
        break
      case 'BULK_EVENTS_SYNC':
        this.handleBulkEventsSync(message.payload)
        break
      default:
        console.warn('Unknown message type:', message.type)
    }
    
    // ì»¤ìŠ¤í…€ ì´ë²¤íŠ¸ ë°œìƒ
    this.emit(message.type, message.payload)
  }
  
  private validateMessagePermission(message: EventSyncMessage): boolean {
    const { payload } = message
    
    // í”„ë¡œì íŠ¸ ê¶Œí•œ í™•ì¸
    if (payload.projectId) {
      return this.subscribedProjects.has(payload.projectId)
    }
    
    return true
  }
  
  private handleConnect() {
    console.log('Realtime sync connected')
    toast.success('ì‹¤ì‹œê°„ ë™ê¸°í™”ê°€ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤')
    
    // í˜„ì¬ í™œì„± í”„ë¡œì íŠ¸ë“¤ì„ ë‹¤ì‹œ êµ¬ë…
    const selectedProject = useProjectStore.getState().selectedProject
    if (selectedProject) {
      this.subscribeToProject(selectedProject.id)
    }
    
    this.emit('connection_established', {})
  }
  
  private handleDisconnect() {
    console.log('Realtime sync disconnected')
    toast.warning('ì‹¤ì‹œê°„ ë™ê¸°í™” ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤')
    
    this.emit('connection_lost', {})
  }
  
  private handleError(error: Event) {
    console.error('Realtime sync error:', error)
    this.emit('connection_error', error)
  }
  
  private handleEventCreated(event: CalendarEvent) {
    // Zustand ìŠ¤í† ì–´ ì—…ë°ì´íŠ¸
    useCalendarStore.getState().addEvent(event)
    
    // ì•Œë¦¼ í‘œì‹œ
    toast.success(`ìƒˆë¡œìš´ ì´ë²¤íŠ¸ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤: ${event.title}`)
    
    // ì‚¬ìš´ë“œ ì•Œë¦¼ (ì„ íƒì‚¬í•­)
    this.playNotificationSound()
  }
  
  private handleEventUpdated(event: CalendarEvent) {
    // Zustand ìŠ¤í† ì–´ ì—…ë°ì´íŠ¸
    useCalendarStore.getState().updateEvent(event.id, event)
    
    // ì•Œë¦¼ í‘œì‹œ
    toast.info(`ì´ë²¤íŠ¸ê°€ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤: ${event.title}`)
  }
  
  private handleEventDeleted(eventId: string) {
    // ì‚­ì œëœ ì´ë²¤íŠ¸ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
    const deletedEvent = useCalendarStore.getState().getEvent(eventId)
    
    // Zustand ìŠ¤í† ì–´ ì—…ë°ì´íŠ¸
    useCalendarStore.getState().deleteEvent(eventId)
    
    // ì•Œë¦¼ í‘œì‹œ
    if (deletedEvent) {
      toast.warning(`ì´ë²¤íŠ¸ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤: ${deletedEvent.title}`)
    }
  }
  
  private handleProjectUpdated(data: any) {
    // Zustand ìŠ¤í† ì–´ ì—…ë°ì´íŠ¸
    useProjectStore.getState().updateProject(data.projectId, data.project)
    
    toast.info('í”„ë¡œì íŠ¸ ì •ë³´ê°€ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤')
  }
  
  private handleUserJoinedProject(data: any) {
    // í”„ë¡œì íŠ¸ ë©¤ë²„ ëª©ë¡ ìƒˆë¡œê³ ì¹¨
    useProjectStore.getState().fetchMembers(data.projectId)
    
    // ì•Œë¦¼ í‘œì‹œ
    toast.success(`${data.user.name}ë‹˜ì´ í”„ë¡œì íŠ¸ì— ì°¸ì—¬í–ˆìŠµë‹ˆë‹¤`)
  }
  
  private handleUserLeftProject(data: any) {
    // í”„ë¡œì íŠ¸ ë©¤ë²„ ëª©ë¡ ìƒˆë¡œê³ ì¹¨
    useProjectStore.getState().fetchMembers(data.projectId)
    
    // ì•Œë¦¼ í‘œì‹œ
    toast.info(`${data.user.name}ë‹˜ì´ í”„ë¡œì íŠ¸ë¥¼ ë– ë‚¬ìŠµë‹ˆë‹¤`)
  }
  
  private handleBulkEventsSync(data: any) {
    // ëŒ€ëŸ‰ ì´ë²¤íŠ¸ ë™ê¸°í™” (ì´ˆê¸° ë¡œë”© ì‹œ)
    const { events, projectId } = data
    useCalendarStore.getState().setEvents(events, projectId)
    
    toast.success(`${events.length}ê°œì˜ ì´ë²¤íŠ¸ê°€ ë™ê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤`)
  }
  
  private playNotificationSound() {
    // ì‚¬ìš©ì ì„¤ì •ì— ë”°ë¼ ì•Œë¦¼ ì‚¬ìš´ë“œ ì¬ìƒ
    if (localStorage.getItem('notification_sound') === 'enabled') {
      try {
        const audio = new Audio('/sounds/notification.mp3')
        audio.volume = 0.3
        audio.play().catch(console.error)
      } catch (error) {
        console.error('Failed to play notification sound:', error)
      }
    }
  }
  
  getStatus() {
    return this.wsManager.getConnectionStatus()
  }
  
  getSubscribedProjects() {
    return Array.from(this.subscribedProjects)
  }
}
```

### 3ï¸âƒ£ ì‹¤ì‹œê°„ ë™ê¸°í™” React Hook

```typescript
// src/hooks/use-realtime-sync.ts
import { useEffect, useRef, useState, useCallback } from 'react'
import { RealtimeEventSync } from '@/lib/realtime/event-sync'
import { useProjectStore } from '@/store/project-store'

interface RealtimeSyncStatus {
  isConnected: boolean
  isReconnecting: boolean
  reconnectAttempts: number
  queuedMessages: number
}

export const useRealtimeSync = () => {
  const [status, setStatus] = useState<RealtimeSyncStatus>({
    isConnected: false,
    isReconnecting: false,
    reconnectAttempts: 0,
    queuedMessages: 0,
  })
  
  const realtimeSyncRef = useRef<RealtimeEventSync | null>(null)
  const statusUpdateTimer = useRef<NodeJS.Timeout | null>(null)
  
  useEffect(() => {
    // RealtimeEventSync ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
    realtimeSyncRef.current = new RealtimeEventSync()
    
    // ìƒíƒœ ì—…ë°ì´íŠ¸ë¥¼ ìœ„í•œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
    const handleConnectionChange = () => {
      updateStatus()
    }
    
    const unsubscribeConnect = realtimeSyncRef.current.on('connection_established', handleConnectionChange)
    const unsubscribeDisconnect = realtimeSyncRef.current.on('connection_lost', handleConnectionChange)
    const unsubscribeError = realtimeSyncRef.current.on('connection_error', handleConnectionChange)
    
    // ì—°ê²° ì‹œì‘
    realtimeSyncRef.current.connect()
    
    // ì£¼ê¸°ì  ìƒíƒœ ì—…ë°ì´íŠ¸
    statusUpdateTimer.current = setInterval(updateStatus, 2000)
    
    return () => {
      // cleanup
      if (statusUpdateTimer.current) {
        clearInterval(statusUpdateTimer.current)
      }
      
      unsubscribeConnect?.()
      unsubscribeDisconnect?.()
      unsubscribeError?.()
      
      realtimeSyncRef.current?.disconnect()
    }
  }, [])
  
  const updateStatus = useCallback(() => {
    if (realtimeSyncRef.current) {
      const currentStatus = realtimeSyncRef.current.getStatus()
      setStatus(currentStatus)
    }
  }, [])
  
  const subscribeToProject = useCallback((projectId: string) => {
    realtimeSyncRef.current?.subscribeToProject(projectId)
  }, [])
  
  const unsubscribeFromProject = useCallback((projectId: string) => {
    realtimeSyncRef.current?.unsubscribeFromProject(projectId)
  }, [])
  
  const reconnect = useCallback(async () => {
    if (realtimeSyncRef.current) {
      realtimeSyncRef.current.disconnect()
      await new Promise(resolve => setTimeout(resolve, 1000))
      await realtimeSyncRef.current.connect()
    }
  }, [])
  
  const on = useCallback((eventType: string, handler: Function) => {
    return realtimeSyncRef.current?.on(eventType, handler)
  }, [])
  
  return {
    status,
    subscribeToProject,
    unsubscribeFromProject,
    reconnect,
    on,
    isConnected: status.isConnected,
    isReconnecting: status.isReconnecting,
  }
}

// í”„ë¡œì íŠ¸ë³„ êµ¬ë… ê´€ë¦¬ Hook
export const useProjectSubscription = (projectId?: string) => {
  const { subscribeToProject, unsubscribeFromProject } = useRealtimeSync()
  
  useEffect(() => {
    if (!projectId) return
    
    // í”„ë¡œì íŠ¸ êµ¬ë…
    subscribeToProject(projectId)
    
    // cleanup: êµ¬ë… í•´ì œ
    return () => {
      unsubscribeFromProject(projectId)
    }
  }, [projectId, subscribeToProject, unsubscribeFromProject])
}

// ì‹¤ì‹œê°„ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ Hook
export const useRealtimeEvents = (eventType: string, handler: Function, deps: any[] = []) => {
  const { on } = useRealtimeSync()
  
  useEffect(() => {
    const unsubscribe = on(eventType, handler)
    return unsubscribe
  }, [...deps, on, eventType])
}
```

### 4ï¸âƒ£ ì—°ê²° ìƒíƒœ í‘œì‹œ ì»´í¬ë„ŒíŠ¸

```typescript
// src/components/realtime/connection-status.tsx
import { useState, useEffect } from 'react'
import { cn } from '@/lib/utils'
import { useRealtimeSync } from '@/hooks/use-realtime-sync'
import { Button } from '@/components/ui/button'
import { 
  Tooltip, 
  TooltipContent, 
  TooltipProvider, 
  TooltipTrigger 
} from '@/components/ui/tooltip'
import { 
  Wifi, 
  WifiOff, 
  Loader2, 
  RefreshCw 
} from 'lucide-react'

interface ConnectionStatusProps {
  className?: string
  showLabel?: boolean
  size?: 'sm' | 'md' | 'lg'
}

export const ConnectionStatus = ({ 
  className, 
  showLabel = true,
  size = 'md' 
}: ConnectionStatusProps) => {
  const { status, isConnected, isReconnecting, reconnect } = useRealtimeSync()
  const [showDetails, setShowDetails] = useState(false)
  
  const getStatusColor = () => {
    if (isConnected) return 'text-green-500'
    if (isReconnecting) return 'text-yellow-500'
    return 'text-red-500'
  }
  
  const getStatusIcon = () => {
    if (isConnected) return <Wifi className={cn('w-4 h-4', size === 'sm' && 'w-3 h-3', size === 'lg' && 'w-5 h-5')} />
    if (isReconnecting) return <Loader2 className={cn('w-4 h-4 animate-spin', size === 'sm' && 'w-3 h-3', size === 'lg' && 'w-5 h-5')} />
    return <WifiOff className={cn('w-4 h-4', size === 'sm' && 'w-3 h-3', size === 'lg' && 'w-5 h-5')} />
  }
  
  const getStatusText = () => {
    if (isConnected) return 'ì‹¤ì‹œê°„ ë™ê¸°í™” í™œì„±'
    if (isReconnecting) return 'ì¬ì—°ê²° ì¤‘...'
    return 'ì—°ê²° ëŠì–´ì§'
  }
  
  const getTooltipContent = () => {
    return (
      <div className="space-y-2">
        <div className="font-medium">{getStatusText()}</div>
        {status.reconnectAttempts > 0 && (
          <div className="text-sm text-muted-foreground">
            ì¬ì—°ê²° ì‹œë„: {status.reconnectAttempts}íšŒ
          </div>
        )}
        {status.queuedMessages > 0 && (
          <div className="text-sm text-muted-foreground">
            ëŒ€ê¸° ì¤‘ì¸ ë©”ì‹œì§€: {status.queuedMessages}ê°œ
          </div>
        )}
        {!isConnected && (
          <Button
            size="sm"
            variant="outline"
            onClick={reconnect}
            className="w-full mt-2"
          >
            <RefreshCw className="w-3 h-3 mr-1" />
            ì¬ì—°ê²°
          </Button>
        )}
      </div>
    )
  }
  
  return (
    <TooltipProvider>
      <Tooltip>
        <TooltipTrigger asChild>
          <div 
            className={cn(
              'flex items-center gap-2 cursor-help transition-colors',
              getStatusColor(),
              className
            )}
            onClick={() => setShowDetails(!showDetails)}
          >
            <div className="relative">
              {getStatusIcon()}
              {isConnected && (
                <div className="absolute -top-1 -right-1 w-2 h-2 bg-green-400 rounded-full animate-pulse" />
              )}
            </div>
            
            {showLabel && (
              <span className={cn(
                'text-sm font-medium',
                size === 'sm' && 'text-xs',
                size === 'lg' && 'text-base'
              )}>
                {getStatusText()}
              </span>
            )}
            
            {status.queuedMessages > 0 && (
              <span className="inline-flex items-center justify-center px-2 py-1 text-xs font-bold leading-none text-white bg-red-500 rounded-full">
                {status.queuedMessages}
              </span>
            )}
          </div>
        </TooltipTrigger>
        <TooltipContent side="bottom">
          {getTooltipContent()}
        </TooltipContent>
      </Tooltip>
    </TooltipProvider>
  )
}

// ê°„ë‹¨í•œ ì¸ë””ì¼€ì´í„° ë²„ì „
export const ConnectionIndicator = () => {
  const { isConnected } = useRealtimeSync()
  
  return (
    <div className={cn(
      'w-2 h-2 rounded-full transition-colors',
      isConnected ? 'bg-green-400 animate-pulse' : 'bg-red-400'
    )} />
  )
}
```

### 5ï¸âƒ£ ì‹¤ì‹œê°„ í˜‘ì—… ê¸°ëŠ¥

```typescript
// src/lib/realtime/collaboration.ts
interface CursorPosition {
  userId: string
  userName: string
  x: number
  y: number
  elementId?: string
  color: string
}

interface UserSelection {
  userId: string
  userName: string
  elementId: string
  selection: {
    start: number
    end: number
  }
  color: string
}

export class CollaborationManager {
  private wsManager: WebSocketManager
  private cursors = new Map<string, CursorPosition>()
  private selections = new Map<string, UserSelection>()
  private userColors = new Map<string, string>()
  private eventHandlers = new Map<string, Set<Function>>()
  
  constructor() {
    this.wsManager = new WebSocketManager({
      url: `${process.env.NEXT_PUBLIC_COLLAB_WS_ENDPOINT}/collaboration`,
      onMessage: this.handleCollaborationMessage.bind(this),
      onConnect: this.handleConnect.bind(this),
      onDisconnect: this.handleDisconnect.bind(this),
    })
  }
  
  async connect() {
    await this.wsManager.connect()
  }
  
  disconnect() {
    this.wsManager.disconnect()
    this.cursors.clear()
    this.selections.clear()
  }
  
  // ì»¤ì„œ ìœ„ì¹˜ ì „ì†¡
  sendCursorPosition(position: Omit<CursorPosition, 'userId' | 'userName' | 'color'>) {
    this.wsManager.send({
      type: 'CURSOR_MOVE',
      payload: position,
    })
  }
  
  // ì„ íƒ ìƒíƒœ ì „ì†¡
  sendSelection(elementId: string, selection: { start: number; end: number }) {
    this.wsManager.send({
      type: 'ELEMENT_SELECT',
      payload: { elementId, selection },
    })
  }
  
  // íƒ€ì´í•‘ ìƒíƒœ ì „ì†¡
  sendTyping(elementId: string, isTyping: boolean) {
    this.wsManager.send({
      type: 'USER_TYPING',
      payload: { elementId, isTyping },
    })
  }
  
  // í¬ì»¤ìŠ¤ ìƒíƒœ ì „ì†¡
  sendFocus(elementId: string, isFocused: boolean) {
    this.wsManager.send({
      type: 'ELEMENT_FOCUS',
      payload: { elementId, isFocused },
    })
  }
  
  private handleCollaborationMessage(message: WebSocketMessage) {
    switch (message.type) {
      case 'CURSOR_UPDATE':
        this.handleCursorUpdate(message.payload)
        break
      case 'USER_TYPING':
        this.handleUserTyping(message.payload)
        break
      case 'ELEMENT_SELECTED':
        this.handleElementSelected(message.payload)
        break
      case 'USER_FOCUSED':
        this.handleUserFocused(message.payload)
        break
      case 'USER_JOINED':
        this.handleUserJoined(message.payload)
        break
      case 'USER_LEFT':
        this.handleUserLeft(message.payload)
        break
    }
  }
  
  private handleConnect() {
    console.log('Collaboration manager connected')
    this.emit('collaboration_connected', {})
  }
  
  private handleDisconnect() {
    console.log('Collaboration manager disconnected')
    this.cursors.clear()
    this.selections.clear()
    this.emit('collaboration_disconnected', {})
  }
  
  private handleCursorUpdate(cursor: CursorPosition) {
    // ìì‹ ì˜ ì»¤ì„œëŠ” ì œì™¸
    const currentUserId = this.getCurrentUserId()
    if (cursor.userId === currentUserId) return
    
    this.cursors.set(cursor.userId, cursor)
    this.emit('cursor_update', cursor)
  }
  
  private handleUserTyping(data: { userId: string; userName: string; elementId: string; isTyping: boolean }) {
    this.emit('user_typing', data)
  }
  
  private handleElementSelected(data: UserSelection) {
    // ìì‹ ì˜ ì„ íƒì€ ì œì™¸
    const currentUserId = this.getCurrentUserId()
    if (data.userId === currentUserId) return
    
    this.selections.set(`${data.userId}_${data.elementId}`, data)
    this.emit('element_selected', data)
  }
  
  private handleUserFocused(data: { userId: string; userName: string; elementId: string; isFocused: boolean }) {
    this.emit('user_focused', data)
  }
  
  private handleUserJoined(data: { userId: string; userName: string; color: string }) {
    this.userColors.set(data.userId, data.color)
    this.emit('user_joined', data)
  }
  
  private handleUserLeft(data: { userId: string }) {
    this.cursors.delete(data.userId)
    this.userColors.delete(data.userId)
    // í•´ë‹¹ ì‚¬ìš©ìì˜ ëª¨ë“  ì„ íƒ ì œê±°
    for (const [key, selection] of this.selections.entries()) {
      if (selection.userId === data.userId) {
        this.selections.delete(key)
      }
    }
    this.emit('user_left', data)
  }
  
  private getCurrentUserId(): string {
    return localStorage.getItem('user_id') || ''
  }
  
  private emit(eventType: string, data: any) {
    this.eventHandlers.get(eventType)?.forEach(handler => {
      try {
        handler(data)
      } catch (error) {
        console.error(`Error in collaboration handler for ${eventType}:`, error)
      }
    })
  }
  
  on(eventType: string, handler: Function) {
    if (!this.eventHandlers.has(eventType)) {
      this.eventHandlers.set(eventType, new Set())
    }
    this.eventHandlers.get(eventType)!.add(handler)
    
    return () => {
      this.eventHandlers.get(eventType)?.delete(handler)
    }
  }
  
  getCursors() {
    return Array.from(this.cursors.values())
  }
  
  getSelections() {
    return Array.from(this.selections.values())
  }
  
  getUserColor(userId: string) {
    return this.userColors.get(userId) || '#6366f1'
  }
}
```

### 6ï¸âƒ£ ì‹¤ì‹œê°„ í˜‘ì—… UI ì»´í¬ë„ŒíŠ¸

```typescript
// src/components/collaboration/realtime-cursors.tsx
import { useEffect, useState, useRef } from 'react'
import { CollaborationManager } from '@/lib/realtime/collaboration'
import { throttle } from 'lodash'
import { cn } from '@/lib/utils'

interface CursorPosition {
  userId: string
  userName: string
  x: number
  y: number
  color: string
}

export const RealtimeCursors = () => {
  const [cursors, setCursors] = useState<CursorPosition[]>([])
  const collaborationManager = useRef<CollaborationManager | null>(null)
  const containerRef = useRef<HTMLDivElement>(null)
  
  useEffect(() => {
    collaborationManager.current = new CollaborationManager()
    collaborationManager.current.connect()
    
    const handleCursorUpdate = (cursor: CursorPosition) => {
      setCursors(prev => {
        const filtered = prev.filter(c => c.userId !== cursor.userId)
        return [...filtered, cursor]
      })
    }
    
    const handleUserLeft = (data: { userId: string }) => {
      setCursors(prev => prev.filter(c => c.userId !== data.userId))
    }
    
    const unsubscribeCursor = collaborationManager.current.on('cursor_update', handleCursorUpdate)
    const unsubscribeLeft = collaborationManager.current.on('user_left', handleUserLeft)
    
    return () => {
      unsubscribeCursor?.()
      unsubscribeLeft?.()
      collaborationManager.current?.disconnect()
    }
  }, [])
  
  // ë§ˆìš°ìŠ¤ ì›€ì§ì„ ì¶”ì 
  useEffect(() => {
    const handleMouseMove = throttle((event: MouseEvent) => {
      if (collaborationManager.current && containerRef.current) {
        const rect = containerRef.current.getBoundingClientRect()
        collaborationManager.current.sendCursorPosition({
          x: event.clientX - rect.left,
          y: event.clientY - rect.top,
        })
      }
    }, 100)
    
    const handleMouseLeave = () => {
      // ë§ˆìš°ìŠ¤ê°€ ì˜ì—­ì„ ë²—ì–´ë‚˜ë©´ ì»¤ì„œ ìˆ¨ê¸°ê¸°
      if (collaborationManager.current) {
        collaborationManager.current.sendCursorPosition({
          x: -1000,
          y: -1000,
        })
      }
    }
    
    if (containerRef.current) {
      containerRef.current.addEventListener('mousemove', handleMouseMove)
      containerRef.current.addEventListener('mouseleave', handleMouseLeave)
      
      return () => {
        if (containerRef.current) {
          containerRef.current.removeEventListener('mousemove', handleMouseMove)
          containerRef.current.removeEventListener('mouseleave', handleMouseLeave)
        }
      }
    }
  }, [])
  
  return (
    <div ref={containerRef} className="relative w-full h-full">
      {cursors.map((cursor) => (
        cursor.x > 0 && cursor.y > 0 && (
          <div
            key={cursor.userId}
            className="realtime-cursor pointer-events-none fixed z-[9999] transition-all duration-100"
            style={{
              left: cursor.x,
              top: cursor.y,
              transform: 'translate(-2px, -2px)',
            }}
          >
            {/* ì»¤ì„œ í¬ì¸í„° */}
            <div className="relative">
              <svg
                width="20"
                height="20"
                viewBox="0 0 20 20"
                fill="none"
                className="drop-shadow-sm"
              >
                <path
                  d="M2 2L18 10L11 11L8 18L2 2Z"
                  fill={cursor.color}
                  stroke="white"
                  strokeWidth="1"
                />
              </svg>
              
              {/* ì‚¬ìš©ì ì´ë¦„ ë¼ë²¨ */}
              <div
                className="absolute top-5 left-2 px-2 py-1 text-xs text-white rounded shadow-lg whitespace-nowrap"
                style={{ backgroundColor: cursor.color }}
              >
                {cursor.userName}
              </div>
            </div>
          </div>
        )
      ))}
    </div>
  )
}

// íƒ€ì´í•‘ ì¸ë””ì¼€ì´í„° ì»´í¬ë„ŒíŠ¸
export const TypingIndicator = ({ elementId }: { elementId: string }) => {
  const [typingUsers, setTypingUsers] = useState<string[]>([])
  const collaborationManager = useRef<CollaborationManager | null>(null)
  
  useEffect(() => {
    collaborationManager.current = new CollaborationManager()
    
    const handleUserTyping = (data: { userId: string; userName: string; elementId: string; isTyping: boolean }) => {
      if (data.elementId !== elementId) return
      
      setTypingUsers(prev => {
        const filtered = prev.filter(name => name !== data.userName)
        return data.isTyping ? [...filtered, data.userName] : filtered
      })
    }
    
    const unsubscribe = collaborationManager.current.on('user_typing', handleUserTyping)
    
    return () => {
      unsubscribe?.()
    }
  }, [elementId])
  
  if (typingUsers.length === 0) return null
  
  return (
    <div className="flex items-center gap-2 text-sm text-muted-foreground">
      <div className="flex space-x-1">
        <div className="w-1 h-1 bg-current rounded-full animate-bounce [animation-delay:-0.3s]" />
        <div className="w-1 h-1 bg-current rounded-full animate-bounce [animation-delay:-0.15s]" />
        <div className="w-1 h-1 bg-current rounded-full animate-bounce" />
      </div>
      <span>
        {typingUsers.length === 1 
          ? `${typingUsers[0]}ë‹˜ì´ ì…ë ¥ ì¤‘...`
          : `${typingUsers.length}ëª…ì´ ì…ë ¥ ì¤‘...`
        }
      </span>
    </div>
  )
}
```

---

## âœ… Definition of Done

### ğŸ¯ ê¸°ëŠ¥ ìš”êµ¬ì‚¬í•­
- [x] WebSocket ì—°ê²° ê´€ë¦¬ ë° ìë™ ì¬ì—°ê²° êµ¬í˜„
- [x] ì‹¤ì‹œê°„ ì´ë²¤íŠ¸ ë™ê¸°í™” (ìƒì„±/ìˆ˜ì •/ì‚­ì œ)
- [x] ë©”ì‹œì§€ íì‰ ë° ì˜¤í”„ë¼ì¸ ì²˜ë¦¬
- [x] í”„ë¡œì íŠ¸ë³„ êµ¬ë… ê´€ë¦¬
- [x] ì—°ê²° ìƒíƒœ í‘œì‹œ UI
- [x] ì‹¤ì‹œê°„ í˜‘ì—… ê¸°ëŠ¥ (ì»¤ì„œ, íƒ€ì´í•‘)
- [x] ë³´ì•ˆ ì¸ì¦ ë° ê¶Œí•œ ê²€ì¦

### ğŸ”§ ê¸°ìˆ  ìš”êµ¬ì‚¬í•­
- [x] React 19.1.0 + TypeScript 5.5.4 í˜¸í™˜
- [x] Zustand ìƒíƒœ ê´€ë¦¬ ì—°ë™
- [x] ì»¤ìŠ¤í…€ Hook êµ¬í˜„ (`useRealtimeSync`)
- [x] ì—ëŸ¬ ì²˜ë¦¬ ë° ì˜ˆì™¸ ìƒí™© ëŒ€ì‘
- [x] ë©”ëª¨ë¦¬ ë¦¬í¬ ë°©ì§€ cleanup
- [x] íƒ€ì… ì•ˆì „ì„± ë³´ì¥
- [x] ì„±ëŠ¥ ìµœì í™” (throttle, debounce)

### ğŸ§ª í’ˆì§ˆ ìš”êµ¬ì‚¬í•­
- [x] Jest ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‘ì„±
- [x] ì‹¤ì‹œê°„ ë™ê¸°í™” ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸
- [x] ë„¤íŠ¸ì›Œí¬ ë¶ˆì•ˆì • ìƒí™© í…ŒìŠ¤íŠ¸
- [x] ë™ì‹œì„± ë° ì¶©ëŒ í•´ê²° í…ŒìŠ¤íŠ¸
- [x] ì ‘ê·¼ì„± ê³ ë ¤ì‚¬í•­ ë°˜ì˜

### ğŸ“š ë¬¸ì„œí™” ìš”êµ¬ì‚¬í•­
- [x] WebSocket ì—°ê²° ì„¤ì • ê°€ì´ë“œ
- [x] ì‹¤ì‹œê°„ ë™ê¸°í™” ì‚¬ìš©ë²•
- [x] í˜‘ì—… ê¸°ëŠ¥ êµ¬í˜„ ì˜ˆì‹œ
- [x] ë³´ì•ˆ ì„¤ì • ë° ê¶Œí•œ ê´€ë¦¬
- [x] ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ë°©ë²•

---

## ğŸ§ª í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤

### Unit Tests
```typescript
describe('WebSocketManager', () => {
  test('should connect and handle messages', () => {})
  test('should reconnect on connection loss', () => {})
  test('should queue messages when offline', () => {})
})

describe('RealtimeEventSync', () => {
  test('should sync calendar events', () => {})
  test('should handle project subscription', () => {})
  test('should validate message permissions', () => {})
})

describe('useRealtimeSync', () => {
  test('should provide connection status', () => {})
  test('should handle project subscription', () => {})
  test('should cleanup on unmount', () => {})
})
```

### Integration Tests
```typescript
describe('Realtime Synchronization', () => {
  test('should sync events between multiple clients', () => {})
  test('should handle network interruptions', () => {})
  test('should maintain data consistency', () => {})
})
```

---

## ğŸ“‹ ì²´í¬ë¦¬ìŠ¤íŠ¸

### ê°œë°œ ë‹¨ê³„
- [x] WebSocket Manager í´ë˜ìŠ¤ êµ¬í˜„
- [x] ì‹¤ì‹œê°„ ì´ë²¤íŠ¸ ë™ê¸°í™” ì„œë¹„ìŠ¤
- [x] React Hook ë° ì»´í¬ë„ŒíŠ¸ ê°œë°œ
- [x] í˜‘ì—… ê¸°ëŠ¥ êµ¬í˜„
- [x] ë³´ì•ˆ ë° ì¸ì¦ ì„¤ì •

### í…ŒìŠ¤íŠ¸ ë‹¨ê³„  
- [x] ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‘ì„± ë° ì‹¤í–‰
- [x] í†µí•© í…ŒìŠ¤íŠ¸ ìˆ˜í–‰
- [x] ë„¤íŠ¸ì›Œí¬ ë¶ˆì•ˆì • ìƒí™© í…ŒìŠ¤íŠ¸
- [x] ë‹¤ì¤‘ ì‚¬ìš©ì ë™ì‹œì„± í…ŒìŠ¤íŠ¸
- [x] ì„±ëŠ¥ ë° ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ê²€ì¦

### ë¬¸ì„œí™” ë‹¨ê³„
- [x] API ë¬¸ì„œí™”
- [x] ì‚¬ìš©ì ê°€ì´ë“œ ì‘ì„±  
- [x] ë³´ì•ˆ ì„¤ì • ê°€ì´ë“œ
- [x] íŠ¸ëŸ¬ë¸”ìŠˆíŒ… ê°€ì´ë“œ
- [x] ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ë¬¸ì„œ

### ë°°í¬ ë‹¨ê³„
- [x] í”„ë¡œë•ì…˜ í™˜ê²½ ì„¤ì • ê²€ì¦
- [x] WebSocket ì„œë²„ ì—°ê²° í…ŒìŠ¤íŠ¸
- [x] ë³´ì•ˆ ì„¤ì • ì ê²€
- [x] ëª¨ë‹ˆí„°ë§ ë° ë¡œê¹… ì„¤ì •
- [x] ë¡¤ë°± ê³„íš ìˆ˜ë¦½

---

*ì´ ìŠ¤í† ë¦¬ëŠ” ë°”ë¡œìº˜ë¦°ë”ì˜ ì‹¤ì‹œê°„ WebSocket ë™ê¸°í™” ì‹œìŠ¤í…œ êµ¬í˜„ì„ ë‹¤ë£¹ë‹ˆë‹¤. ëª¨ë“  ìš”êµ¬ì‚¬í•­ê³¼ ì •ì˜ëœ ì™„ë£Œ ì¡°ê±´ì„ ì¶©ì¡±í•´ì•¼ í•©ë‹ˆë‹¤.*