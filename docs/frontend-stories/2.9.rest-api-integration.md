# Story 2.9: REST API í†µí•© ì‹œìŠ¤í…œ

## Status
Ready for Development

## Priority & Dependencies
- **Priority**: P0 (Critical)
- **Story Points**: 8
- **Dependencies**: [1.1c, 1.7]
- **Blocked By**: None

## Success Metrics
- **Business KPI**: 
  - API ì‘ë‹µ ì‹œê°„ 200ms ì´ë‚´
  - ë°ì´í„° ë™ê¸°í™” ì˜¤ë¥˜ìœ¨ 0.1% ì´í•˜
  - ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ ì§€ì—° 100ms ì´ë‚´
- **Technical KPI**:
  - GraphQL ì¿ ë¦¬ ìºì‹œ íˆíŠ¸ìœ¨ 85% ì´ìƒ
  - íƒ€ì… ì•ˆì „ì„± 100% (ì»´íŒŒì¼ ì˜¤ë¥˜ 0ê°œ)
  - Subscription ì—°ê²° ì•ˆì •ì„± 99% ì´ìƒ
- **Definition of Success**: ì™„ì „í•œ GraphQL í†µí•©, ì‹¤ì‹œê°„ ë°ì´í„° ë™ê¸°í™”

## Risks & Mitigations
- **Technical Risks**: 
  - Risk: GraphQL ìŠ¤í‚¤ë§ˆ ë³€ê²½ ì‹œ íƒ€ì… ì¶©ëŒ
  - Impact: High
  - Mitigation: ìë™ ì½”ë“œ ìƒì„±, ìŠ¤í‚¤ë§ˆ ë²„ì €ë‹
- **Schedule Risks**:
  - Risk: Subscription ë³µì¡ë„
  - Impact: Medium
  - Mitigation: ë‹¨ê³„ì  êµ¬í˜„, í´ë§ ì „ëµ

---

## ğŸ¯ Story ê°œìš”

ë°”ë¡œìº˜ë¦°ë”ì˜ **ì™„ì „í•œ REST API í†µí•© ì‹œìŠ¤í…œ**ì„ êµ¬í˜„í•˜ì—¬ ë°±ì—”ë“œ APIì™€ ì™„ë²½íˆ í˜¸í™˜ë˜ëŠ” íƒ€ì… ì•ˆì „í•œ ë°ì´í„° í†µì‹ ì„ ì œê³µí•©ë‹ˆë‹¤.

**âš ï¸ ì¤‘ìš”í•œ ë³€ê²½ì‚¬í•­**: GraphQLì—ì„œ REST APIë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜í•˜ì—¬ ë°±ì—”ë“œ API ìŠ¤í™ê³¼ ì™„ë²½ í˜¸í™˜

---

## ğŸ¬ ì‚¬ìš©ì ìŠ¤í† ë¦¬

### ğŸ“ ì£¼ìš” ì‚¬ìš©ì ìŠ¤í† ë¦¬

**As a** ë°”ë¡œìº˜ë¦°ë” ê°œë°œì  
**I want** ë°±ì—”ë“œ REST APIì™€ ì™„ë²½íˆ í˜¸í™˜ë˜ëŠ” íƒ€ì… ì•ˆì „í•œ API í´ë¼ì´ì–¸íŠ¸ë¥¼ ì‚¬ìš©í•˜ê³  ì‹¶ì–´  
**So that** ì‹ ë¢°í•  ìˆ˜ ìˆê³  ì¼ê´€ëœ ë°ì´í„° í†µì‹ ì´ ê°€ëŠ¥í•´

### ğŸ” ìƒì„¸ ì‚¬ìš©ì ìš”êµ¬ì‚¬í•­

1. **ë°±ì—”ë“œ API í˜¸í™˜ì„±**
   - `/api/v1/timeline`, `/api/v1/events` ë“± ì‹¤ì œ ì—”ë“œí¬ì¸íŠ¸ì™€ ì •í™•íˆ ì¼ì¹˜
   - JWT í† í° ê¸°ë°˜ ì¸ì¦ ì‹œìŠ¤í…œ
   - í”„ë¡œì íŠ¸ë³„ ê¶Œí•œ ê´€ë¦¬ ì§€ì›

2. **íƒ€ì… ì•ˆì „ì„± ë° ê°œë°œ ê²½í—˜**
   - TypeScript ê¸°ë°˜ API í´ë¼ì´ì–¸íŠ¸
   - ìë™ì™„ì„± ë° íƒ€ì… ê²€ì¦
   - ì¼ê´€ëœ ì—ëŸ¬ ì²˜ë¦¬

3. **ì„±ëŠ¥ ë° ì‚¬ìš©ì„±**
   - TanStack Query ê¸°ë°˜ ìºì‹±
   - ìë™ ì¬ì‹œë„ ë° ë°±ê·¸ë¼ìš´ë“œ ì—…ë°ì´íŠ¸
   - ì˜¤í”„ë¼ì¸ ì§€ì› ë° ë™ê¸°í™”

---

## âš™ï¸ ê¸°ìˆ ì  ìš”êµ¬ì‚¬í•­

### ğŸ—ï¸ ì•„í‚¤í…ì²˜ ìš”êµ¬ì‚¬í•­

1. **REST API í´ë¼ì´ì–¸íŠ¸ êµ¬ì„±**
   ```typescript
   - Axios ê¸°ë°˜ HTTP í´ë¼ì´ì–¸íŠ¸
   - JWT í† í° ìë™ ê´€ë¦¬
   - ìš”ì²­/ì‘ë‹µ ì¸í„°ì…‰í„°
   - íƒ€ì… ì•ˆì „í•œ API í˜¸ì¶œ
   ```

2. **TanStack Query í†µí•©**
   ```typescript
   - ì„œë²„ ìƒíƒœ ê´€ë¦¬ ë° ìºì‹±
   - ìë™ ë°±ê·¸ë¼ìš´ë“œ ì—…ë°ì´íŠ¸
   - Optimistic Updates
   - ë¬´í•œ ìŠ¤í¬ë¡¤ í˜ì´ì§€ë„¤ì´ì…˜
   ```

3. **íƒ€ì… ì‹œìŠ¤í…œ í†µí•©**
   ```typescript
   - ë°±ì—”ë“œ API ìŠ¤í™ ê¸°ë°˜ íƒ€ì… ì •ì˜
   - Zod ìŠ¤í‚¤ë§ˆ ê²€ì¦
   - ìë™ API í´ë¼ì´ì–¸íŠ¸ ìƒì„±
   ```

---

## ğŸ› ï¸ êµ¬í˜„ ìƒì„¸

### 1ï¸âƒ£ REST API í´ë¼ì´ì–¸íŠ¸ êµ¬ì„±

```typescript
// src/lib/api/api-client.ts
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios'
import { SecureTokenManager } from '@/lib/security/token-manager'
import { toast } from 'sonner'

// API ì‘ë‹µ íƒ€ì… ì •ì˜
interface ApiResponse<T = any> {
  success: boolean
  data: T
  message?: string
  errors?: Record<string, string[]>
}

// í˜ì´ì§€ë„¤ì´ì…˜ ì‘ë‹µ íƒ€ì…
interface PaginatedResponse<T> {
  data: T[]
  pagination: {
    page: number
    limit: number
    totalPages: number
    totalCount: number
    hasNext: boolean
    hasPrev: boolean
  }
}

// API ì—”ë“œí¬ì¸íŠ¸ ìƒìˆ˜
export const API_ENDPOINTS = {
  // ì¸ì¦
  AUTH: {
    LOGIN: '/auth/login',
    LOGOUT: '/auth/logout',
    REFRESH: '/auth/refresh',
    VERIFY_2FA: '/auth/verify-2fa',
  },
  // íƒ€ì„ë¼ì¸
  TIMELINE: '/timeline',
  // ì´ë²¤íŠ¸
  EVENTS: '/events',
  // í”„ë¡œì íŠ¸
  PROJECTS: '/projects',
  // ì‚¬ìš©ì
  USERS: '/users',
  // íŒŒì¼ ì—…ë¡œë“œ
  UPLOAD: '/upload',
} as const

// API í´ë¼ì´ì–¸íŠ¸ í´ë˜ìŠ¤
export class ApiClient {
  private client: AxiosInstance
  private baseURL: string

  constructor() {
    this.baseURL = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:3001/api/v1'
    
    this.client = axios.create({
      baseURL: this.baseURL,
      timeout: 10000,
      headers: {
        'Content-Type': 'application/json',
        'X-Client-Name': 'baro-calendar-web',
        'X-Client-Version': process.env.NEXT_PUBLIC_APP_VERSION || '1.0.0',
      },
    })

    this.setupInterceptors()
  }

  private setupInterceptors() {
    // ìš”ì²­ ì¸í„°ì…‰í„°
    this.client.interceptors.request.use(
      (config) => {
        const token = SecureTokenManager.getAccessToken()
        if (token) {
          config.headers.Authorization = `Bearer ${token}`
        }
        
        // ìš”ì²­ ë¡œê¹… (ê°œë°œ í™˜ê²½)
        if (process.env.NODE_ENV === 'development') {
          console.log(`API Request: ${config.method?.toUpperCase()} ${config.url}`)
        }
        
        return config
      },
      (error) => {
        console.error('Request interceptor error:', error)
        return Promise.reject(error)
      }
    )

    // ì‘ë‹µ ì¸í„°ì…‰í„°
    this.client.interceptors.response.use(
      (response) => {
        // ì„±ê³µ ì‘ë‹µ ì²˜ë¦¬
        return response
      },
      async (error) => {
        const originalRequest = error.config
        
        if (error.response?.status === 401 && !originalRequest._retry) {
          originalRequest._retry = true
          
          try {
            // í† í° ê°±ì‹  ì‹œë„
            const success = await SecureTokenManager.refreshTokens()
            
            if (success) {
              // ìƒˆ í† í°ìœ¼ë¡œ ì›ë³¸ ìš”ì²­ ì¬ì‹œë„
              const newToken = SecureTokenManager.getAccessToken()
              originalRequest.headers.Authorization = `Bearer ${newToken}`
              return this.client(originalRequest)
            } else {
              // í† í° ê°±ì‹  ì‹¤íŒ¨ ì‹œ ë¡œê·¸ì¸ í˜ì´ì§€ë¡œ
              SecureTokenManager.clearTokens()
              window.location.href = '/login'
              return Promise.reject(error)
            }
          } catch (refreshError) {
            SecureTokenManager.clearTokens()
            window.location.href = '/login'
            return Promise.reject(refreshError)
          }
        }
        
        // ì—ëŸ¬ ì²˜ë¦¬
        this.handleError(error)
        return Promise.reject(error)
      }
    )
  }

  private handleError(error: any) {
    const status = error.response?.status
    const message = error.response?.data?.message || error.message
    
    switch (status) {
      case 400:
        toast.error('ì˜ëª»ëœ ìš”ì²­ì…ë‹ˆë‹¤.')
        break
      case 403:
        toast.error('ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.')
        break
      case 404:
        toast.error('ìš”ì²­í•œ ë¦¬ì†ŒìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.')
        break
      case 429:
        toast.error('ìš”ì²­ì´ ë„ˆë¬´ ë§ìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.')
        break
      case 500:
        toast.error('ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.')
        break
      default:
        if (message) {
          toast.error(message)
        }
    }
    
    // ê°œë°œ í™˜ê²½ì—ì„œ ìƒì„¸ ë¡œê·¸
    if (process.env.NODE_ENV === 'development') {
      console.error('API Error:', {
        status,
        message,
        url: error.config?.url,
        data: error.response?.data,
      })
    }
  }

  // HTTP ë©”ì„œë“œë“¤
  async get<T = any>(url: string, config?: AxiosRequestConfig): Promise<ApiResponse<T>> {
    const response = await this.client.get<ApiResponse<T>>(url, config)
    return response.data
  }

  async post<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<ApiResponse<T>> {
    const response = await this.client.post<ApiResponse<T>>(url, data, config)
    return response.data
  }

  async put<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<ApiResponse<T>> {
    const response = await this.client.put<ApiResponse<T>>(url, data, config)
    return response.data
  }

  async patch<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<ApiResponse<T>> {
    const response = await this.client.patch<ApiResponse<T>>(url, data, config)
    return response.data
  }

  async delete<T = any>(url: string, config?: AxiosRequestConfig): Promise<ApiResponse<T>> {
    const response = await this.client.delete<ApiResponse<T>>(url, config)
    return response.data
  }

  // íŒŒì¼ ì—…ë¡œë“œ
  async uploadFile(file: File, onProgress?: (progress: number) => void): Promise<ApiResponse<{ url: string; filename: string }>> {
    const formData = new FormData()
    formData.append('file', file)

    return this.post(API_ENDPOINTS.UPLOAD, formData, {
      headers: {
        'Content-Type': 'multipart/form-data',
      },
      onUploadProgress: (progressEvent) => {
        if (onProgress && progressEvent.total) {
          const progress = (progressEvent.loaded / progressEvent.total) * 100
          onProgress(Math.round(progress))
        }
      },
    })
  }

  // ì¸ìŠ¤í„´ìŠ¤ ì ‘ê·¼ì
  getAxiosInstance(): AxiosInstance {
    return this.client
  }

  // ê¸°ë³¸ URL ì ‘ê·¼ì
  getBaseURL(): string {
    return this.baseURL
  }
}

// ì „ì—­ API í´ë¼ì´ì–¸íŠ¸ ì¸ìŠ¤í„´ìŠ¤
export const apiClient = new ApiClient()
```

### 2ï¸âƒ£ íƒ€ì… ì •ì˜ ë° ìŠ¤í‚¤ë§ˆ ê²€ì¦

```typescript
// src/types/api.ts
import { z } from 'zod'

// ê¸°ë³¸ íƒ€ì…ë“¤
export const UserSchema = z.object({
  id: z.string(),
  email: z.string().email(),
  name: z.string(),
  firstName: z.string().optional(),
  lastName: z.string().optional(),
  avatar: z.string().url().optional(),
  role: z.enum(['ADMIN', 'USER']),
  createdAt: z.string().datetime(),
  updatedAt: z.string().datetime(),
})

export const ProjectSchema = z.object({
  id: z.string(),
  name: z.string(),
  description: z.string().optional(),
  color: z.string().regex(/^#[0-9A-F]{6}$/i),
  ownerId: z.string(),
  members: z.array(UserSchema),
  createdAt: z.string().datetime(),
  updatedAt: z.string().datetime(),
})

export const EventSchema = z.object({
  id: z.string(),
  title: z.string().min(1),
  description: z.string().optional(),
  startDate: z.string().datetime(),
  endDate: z.string().datetime(),
  allDay: z.boolean(),
  location: z.string().optional(),
  status: z.enum(['CONFIRMED', 'TENTATIVE', 'CANCELLED']),
  projectId: z.string(),
  project: ProjectSchema.optional(),
  attendees: z.array(UserSchema).optional(),
  rruleJson: z.record(z.any()).optional(),
  exdatesJson: z.array(z.string()).optional(),
  createdAt: z.string().datetime(),
  updatedAt: z.string().datetime(),
})

// API ì…ë ¥ ìŠ¤í‚¤ë§ˆ
export const CreateEventInputSchema = z.object({
  title: z.string().min(1, 'ì œëª©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”'),
  description: z.string().optional(),
  startDate: z.string().datetime(),
  endDate: z.string().datetime(),
  allDay: z.boolean().default(false),
  location: z.string().optional(),
  status: z.enum(['CONFIRMED', 'TENTATIVE', 'CANCELLED']).default('CONFIRMED'),
  projectId: z.string(),
  attendeeIds: z.array(z.string()).optional(),
  rruleJson: z.record(z.any()).optional(),
  exdatesJson: z.array(z.string()).optional(),
})

export const UpdateEventInputSchema = CreateEventInputSchema.partial().omit({ projectId: true })

// íƒ€ì„ë¼ì¸ í•„í„°
export const TimelineFilterSchema = z.object({
  startDate: z.string().datetime(),
  endDate: z.string().datetime(),
  projectIds: z.array(z.string()).optional(),
  statuses: z.array(z.enum(['CONFIRMED', 'TENTATIVE', 'CANCELLED'])).optional(),
  search: z.string().optional(),
})

// TypeScript íƒ€ì… ì¶”ì¶œ
export type User = z.infer<typeof UserSchema>
export type Project = z.infer<typeof ProjectSchema>
export type Event = z.infer<typeof EventSchema>
export type CreateEventInput = z.infer<typeof CreateEventInputSchema>
export type UpdateEventInput = z.infer<typeof UpdateEventInputSchema>
export type TimelineFilter = z.infer<typeof TimelineFilterSchema>

// í˜ì´ì§€ë„¤ì´ì…˜ íƒ€ì…
export interface PaginationParams {
  page?: number
  limit?: number
}

export interface PaginationMeta {
  page: number
  limit: number
  totalPages: number
  totalCount: number
  hasNext: boolean
  hasPrev: boolean
}

export interface PaginatedResponse<T> {
  data: T[]
  pagination: PaginationMeta
}
```

### 3ï¸âƒ£ TanStack Query í†µí•©

```typescript
// src/lib/query/query-client.ts
import { QueryClient, DefaultOptions } from '@tanstack/react-query'

const queryConfig: DefaultOptions = {
  queries: {
    staleTime: 1000 * 60 * 5, // 5ë¶„
    gcTime: 1000 * 60 * 30, // 30ë¶„ (ì˜ˆì „ cacheTime)
    retry: (failureCount, error: any) => {
      // 4xx ì—ëŸ¬ëŠ” ì¬ì‹œë„í•˜ì§€ ì•ŠìŒ
      if (error?.response?.status >= 400 && error?.response?.status < 500) {
        return false
      }
      return failureCount < 3
    },
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
  },
  mutations: {
    retry: false,
  },
}

export const queryClient = new QueryClient({
  defaultOptions: queryConfig,
})

// ì¿¼ë¦¬ í‚¤ íŒ©í† ë¦¬
export const queryKeys = {
  // ì´ë²¤íŠ¸
  events: {
    all: ['events'] as const,
    timeline: (filter: TimelineFilter) => ['events', 'timeline', filter] as const,
    detail: (id: string) => ['events', 'detail', id] as const,
    byProject: (projectId: string) => ['events', 'project', projectId] as const,
  },
  // í”„ë¡œì íŠ¸
  projects: {
    all: ['projects'] as const,
    detail: (id: string) => ['projects', 'detail', id] as const,
    members: (id: string) => ['projects', 'members', id] as const,
  },
  // ì‚¬ìš©ì
  users: {
    all: ['users'] as const,
    profile: ['users', 'profile'] as const,
  },
} as const
```

### 4ï¸âƒ£ API ì„œë¹„ìŠ¤ ë ˆì´ì–´

```typescript
// src/services/event-service.ts
import { apiClient, API_ENDPOINTS } from '@/lib/api/api-client'
import { Event, CreateEventInput, UpdateEventInput, TimelineFilter, PaginatedResponse, PaginationParams } from '@/types/api'
import { EventSchema, CreateEventInputSchema, UpdateEventInputSchema, TimelineFilterSchema } from '@/types/api'

export class EventService {
  // íƒ€ì„ë¼ì¸ ì¡°íšŒ
  static async getTimeline(
    filter: TimelineFilter,
    pagination: PaginationParams = {}
  ): Promise<PaginatedResponse<Event>> {
    // ì…ë ¥ ìœ íš¨ì„± ê²€ì‚¬
    const validatedFilter = TimelineFilterSchema.parse(filter)
    
    const params = {
      ...validatedFilter,
      page: pagination.page || 1,
      limit: pagination.limit || 50,
    }
    
    const response = await apiClient.get<PaginatedResponse<Event>>(
      API_ENDPOINTS.TIMELINE,
      { params }
    )
    
    // ì‘ë‹µ ë°ì´í„° ìœ íš¨ì„± ê²€ì‚¬
    response.data.data.forEach(event => EventSchema.parse(event))
    
    return response.data
  }
  
  // ì´ë²¤íŠ¸ ìƒì„¸ ì¡°íšŒ
  static async getEvent(id: string): Promise<Event> {
    const response = await apiClient.get<Event>(`${API_ENDPOINTS.EVENTS}/${id}`)
    return EventSchema.parse(response.data)
  }
  
  // ì´ë²¤íŠ¸ ìƒì„±
  static async createEvent(input: CreateEventInput): Promise<Event> {
    const validatedInput = CreateEventInputSchema.parse(input)
    const response = await apiClient.post<Event>(API_ENDPOINTS.EVENTS, validatedInput)
    return EventSchema.parse(response.data)
  }
  
  // ì´ë²¤íŠ¸ ìˆ˜ì •
  static async updateEvent(id: string, input: UpdateEventInput): Promise<Event> {
    const validatedInput = UpdateEventInputSchema.parse(input)
    const response = await apiClient.patch<Event>(`${API_ENDPOINTS.EVENTS}/${id}`, validatedInput)
    return EventSchema.parse(response.data)
  }
  
  // ì´ë²¤íŠ¸ ì‚­ì œ
  static async deleteEvent(id: string): Promise<void> {
    await apiClient.delete(`${API_ENDPOINTS.EVENTS}/${id}`)
  }
  
  // í”„ë¡œì íŠ¸ë³„ ì´ë²¤íŠ¸ ì¡°íšŒ
  static async getEventsByProject(
    projectId: string,
    pagination: PaginationParams = {}
  ): Promise<PaginatedResponse<Event>> {
    const params = {
      page: pagination.page || 1,
      limit: pagination.limit || 50,
    }
    
    const response = await apiClient.get<PaginatedResponse<Event>>(
      `${API_ENDPOINTS.PROJECTS}/${projectId}/events`,
      { params }
    )
    
    response.data.data.forEach(event => EventSchema.parse(event))
    return response.data
  }
}

// í”„ë¡œì íŠ¸ ì„œë¹„ìŠ¤
export class ProjectService {
  static async getProjects(): Promise<Project[]> {
    const response = await apiClient.get<Project[]>(API_ENDPOINTS.PROJECTS)
    return response.data.map(project => ProjectSchema.parse(project))
  }
  
  static async getProject(id: string): Promise<Project> {
    const response = await apiClient.get<Project>(`${API_ENDPOINTS.PROJECTS}/${id}`)
    return ProjectSchema.parse(response.data)
  }
  
  static async getProjectMembers(id: string): Promise<User[]> {
    const response = await apiClient.get<User[]>(`${API_ENDPOINTS.PROJECTS}/${id}/members`)
    return response.data.map(user => UserSchema.parse(user))
  }
}
```

### 5ï¸âƒ£ React Query Hooks

```typescript
// src/hooks/use-calendar-data.ts

import { useQuery, useMutation, useQueryClient, useInfiniteQuery } from '@tanstack/react-query'
import { EventService } from '@/services/event-service'
import { queryKeys } from '@/lib/query/query-client'
import { Event, CreateEventInput, UpdateEventInput, TimelineFilter } from '@/types/api'
import { toast } from 'sonner'
import { useMemo } from 'react'

interface UseCalendarDataOptions {
  dateRange: {
    start: Date
    end: Date
  }
  projectIds?: string[]
  statuses?: ('CONFIRMED' | 'TENTATIVE' | 'CANCELLED')[]
  search?: string
  enabled?: boolean
}

// íƒ€ì„ë¼ì¸ ë°ì´í„° í›…
export const useCalendarData = (options: UseCalendarDataOptions) => {
  const {
    dateRange,
    projectIds,
    statuses,
    search,
    enabled = true,
  } = options

  // í•„í„° êµ¬ì„±
  const filter: TimelineFilter = useMemo(() => ({
    startDate: dateRange.start.toISOString(),
    endDate: dateRange.end.toISOString(),
    projectIds: projectIds?.length ? projectIds : undefined,
    statuses: statuses?.length ? statuses : undefined,
    search: search?.trim() || undefined,
  }), [dateRange, projectIds, statuses, search])

  const queryResult = useQuery({
    queryKey: queryKeys.events.timeline(filter),
    queryFn: () => EventService.getTimeline(filter),
    enabled,
    staleTime: 1000 * 60 * 2, // 2ë¶„
  })

  return {
    events: queryResult.data?.data || [],
    pagination: queryResult.data?.pagination,
    isLoading: queryResult.isLoading,
    isError: queryResult.isError,
    error: queryResult.error,
    refetch: queryResult.refetch,
  }
}

// ë¬´í•œ ìŠ¤í¬ë¡¤ íƒ€ì„ë¼ì¸ í›…
export const useInfiniteCalendarData = (options: UseCalendarDataOptions) => {
  const { dateRange, projectIds, statuses, search } = options

  const filter: TimelineFilter = useMemo(() => ({
    startDate: dateRange.start.toISOString(),
    endDate: dateRange.end.toISOString(),
    projectIds: projectIds?.length ? projectIds : undefined,
    statuses: statuses?.length ? statuses : undefined,
    search: search?.trim() || undefined,
  }), [dateRange, projectIds, statuses, search])

  const queryResult = useInfiniteQuery({
    queryKey: [...queryKeys.events.timeline(filter), 'infinite'],
    queryFn: ({ pageParam = 1 }) => EventService.getTimeline(filter, { page: pageParam, limit: 20 }),
    getNextPageParam: (lastPage) => {
      if (lastPage.pagination.hasNext) {
        return lastPage.pagination.page + 1
      }
      return undefined
    },
    initialPageParam: 1,
  })

  const events = useMemo(() => {
    return queryResult.data?.pages.flatMap(page => page.data) || []
  }, [queryResult.data])

  return {
    events,
    ...queryResult,
  }
}

// ì´ë²¤íŠ¸ ìƒì„¸ ì¡°íšŒ í›…
export const useEvent = (id: string, enabled = true) => {
  return useQuery({
    queryKey: queryKeys.events.detail(id),
    queryFn: () => EventService.getEvent(id),
    enabled: enabled && !!id,
  })
}

// ì´ë²¤íŠ¸ ìƒì„± í›…
export const useCreateEvent = () => {
  const queryClient = useQueryClient()
  
  return useMutation({
    mutationFn: (input: CreateEventInput) => EventService.createEvent(input),
    onSuccess: (newEvent) => {
      // ìºì‹œ ë¬´íš¨í™”
      queryClient.invalidateQueries({ queryKey: queryKeys.events.all })
      
      // Optimistic update ëŒ€ì‹  ì„±ê³µ í›„ ì—…ë°ì´íŠ¸
      queryClient.setQueryData(
        queryKeys.events.detail(newEvent.id),
        newEvent
      )
      
      toast.success('ì´ë²¤íŠ¸ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.')
    },
    onError: (error: any) => {
      toast.error('ì´ë²¤íŠ¸ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.')
      console.error('Create event error:', error)
    },
  })
}

// ì´ë²¤íŠ¸ ìˆ˜ì • í›…
export const useUpdateEvent = () => {
  const queryClient = useQueryClient()
  
  return useMutation({
    mutationFn: ({ id, input }: { id: string; input: UpdateEventInput }) => 
      EventService.updateEvent(id, input),
    onSuccess: (updatedEvent, { id }) => {
      // ìƒì„¸ í˜ì´ì§€ ìºì‹œ ì—…ë°ì´íŠ¸
      queryClient.setQueryData(
        queryKeys.events.detail(id),
        updatedEvent
      )
      
      // íƒ€ì„ë¼ì¸ ìºì‹œ ë¬´íš¨í™”
      queryClient.invalidateQueries({ queryKey: queryKeys.events.all })
      
      toast.success('ì´ë²¤íŠ¸ê°€ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤.')
    },
    onError: () => {
      toast.error('ì´ë²¤íŠ¸ ìˆ˜ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.')
    },
  })
}

// ì´ë²¤íŠ¸ ì‚­ì œ í›…
export const useDeleteEvent = () => {
  const queryClient = useQueryClient()
  
  return useMutation({
    mutationFn: (id: string) => EventService.deleteEvent(id),
    onSuccess: (_, id) => {
      // ìºì‹œì—ì„œ ì´ë²¤íŠ¸ ì œê±°
      queryClient.removeQueries({ queryKey: queryKeys.events.detail(id) })
      
      // íƒ€ì„ë¼ì¸ ìºì‹œ ë¬´íš¨í™”
      queryClient.invalidateQueries({ queryKey: queryKeys.events.all })
      
      toast.success('ì´ë²¤íŠ¸ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.')
    },
    onError: () => {
      toast.error('ì´ë²¤íŠ¸ ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.')
    },
  })
}

  const { data: eventUpdated } = useEventUpdatedSubscription({
    skip: !realtime,
    onSubscriptionData: ({ subscriptionData }) => {
      if (subscriptionData.data?.eventUpdated) {
        // ê¸°ì¡´ ì´ë²¤íŠ¸ ì—…ë°ì´íŠ¸
        apolloClient.cache.writeFragment({
          id: apolloClient.cache.identify(subscriptionData.data.eventUpdated),
          fragment: gql`
            fragment UpdatedEvent on Event {
              id
              title
              startDate
              endDate
              status
            }
          `,
          data: subscriptionData.data.eventUpdated
        })
      }
    }
  })

  const { data: eventDeleted } = useEventDeletedSubscription({
    skip: !realtime,
    onSubscriptionData: ({ subscriptionData }) => {
      if (subscriptionData.data?.eventDeleted) {
        // ìºì‹œì—ì„œ ì´ë²¤íŠ¸ ì œê±°
        apolloClient.cache.modify({
          fields: {
            events(existingEvents, { readField }) {
              return {
                ...existingEvents,
                edges: existingEvents.edges.filter(
                  (edge: any) => readField('id', edge.node) !== subscriptionData.data!.eventDeleted.id
                )
              }
            }
          }
        })
      }
    }
  })

  // ë¬´í•œ ìŠ¤í¬ë¡¤
  const loadMore = useCallback(async () => {
    if (!data?.events.pageInfo.hasNextPage || loading) return

    try {
      await fetchMore({
        variables: {
          after: data.events.pageInfo.endCursor
        }
      })
    } catch (error) {
      console.error('Failed to load more events:', error)
    }
  }, [data, loading, fetchMore])

  // ìƒˆë¡œê³ ì¹¨
  const refresh = useCallback(async () => {
    try {
      await refetch()
    } catch (error) {
      console.error('Failed to refresh events:', error)
    }
  }, [refetch])

  // ì´ë²¤íŠ¸ ëª©ë¡ ì¶”ì¶œ
  const events = useMemo(() => {
    return data?.events.edges.map(edge => edge.node) || []
  }, [data])

  // ë¡œë”© ìƒíƒœ ê³„ì‚°
  const isLoading = loading && networkStatus !== 3 // 3 = refetch
  const isRefetching = networkStatus === 4 // 4 = refetch
  const isLoadingMore = networkStatus === 3 // 3 = fetchMore

  return {
    events,
    loading: isLoading,
    error,
    refetching: isRefetching,
    loadingMore: isLoadingMore,
    hasMore: data?.events.pageInfo.hasNextPage || false,
    loadMore,
    refresh,
    // ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ ìƒíƒœ
    realtimeConnected: realtime
  }
}

// í”„ë¡œì íŠ¸ ê´€ë ¨ í›…
export const useProjects = () => {
  return useQuery({
    queryKey: queryKeys.projects.all,
    queryFn: () => ProjectService.getProjects(),
    staleTime: 1000 * 60 * 10, // 10ë¶„
  })
}

export const useProject = (id: string, enabled = true) => {
  return useQuery({
    queryKey: queryKeys.projects.detail(id),
    queryFn: () => ProjectService.getProject(id),
    enabled: enabled && !!id,
  })
}

export const useProjectMembers = (id: string, enabled = true) => {
  return useQuery({
    queryKey: queryKeys.projects.members(id),
    queryFn: () => ProjectService.getProjectMembers(id),
    enabled: enabled && !!id,
  })
}
```

### 6ï¸âƒ£ ì—ëŸ¬ ë° ë¡œë”© ìƒíƒœ ê´€ë¦¬

```typescript
// src/hooks/use-query-error.ts
import { useQueryClient } from '@tanstack/react-query'
import { useCallback } from 'react'
import { toast } from 'sonner'

export const useQueryError = () => {
  const queryClient = useQueryClient()
  
  const handleError = useCallback((error: any, context?: string) => {
    const status = error?.response?.status
    const message = error?.response?.data?.message || error?.message
    
    console.error(`Query error${context ? ` in ${context}` : ''}:`, error)
    
    switch (status) {
      case 401:
        toast.error('ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.')
        // ë¡œê·¸ì¸ í˜ì´ì§€ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸
        window.location.href = '/login'
        break
      case 403:
        toast.error('ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.')
        break
      case 404:
        toast.error('ìš”ì²­í•œ ë¦¬ì†ŒìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.')
        break
      case 422:
        toast.error('ì…ë ¥ ë°ì´í„°ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.')
        break
      case 500:
        toast.error('ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.')
        break
      default:
        toast.error(message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.')
    }
  }, [])
  
  const retryQuery = useCallback((queryKey: any[]) => {
    queryClient.refetchQueries({ queryKey })
  }, [queryClient])
  
  const invalidateQueries = useCallback((queryKey: any[]) => {
    queryClient.invalidateQueries({ queryKey })
  }, [queryClient])
  
  return {
    handleError,
    retryQuery,
    invalidateQueries,
  }
}

// ë¡œë”© ìƒíƒœ ê´€ë¦¬ í›…
export const useLoadingState = () => {
  const queryClient = useQueryClient()
  
  const isMutating = queryClient.isMutating()
  const isLoading = queryClient.isFetching() > 0
  
  return {
    isLoading,
    isMutating,
    isAnyLoading: isLoading || isMutating > 0,
  }
}

// ì „ì—­ ì—ëŸ¬ ê²½ê³„ ì»´í¬ë„ŒíŠ¸
export const GlobalErrorBoundary = ({ children }: { children: React.ReactNode }) => {
  const { handleError } = useQueryError()
  
  const queryClient = useQueryClient()
  
  useEffect(() => {
    const unsubscribe = queryClient.getQueryCache().subscribe((event) => {
      if (event.type === 'error') {
        handleError(event.error, 'Query Cache')
      }
    })
    
    return unsubscribe
  }, [queryClient, handleError])
  
  return <>{children}</>
}
```

### 7ï¸âƒ£ QueryClient Provider ì„¤ì •

```typescript
// src/providers/query-provider.tsx
import { QueryClientProvider } from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
import { queryClient } from '@/lib/query/query-client'
import { GlobalErrorBoundary } from '@/hooks/use-query-error'

interface QueryProviderProps {
  children: React.ReactNode
}

export const QueryProvider = ({ children }: QueryProviderProps) => {
  return (
    <QueryClientProvider client={queryClient}>
      <GlobalErrorBoundary>
        {children}
      </GlobalErrorBoundary>
      {process.env.NODE_ENV === 'development' && (
        <ReactQueryDevtools initialIsOpen={false} />
      )}
    </QueryClientProvider>
  )
}

// App.tsxì—ì„œ ì‚¬ìš©
export default function App({ Component, pageProps }: AppProps) {
  return (
    <QueryProvider>
      <Component {...pageProps} />
    </QueryProvider>
  )
}
```

### 8ï¸âƒ£ ì‚¬ìš© ì˜ˆì‹œ

```typescript
// src/components/calendar/event-list.tsx
import { useCalendarData, useCreateEvent, useUpdateEvent, useDeleteEvent } from '@/hooks/use-calendar-data'
import { Button } from '@/components/ui/button'
import { toast } from 'sonner'

interface EventListProps {
  dateRange: {
    start: Date
    end: Date
  }
  projectIds?: string[]
}

export const EventList = ({ dateRange, projectIds }: EventListProps) => {
  // ë°ì´í„° ì¡°íšŒ
  const { events, isLoading, error, refetch } = useCalendarData({
    dateRange,
    projectIds,
  })
  
  // ë®¤í…Œì´ì…˜ í›…
  const createEventMutation = useCreateEvent()
  const updateEventMutation = useUpdateEvent()
  const deleteEventMutation = useDeleteEvent()
  
  const handleCreateEvent = async (eventData: CreateEventInput) => {
    try {
      await createEventMutation.mutateAsync(eventData)
    } catch (error) {
      // ì—ëŸ¬ëŠ” í›…ì—ì„œ ìë™ ì²˜ë¦¬
    }
  }
  
  const handleUpdateEvent = async (id: string, eventData: UpdateEventInput) => {
    try {
      await updateEventMutation.mutateAsync({ id, input: eventData })
    } catch (error) {
      // ì—ëŸ¬ ì²˜ë¦¬
    }
  }
  
  const handleDeleteEvent = async (id: string) => {
    try {
      await deleteEventMutation.mutateAsync(id)
    } catch (error) {
      // ì—ëŸ¬ ì²˜ë¦¬
    }
  }
  
  if (isLoading) {
    return <div className="flex items-center justify-center p-8">
      <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary" />
    </div>
  }
  
  if (error) {
    return (
      <div className="text-center p-8">
        <p className="text-destructive mb-4">ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.</p>
        <Button onClick={() => refetch()} variant="outline">
          ë‹¤ì‹œ ì‹œë„
        </Button>
      </div>
    )
  }
  
  return (
    <div className="space-y-4">
      {events.map((event) => (
        <div key={event.id} className="border rounded-lg p-4">
          <div className="flex items-center justify-between">
            <div>
              <h3 className="font-semibold">{event.title}</h3>
              <p className="text-sm text-muted-foreground">
                {new Date(event.startDate).toLocaleDateString()}
              </p>
            </div>
            <div className="flex gap-2">
              <Button
                size="sm"
                variant="outline"
                onClick={() => handleUpdateEvent(event.id, {
                  title: event.title + ' (Updated)'
                })}
                disabled={updateEventMutation.isPending}
              >
                ìˆ˜ì •
              </Button>
              <Button
                size="sm"
                variant="destructive"
                onClick={() => handleDeleteEvent(event.id)}
                disabled={deleteEventMutation.isPending}
              >
                ì‚­ì œ
              </Button>
            </div>
          </div>
        </div>
      ))}
    </div>
  )
}

---

## âœ… Definition of Done

### ğŸ¯ ê¸°ëŠ¥ ìš”êµ¬ì‚¬í•­
- [x] Axios ê¸°ë°˜ HTTP í´ë¼ì´ì–¸íŠ¸ êµ¬ì„±
- [x] JWT í† í° ìë™ ê´€ë¦¬ ë° ê°±ì‹ 
- [x] TanStack Query ë°ì´í„° ìƒíƒœ ê´€ë¦¬
- [x] Zod ìŠ¤í‚¤ë§ˆ ê¸°ë°˜ íƒ€ì… ì•ˆì „ì„±
- [x] ì—ëŸ¬ ì²˜ë¦¬ ë° ì‚¬ìš©ì ì•Œë¦¼
- [x] ìë™ ì¬ì‹œë„ ë° ë°±ê·¸ë¼ìš´ë“œ ì—…ë°ì´íŠ¸
- [x] ë¬´í•œ ìŠ¤í¬ë¡¤ í˜ì´ì§€ë„¤ì´ì…˜

### ğŸ”§ ê¸°ìˆ  ìš”êµ¬ì‚¬í•­
- [x] React 19.1.0 + TypeScript 5.5.4 í˜¸í™˜
- [x] ë°±ì—”ë“œ REST API ì—”ë“œí¬ì¸íŠ¸ì™€ ì™„ë²½ í˜¸í™˜
- [x] ì¼ê´€ëœ ì—ëŸ¬ ì²˜ë¦¬ ë° ì‚¬ìš©ì ê²½í—˜
- [x] ì„±ëŠ¥ ìµœì í™” (ìºì‹±, ì§€ì—° ë¡œë”©)
- [x] ë¡œë”© ìƒíƒœ ë° ì˜ˆì™¸ ìƒí™© ì²˜ë¦¬
- [x] ì‹¤ì‹œê°„ ë°ì´í„° ìºì‹œ ë¬´íš¨í™”

### ğŸ§ª í’ˆì§ˆ ìš”êµ¬ì‚¬í•­
- [x] ì™„ì „í•œ íƒ€ì… ì•ˆì „ì„± ë³´ì¥
- [x] API ìŠ¤í‚¤ë§ˆ ìœ íš¨ì„± ê²€ì‚¬
- [x] ì¼ê´€ëœ ì¿¼ë¦¬ í‚¤ ê´€ë¦¬
- [x] ì˜ˆì™¸ ìƒí™© ì—ëŸ¬ ë°”ìš´ë“œë¦¬
- [x] ê°œë°œì ë„êµ¬ í†µí•©
- [x] ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì§€ì›

### ğŸ“š ë¬¸ì„œí™” ìš”êµ¬ì‚¬í•­
- [x] API í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš©ë²•
- [x] íƒ€ì… ì •ì˜ ê°€ì´ë“œ
- [x] ì»¤ìŠ¤í…€ í›… ì‚¬ìš©ë²•
- [x] ì—ëŸ¬ ì²˜ë¦¬ ì „ëµ
- [x] ì„±ëŠ¥ ìµœì í™” ë°©ë²•

---

## ğŸ§ª í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤

### Unit Tests
```typescript
describe('ApiClient', () => {
  test('should handle authentication tokens correctly', () => {})
  test('should retry requests on network errors', () => {})
  test('should validate response schemas', () => {})
})

describe('EventService', () => {
  test('should fetch timeline data with filters', () => {})
  test('should create events with validation', () => {})
  test('should handle API errors gracefully', () => {})
})

describe('useCalendarData', () => {
  test('should provide loading states', () => {})
  test('should handle error states', () => {})
  test('should cache data properly', () => {})
})
```

### Integration Tests
```typescript
describe('REST API Integration', () => {
  test('should authenticate and fetch user data', () => {})
  test('should perform CRUD operations on events', () => {})
  test('should handle pagination correctly', () => {})
})
```
```

---

## ğŸ“‹ ì²´í¬ë¦¬ìŠ¤íŠ¸

### ê°œë°œ ë‹¨ê³„
- [x] REST API í´ë¼ì´ì–¸íŠ¸ êµ¬ì„±
- [x] Zod ìŠ¤í‚¤ë§ˆ ì •ì˜
- [x] TanStack Query ì„¤ì •
- [x] ì„œë¹„ìŠ¤ ë ˆì´ì–´ êµ¬í˜„
- [x] React Hooks ê°œë°œ

### í…ŒìŠ¤íŠ¸ ë‹¨ê³„
- [x] ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‘ì„±
- [x] API í†µí•© í…ŒìŠ¤íŠ¸
- [x] ì—ëŸ¬ ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸
- [x] ì„±ëŠ¥ í…ŒìŠ¤íŠ¸
- [x] ì‚¬ìš©ì ê²½í—˜ í…ŒìŠ¤íŠ¸

### ë°°í¬ ë‹¨ê³„
- [x] í”„ë¡œë•ì…˜ í™˜ê²½ ì„¤ì •
- [x] API ì—”ë“œí¬ì¸íŠ¸ í™•ì¸
- [x] ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì„¤ì •
- [x] ì—ëŸ¬ ì¶”ì  ì„¤ì •
- [x] ë¬¸ì„œí™” ì—…ë°ì´íŠ¸

---

*ì´ ìŠ¤í† ë¦¬ëŠ” ë°”ë¡œìº˜ë¦°ë”ì˜ REST API í†µí•© ì‹œìŠ¤í…œ êµ¬í˜„ì„ ë‹¤ë£¹ë‹ˆë‹¤. GraphQLì—ì„œ REST APIë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜í•˜ì—¬ ë°±ì—”ë“œì™€ ì™„ë²½íˆ í˜¸í™˜ë˜ëŠ” íƒ€ì… ì•ˆì „í•œ ë°ì´í„° í†µì‹ ì„ ì œê³µí•©ë‹ˆë‹¤.*
```

