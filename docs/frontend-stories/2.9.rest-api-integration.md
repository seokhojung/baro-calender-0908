# Story 2.9: REST API 통합 시스템

## Status
Ready for Development

## Priority & Dependencies
- **Priority**: P0 (Critical)
- **Story Points**: 8
- **Dependencies**: [1.1c, 1.7]
- **Blocked By**: None

## Success Metrics
- **Business KPI**: 
  - API 응답 시간 200ms 이내
  - 데이터 동기화 오류율 0.1% 이하
  - 실시간 업데이트 지연 100ms 이내
- **Technical KPI**:
  - GraphQL 쿠리 캐시 히트율 85% 이상
  - 타입 안전성 100% (컴파일 오류 0개)
  - Subscription 연결 안정성 99% 이상
- **Definition of Success**: 완전한 GraphQL 통합, 실시간 데이터 동기화

## Risks & Mitigations
- **Technical Risks**: 
  - Risk: GraphQL 스키마 변경 시 타입 충돌
  - Impact: High
  - Mitigation: 자동 코드 생성, 스키마 버저닝
- **Schedule Risks**:
  - Risk: Subscription 복잡도
  - Impact: Medium
  - Mitigation: 단계적 구현, 폴링 전략

---

## 🎯 Story 개요

바로캘린더의 **완전한 REST API 통합 시스템**을 구현하여 백엔드 API와 완벽히 호환되는 타입 안전한 데이터 통신을 제공합니다.

**⚠️ 중요한 변경사항**: GraphQL에서 REST API로 마이그레이션하여 백엔드 API 스펙과 완벽 호환

---

## 🎬 사용자 스토리

### 📝 주요 사용자 스토리

**As a** 바로캘린더 개발자  
**I want** 백엔드 REST API와 완벽히 호환되는 타입 안전한 API 클라이언트를 사용하고 싶어  
**So that** 신뢰할 수 있고 일관된 데이터 통신이 가능해

### 🔍 상세 사용자 요구사항

1. **백엔드 API 호환성**
   - `/api/v1/timeline`, `/api/v1/events` 등 실제 엔드포인트와 정확히 일치
   - JWT 토큰 기반 인증 시스템
   - 프로젝트별 권한 관리 지원

2. **타입 안전성 및 개발 경험**
   - TypeScript 기반 API 클라이언트
   - 자동완성 및 타입 검증
   - 일관된 에러 처리

3. **성능 및 사용성**
   - TanStack Query 기반 캐싱
   - 자동 재시도 및 백그라운드 업데이트
   - 오프라인 지원 및 동기화

---

## ⚙️ 기술적 요구사항

### 🏗️ 아키텍처 요구사항

1. **REST API 클라이언트 구성**
   ```typescript
   - Axios 기반 HTTP 클라이언트
   - JWT 토큰 자동 관리
   - 요청/응답 인터셉터
   - 타입 안전한 API 호출
   ```

2. **TanStack Query 통합**
   ```typescript
   - 서버 상태 관리 및 캐싱
   - 자동 백그라운드 업데이트
   - Optimistic Updates
   - 무한 스크롤 페이지네이션
   ```

3. **타입 시스템 통합**
   ```typescript
   - 백엔드 API 스펙 기반 타입 정의
   - Zod 스키마 검증
   - 자동 API 클라이언트 생성
   ```

---

## 🛠️ 구현 상세

### 1️⃣ REST API 클라이언트 구성

```typescript
// src/lib/api/api-client.ts
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios'
import { SecureTokenManager } from '@/lib/security/token-manager'
import { toast } from 'sonner'

// API 응답 타입 정의
interface ApiResponse<T = any> {
  success: boolean
  data: T
  message?: string
  errors?: Record<string, string[]>
}

// 페이지네이션 응답 타입
interface PaginatedResponse<T> {
  data: T[]
  pagination: {
    page: number
    limit: number
    totalPages: number
    totalCount: number
    hasNext: boolean
    hasPrev: boolean
  }
}

// API 엔드포인트 상수
export const API_ENDPOINTS = {
  // 인증
  AUTH: {
    LOGIN: '/auth/login',
    LOGOUT: '/auth/logout',
    REFRESH: '/auth/refresh',
    VERIFY_2FA: '/auth/verify-2fa',
  },
  // 타임라인
  TIMELINE: '/timeline',
  // 이벤트
  EVENTS: '/events',
  // 프로젝트
  PROJECTS: '/projects',
  // 사용자
  USERS: '/users',
  // 파일 업로드
  UPLOAD: '/upload',
} as const

// API 클라이언트 클래스
export class ApiClient {
  private client: AxiosInstance
  private baseURL: string

  constructor() {
    this.baseURL = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:3001/api/v1'
    
    this.client = axios.create({
      baseURL: this.baseURL,
      timeout: 10000,
      headers: {
        'Content-Type': 'application/json',
        'X-Client-Name': 'baro-calendar-web',
        'X-Client-Version': process.env.NEXT_PUBLIC_APP_VERSION || '1.0.0',
      },
    })

    this.setupInterceptors()
  }

  private setupInterceptors() {
    // 요청 인터셉터
    this.client.interceptors.request.use(
      (config) => {
        const token = SecureTokenManager.getAccessToken()
        if (token) {
          config.headers.Authorization = `Bearer ${token}`
        }
        
        // 요청 로깅 (개발 환경)
        if (process.env.NODE_ENV === 'development') {
          console.log(`API Request: ${config.method?.toUpperCase()} ${config.url}`)
        }
        
        return config
      },
      (error) => {
        console.error('Request interceptor error:', error)
        return Promise.reject(error)
      }
    )

    // 응답 인터셉터
    this.client.interceptors.response.use(
      (response) => {
        // 성공 응답 처리
        return response
      },
      async (error) => {
        const originalRequest = error.config
        
        if (error.response?.status === 401 && !originalRequest._retry) {
          originalRequest._retry = true
          
          try {
            // 토큰 갱신 시도
            const success = await SecureTokenManager.refreshTokens()
            
            if (success) {
              // 새 토큰으로 원본 요청 재시도
              const newToken = SecureTokenManager.getAccessToken()
              originalRequest.headers.Authorization = `Bearer ${newToken}`
              return this.client(originalRequest)
            } else {
              // 토큰 갱신 실패 시 로그인 페이지로
              SecureTokenManager.clearTokens()
              window.location.href = '/login'
              return Promise.reject(error)
            }
          } catch (refreshError) {
            SecureTokenManager.clearTokens()
            window.location.href = '/login'
            return Promise.reject(refreshError)
          }
        }
        
        // 에러 처리
        this.handleError(error)
        return Promise.reject(error)
      }
    )
  }

  private handleError(error: any) {
    const status = error.response?.status
    const message = error.response?.data?.message || error.message
    
    switch (status) {
      case 400:
        toast.error('잘못된 요청입니다.')
        break
      case 403:
        toast.error('권한이 없습니다.')
        break
      case 404:
        toast.error('요청한 리소스를 찾을 수 없습니다.')
        break
      case 429:
        toast.error('요청이 너무 많습니다. 잠시 후 다시 시도해주세요.')
        break
      case 500:
        toast.error('서버 오류가 발생했습니다.')
        break
      default:
        if (message) {
          toast.error(message)
        }
    }
    
    // 개발 환경에서 상세 로그
    if (process.env.NODE_ENV === 'development') {
      console.error('API Error:', {
        status,
        message,
        url: error.config?.url,
        data: error.response?.data,
      })
    }
  }

  // HTTP 메서드들
  async get<T = any>(url: string, config?: AxiosRequestConfig): Promise<ApiResponse<T>> {
    const response = await this.client.get<ApiResponse<T>>(url, config)
    return response.data
  }

  async post<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<ApiResponse<T>> {
    const response = await this.client.post<ApiResponse<T>>(url, data, config)
    return response.data
  }

  async put<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<ApiResponse<T>> {
    const response = await this.client.put<ApiResponse<T>>(url, data, config)
    return response.data
  }

  async patch<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<ApiResponse<T>> {
    const response = await this.client.patch<ApiResponse<T>>(url, data, config)
    return response.data
  }

  async delete<T = any>(url: string, config?: AxiosRequestConfig): Promise<ApiResponse<T>> {
    const response = await this.client.delete<ApiResponse<T>>(url, config)
    return response.data
  }

  // 파일 업로드
  async uploadFile(file: File, onProgress?: (progress: number) => void): Promise<ApiResponse<{ url: string; filename: string }>> {
    const formData = new FormData()
    formData.append('file', file)

    return this.post(API_ENDPOINTS.UPLOAD, formData, {
      headers: {
        'Content-Type': 'multipart/form-data',
      },
      onUploadProgress: (progressEvent) => {
        if (onProgress && progressEvent.total) {
          const progress = (progressEvent.loaded / progressEvent.total) * 100
          onProgress(Math.round(progress))
        }
      },
    })
  }

  // 인스턴스 접근자
  getAxiosInstance(): AxiosInstance {
    return this.client
  }

  // 기본 URL 접근자
  getBaseURL(): string {
    return this.baseURL
  }
}

// 전역 API 클라이언트 인스턴스
export const apiClient = new ApiClient()
```

### 2️⃣ 타입 정의 및 스키마 검증

```typescript
// src/types/api.ts
import { z } from 'zod'

// 기본 타입들
export const UserSchema = z.object({
  id: z.string(),
  email: z.string().email(),
  name: z.string(),
  firstName: z.string().optional(),
  lastName: z.string().optional(),
  avatar: z.string().url().optional(),
  role: z.enum(['ADMIN', 'USER']),
  createdAt: z.string().datetime(),
  updatedAt: z.string().datetime(),
})

export const ProjectSchema = z.object({
  id: z.string(),
  name: z.string(),
  description: z.string().optional(),
  color: z.string().regex(/^#[0-9A-F]{6}$/i),
  ownerId: z.string(),
  members: z.array(UserSchema),
  createdAt: z.string().datetime(),
  updatedAt: z.string().datetime(),
})

export const EventSchema = z.object({
  id: z.string(),
  title: z.string().min(1),
  description: z.string().optional(),
  startDate: z.string().datetime(),
  endDate: z.string().datetime(),
  allDay: z.boolean(),
  location: z.string().optional(),
  status: z.enum(['CONFIRMED', 'TENTATIVE', 'CANCELLED']),
  projectId: z.string(),
  project: ProjectSchema.optional(),
  attendees: z.array(UserSchema).optional(),
  rruleJson: z.record(z.any()).optional(),
  exdatesJson: z.array(z.string()).optional(),
  createdAt: z.string().datetime(),
  updatedAt: z.string().datetime(),
})

// API 입력 스키마
export const CreateEventInputSchema = z.object({
  title: z.string().min(1, '제목을 입력해주세요'),
  description: z.string().optional(),
  startDate: z.string().datetime(),
  endDate: z.string().datetime(),
  allDay: z.boolean().default(false),
  location: z.string().optional(),
  status: z.enum(['CONFIRMED', 'TENTATIVE', 'CANCELLED']).default('CONFIRMED'),
  projectId: z.string(),
  attendeeIds: z.array(z.string()).optional(),
  rruleJson: z.record(z.any()).optional(),
  exdatesJson: z.array(z.string()).optional(),
})

export const UpdateEventInputSchema = CreateEventInputSchema.partial().omit({ projectId: true })

// 타임라인 필터
export const TimelineFilterSchema = z.object({
  startDate: z.string().datetime(),
  endDate: z.string().datetime(),
  projectIds: z.array(z.string()).optional(),
  statuses: z.array(z.enum(['CONFIRMED', 'TENTATIVE', 'CANCELLED'])).optional(),
  search: z.string().optional(),
})

// TypeScript 타입 추출
export type User = z.infer<typeof UserSchema>
export type Project = z.infer<typeof ProjectSchema>
export type Event = z.infer<typeof EventSchema>
export type CreateEventInput = z.infer<typeof CreateEventInputSchema>
export type UpdateEventInput = z.infer<typeof UpdateEventInputSchema>
export type TimelineFilter = z.infer<typeof TimelineFilterSchema>

// 페이지네이션 타입
export interface PaginationParams {
  page?: number
  limit?: number
}

export interface PaginationMeta {
  page: number
  limit: number
  totalPages: number
  totalCount: number
  hasNext: boolean
  hasPrev: boolean
}

export interface PaginatedResponse<T> {
  data: T[]
  pagination: PaginationMeta
}
```

### 3️⃣ TanStack Query 통합

```typescript
// src/lib/query/query-client.ts
import { QueryClient, DefaultOptions } from '@tanstack/react-query'

const queryConfig: DefaultOptions = {
  queries: {
    staleTime: 1000 * 60 * 5, // 5분
    gcTime: 1000 * 60 * 30, // 30분 (예전 cacheTime)
    retry: (failureCount, error: any) => {
      // 4xx 에러는 재시도하지 않음
      if (error?.response?.status >= 400 && error?.response?.status < 500) {
        return false
      }
      return failureCount < 3
    },
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
  },
  mutations: {
    retry: false,
  },
}

export const queryClient = new QueryClient({
  defaultOptions: queryConfig,
})

// 쿼리 키 팩토리
export const queryKeys = {
  // 이벤트
  events: {
    all: ['events'] as const,
    timeline: (filter: TimelineFilter) => ['events', 'timeline', filter] as const,
    detail: (id: string) => ['events', 'detail', id] as const,
    byProject: (projectId: string) => ['events', 'project', projectId] as const,
  },
  // 프로젝트
  projects: {
    all: ['projects'] as const,
    detail: (id: string) => ['projects', 'detail', id] as const,
    members: (id: string) => ['projects', 'members', id] as const,
  },
  // 사용자
  users: {
    all: ['users'] as const,
    profile: ['users', 'profile'] as const,
  },
} as const
```

### 4️⃣ API 서비스 레이어

```typescript
// src/services/event-service.ts
import { apiClient, API_ENDPOINTS } from '@/lib/api/api-client'
import { Event, CreateEventInput, UpdateEventInput, TimelineFilter, PaginatedResponse, PaginationParams } from '@/types/api'
import { EventSchema, CreateEventInputSchema, UpdateEventInputSchema, TimelineFilterSchema } from '@/types/api'

export class EventService {
  // 타임라인 조회
  static async getTimeline(
    filter: TimelineFilter,
    pagination: PaginationParams = {}
  ): Promise<PaginatedResponse<Event>> {
    // 입력 유효성 검사
    const validatedFilter = TimelineFilterSchema.parse(filter)
    
    const params = {
      ...validatedFilter,
      page: pagination.page || 1,
      limit: pagination.limit || 50,
    }
    
    const response = await apiClient.get<PaginatedResponse<Event>>(
      API_ENDPOINTS.TIMELINE,
      { params }
    )
    
    // 응답 데이터 유효성 검사
    response.data.data.forEach(event => EventSchema.parse(event))
    
    return response.data
  }
  
  // 이벤트 상세 조회
  static async getEvent(id: string): Promise<Event> {
    const response = await apiClient.get<Event>(`${API_ENDPOINTS.EVENTS}/${id}`)
    return EventSchema.parse(response.data)
  }
  
  // 이벤트 생성
  static async createEvent(input: CreateEventInput): Promise<Event> {
    const validatedInput = CreateEventInputSchema.parse(input)
    const response = await apiClient.post<Event>(API_ENDPOINTS.EVENTS, validatedInput)
    return EventSchema.parse(response.data)
  }
  
  // 이벤트 수정
  static async updateEvent(id: string, input: UpdateEventInput): Promise<Event> {
    const validatedInput = UpdateEventInputSchema.parse(input)
    const response = await apiClient.patch<Event>(`${API_ENDPOINTS.EVENTS}/${id}`, validatedInput)
    return EventSchema.parse(response.data)
  }
  
  // 이벤트 삭제
  static async deleteEvent(id: string): Promise<void> {
    await apiClient.delete(`${API_ENDPOINTS.EVENTS}/${id}`)
  }
  
  // 프로젝트별 이벤트 조회
  static async getEventsByProject(
    projectId: string,
    pagination: PaginationParams = {}
  ): Promise<PaginatedResponse<Event>> {
    const params = {
      page: pagination.page || 1,
      limit: pagination.limit || 50,
    }
    
    const response = await apiClient.get<PaginatedResponse<Event>>(
      `${API_ENDPOINTS.PROJECTS}/${projectId}/events`,
      { params }
    )
    
    response.data.data.forEach(event => EventSchema.parse(event))
    return response.data
  }
}

// 프로젝트 서비스
export class ProjectService {
  static async getProjects(): Promise<Project[]> {
    const response = await apiClient.get<Project[]>(API_ENDPOINTS.PROJECTS)
    return response.data.map(project => ProjectSchema.parse(project))
  }
  
  static async getProject(id: string): Promise<Project> {
    const response = await apiClient.get<Project>(`${API_ENDPOINTS.PROJECTS}/${id}`)
    return ProjectSchema.parse(response.data)
  }
  
  static async getProjectMembers(id: string): Promise<User[]> {
    const response = await apiClient.get<User[]>(`${API_ENDPOINTS.PROJECTS}/${id}/members`)
    return response.data.map(user => UserSchema.parse(user))
  }
}
```

### 5️⃣ React Query Hooks

```typescript
// src/hooks/use-calendar-data.ts

import { useQuery, useMutation, useQueryClient, useInfiniteQuery } from '@tanstack/react-query'
import { EventService } from '@/services/event-service'
import { queryKeys } from '@/lib/query/query-client'
import { Event, CreateEventInput, UpdateEventInput, TimelineFilter } from '@/types/api'
import { toast } from 'sonner'
import { useMemo } from 'react'

interface UseCalendarDataOptions {
  dateRange: {
    start: Date
    end: Date
  }
  projectIds?: string[]
  statuses?: ('CONFIRMED' | 'TENTATIVE' | 'CANCELLED')[]
  search?: string
  enabled?: boolean
}

// 타임라인 데이터 훅
export const useCalendarData = (options: UseCalendarDataOptions) => {
  const {
    dateRange,
    projectIds,
    statuses,
    search,
    enabled = true,
  } = options

  // 필터 구성
  const filter: TimelineFilter = useMemo(() => ({
    startDate: dateRange.start.toISOString(),
    endDate: dateRange.end.toISOString(),
    projectIds: projectIds?.length ? projectIds : undefined,
    statuses: statuses?.length ? statuses : undefined,
    search: search?.trim() || undefined,
  }), [dateRange, projectIds, statuses, search])

  const queryResult = useQuery({
    queryKey: queryKeys.events.timeline(filter),
    queryFn: () => EventService.getTimeline(filter),
    enabled,
    staleTime: 1000 * 60 * 2, // 2분
  })

  return {
    events: queryResult.data?.data || [],
    pagination: queryResult.data?.pagination,
    isLoading: queryResult.isLoading,
    isError: queryResult.isError,
    error: queryResult.error,
    refetch: queryResult.refetch,
  }
}

// 무한 스크롤 타임라인 훅
export const useInfiniteCalendarData = (options: UseCalendarDataOptions) => {
  const { dateRange, projectIds, statuses, search } = options

  const filter: TimelineFilter = useMemo(() => ({
    startDate: dateRange.start.toISOString(),
    endDate: dateRange.end.toISOString(),
    projectIds: projectIds?.length ? projectIds : undefined,
    statuses: statuses?.length ? statuses : undefined,
    search: search?.trim() || undefined,
  }), [dateRange, projectIds, statuses, search])

  const queryResult = useInfiniteQuery({
    queryKey: [...queryKeys.events.timeline(filter), 'infinite'],
    queryFn: ({ pageParam = 1 }) => EventService.getTimeline(filter, { page: pageParam, limit: 20 }),
    getNextPageParam: (lastPage) => {
      if (lastPage.pagination.hasNext) {
        return lastPage.pagination.page + 1
      }
      return undefined
    },
    initialPageParam: 1,
  })

  const events = useMemo(() => {
    return queryResult.data?.pages.flatMap(page => page.data) || []
  }, [queryResult.data])

  return {
    events,
    ...queryResult,
  }
}

// 이벤트 상세 조회 훅
export const useEvent = (id: string, enabled = true) => {
  return useQuery({
    queryKey: queryKeys.events.detail(id),
    queryFn: () => EventService.getEvent(id),
    enabled: enabled && !!id,
  })
}

// 이벤트 생성 훅
export const useCreateEvent = () => {
  const queryClient = useQueryClient()
  
  return useMutation({
    mutationFn: (input: CreateEventInput) => EventService.createEvent(input),
    onSuccess: (newEvent) => {
      // 캐시 무효화
      queryClient.invalidateQueries({ queryKey: queryKeys.events.all })
      
      // Optimistic update 대신 성공 후 업데이트
      queryClient.setQueryData(
        queryKeys.events.detail(newEvent.id),
        newEvent
      )
      
      toast.success('이벤트가 생성되었습니다.')
    },
    onError: (error: any) => {
      toast.error('이벤트 생성에 실패했습니다.')
      console.error('Create event error:', error)
    },
  })
}

// 이벤트 수정 훅
export const useUpdateEvent = () => {
  const queryClient = useQueryClient()
  
  return useMutation({
    mutationFn: ({ id, input }: { id: string; input: UpdateEventInput }) => 
      EventService.updateEvent(id, input),
    onSuccess: (updatedEvent, { id }) => {
      // 상세 페이지 캐시 업데이트
      queryClient.setQueryData(
        queryKeys.events.detail(id),
        updatedEvent
      )
      
      // 타임라인 캐시 무효화
      queryClient.invalidateQueries({ queryKey: queryKeys.events.all })
      
      toast.success('이벤트가 수정되었습니다.')
    },
    onError: () => {
      toast.error('이벤트 수정에 실패했습니다.')
    },
  })
}

// 이벤트 삭제 훅
export const useDeleteEvent = () => {
  const queryClient = useQueryClient()
  
  return useMutation({
    mutationFn: (id: string) => EventService.deleteEvent(id),
    onSuccess: (_, id) => {
      // 캐시에서 이벤트 제거
      queryClient.removeQueries({ queryKey: queryKeys.events.detail(id) })
      
      // 타임라인 캐시 무효화
      queryClient.invalidateQueries({ queryKey: queryKeys.events.all })
      
      toast.success('이벤트가 삭제되었습니다.')
    },
    onError: () => {
      toast.error('이벤트 삭제에 실패했습니다.')
    },
  })
}

  const { data: eventUpdated } = useEventUpdatedSubscription({
    skip: !realtime,
    onSubscriptionData: ({ subscriptionData }) => {
      if (subscriptionData.data?.eventUpdated) {
        // 기존 이벤트 업데이트
        apolloClient.cache.writeFragment({
          id: apolloClient.cache.identify(subscriptionData.data.eventUpdated),
          fragment: gql`
            fragment UpdatedEvent on Event {
              id
              title
              startDate
              endDate
              status
            }
          `,
          data: subscriptionData.data.eventUpdated
        })
      }
    }
  })

  const { data: eventDeleted } = useEventDeletedSubscription({
    skip: !realtime,
    onSubscriptionData: ({ subscriptionData }) => {
      if (subscriptionData.data?.eventDeleted) {
        // 캐시에서 이벤트 제거
        apolloClient.cache.modify({
          fields: {
            events(existingEvents, { readField }) {
              return {
                ...existingEvents,
                edges: existingEvents.edges.filter(
                  (edge: any) => readField('id', edge.node) !== subscriptionData.data!.eventDeleted.id
                )
              }
            }
          }
        })
      }
    }
  })

  // 무한 스크롤
  const loadMore = useCallback(async () => {
    if (!data?.events.pageInfo.hasNextPage || loading) return

    try {
      await fetchMore({
        variables: {
          after: data.events.pageInfo.endCursor
        }
      })
    } catch (error) {
      console.error('Failed to load more events:', error)
    }
  }, [data, loading, fetchMore])

  // 새로고침
  const refresh = useCallback(async () => {
    try {
      await refetch()
    } catch (error) {
      console.error('Failed to refresh events:', error)
    }
  }, [refetch])

  // 이벤트 목록 추출
  const events = useMemo(() => {
    return data?.events.edges.map(edge => edge.node) || []
  }, [data])

  // 로딩 상태 계산
  const isLoading = loading && networkStatus !== 3 // 3 = refetch
  const isRefetching = networkStatus === 4 // 4 = refetch
  const isLoadingMore = networkStatus === 3 // 3 = fetchMore

  return {
    events,
    loading: isLoading,
    error,
    refetching: isRefetching,
    loadingMore: isLoadingMore,
    hasMore: data?.events.pageInfo.hasNextPage || false,
    loadMore,
    refresh,
    // 실시간 업데이트 상태
    realtimeConnected: realtime
  }
}

// 프로젝트 관련 훅
export const useProjects = () => {
  return useQuery({
    queryKey: queryKeys.projects.all,
    queryFn: () => ProjectService.getProjects(),
    staleTime: 1000 * 60 * 10, // 10분
  })
}

export const useProject = (id: string, enabled = true) => {
  return useQuery({
    queryKey: queryKeys.projects.detail(id),
    queryFn: () => ProjectService.getProject(id),
    enabled: enabled && !!id,
  })
}

export const useProjectMembers = (id: string, enabled = true) => {
  return useQuery({
    queryKey: queryKeys.projects.members(id),
    queryFn: () => ProjectService.getProjectMembers(id),
    enabled: enabled && !!id,
  })
}
```

### 6️⃣ 에러 및 로딩 상태 관리

```typescript
// src/hooks/use-query-error.ts
import { useQueryClient } from '@tanstack/react-query'
import { useCallback } from 'react'
import { toast } from 'sonner'

export const useQueryError = () => {
  const queryClient = useQueryClient()
  
  const handleError = useCallback((error: any, context?: string) => {
    const status = error?.response?.status
    const message = error?.response?.data?.message || error?.message
    
    console.error(`Query error${context ? ` in ${context}` : ''}:`, error)
    
    switch (status) {
      case 401:
        toast.error('로그인이 필요합니다.')
        // 로그인 페이지로 리다이렉트
        window.location.href = '/login'
        break
      case 403:
        toast.error('권한이 없습니다.')
        break
      case 404:
        toast.error('요청한 리소스를 찾을 수 없습니다.')
        break
      case 422:
        toast.error('입력 데이터를 확인해주세요.')
        break
      case 500:
        toast.error('서버 오류가 발생했습니다.')
        break
      default:
        toast.error(message || '알 수 없는 오류가 발생했습니다.')
    }
  }, [])
  
  const retryQuery = useCallback((queryKey: any[]) => {
    queryClient.refetchQueries({ queryKey })
  }, [queryClient])
  
  const invalidateQueries = useCallback((queryKey: any[]) => {
    queryClient.invalidateQueries({ queryKey })
  }, [queryClient])
  
  return {
    handleError,
    retryQuery,
    invalidateQueries,
  }
}

// 로딩 상태 관리 훅
export const useLoadingState = () => {
  const queryClient = useQueryClient()
  
  const isMutating = queryClient.isMutating()
  const isLoading = queryClient.isFetching() > 0
  
  return {
    isLoading,
    isMutating,
    isAnyLoading: isLoading || isMutating > 0,
  }
}

// 전역 에러 경계 컴포넌트
export const GlobalErrorBoundary = ({ children }: { children: React.ReactNode }) => {
  const { handleError } = useQueryError()
  
  const queryClient = useQueryClient()
  
  useEffect(() => {
    const unsubscribe = queryClient.getQueryCache().subscribe((event) => {
      if (event.type === 'error') {
        handleError(event.error, 'Query Cache')
      }
    })
    
    return unsubscribe
  }, [queryClient, handleError])
  
  return <>{children}</>
}
```

### 7️⃣ QueryClient Provider 설정

```typescript
// src/providers/query-provider.tsx
import { QueryClientProvider } from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
import { queryClient } from '@/lib/query/query-client'
import { GlobalErrorBoundary } from '@/hooks/use-query-error'

interface QueryProviderProps {
  children: React.ReactNode
}

export const QueryProvider = ({ children }: QueryProviderProps) => {
  return (
    <QueryClientProvider client={queryClient}>
      <GlobalErrorBoundary>
        {children}
      </GlobalErrorBoundary>
      {process.env.NODE_ENV === 'development' && (
        <ReactQueryDevtools initialIsOpen={false} />
      )}
    </QueryClientProvider>
  )
}

// App.tsx에서 사용
export default function App({ Component, pageProps }: AppProps) {
  return (
    <QueryProvider>
      <Component {...pageProps} />
    </QueryProvider>
  )
}
```

### 8️⃣ 사용 예시

```typescript
// src/components/calendar/event-list.tsx
import { useCalendarData, useCreateEvent, useUpdateEvent, useDeleteEvent } from '@/hooks/use-calendar-data'
import { Button } from '@/components/ui/button'
import { toast } from 'sonner'

interface EventListProps {
  dateRange: {
    start: Date
    end: Date
  }
  projectIds?: string[]
}

export const EventList = ({ dateRange, projectIds }: EventListProps) => {
  // 데이터 조회
  const { events, isLoading, error, refetch } = useCalendarData({
    dateRange,
    projectIds,
  })
  
  // 뮤테이션 훅
  const createEventMutation = useCreateEvent()
  const updateEventMutation = useUpdateEvent()
  const deleteEventMutation = useDeleteEvent()
  
  const handleCreateEvent = async (eventData: CreateEventInput) => {
    try {
      await createEventMutation.mutateAsync(eventData)
    } catch (error) {
      // 에러는 훅에서 자동 처리
    }
  }
  
  const handleUpdateEvent = async (id: string, eventData: UpdateEventInput) => {
    try {
      await updateEventMutation.mutateAsync({ id, input: eventData })
    } catch (error) {
      // 에러 처리
    }
  }
  
  const handleDeleteEvent = async (id: string) => {
    try {
      await deleteEventMutation.mutateAsync(id)
    } catch (error) {
      // 에러 처리
    }
  }
  
  if (isLoading) {
    return <div className="flex items-center justify-center p-8">
      <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary" />
    </div>
  }
  
  if (error) {
    return (
      <div className="text-center p-8">
        <p className="text-destructive mb-4">데이터를 불러오는데 실패했습니다.</p>
        <Button onClick={() => refetch()} variant="outline">
          다시 시도
        </Button>
      </div>
    )
  }
  
  return (
    <div className="space-y-4">
      {events.map((event) => (
        <div key={event.id} className="border rounded-lg p-4">
          <div className="flex items-center justify-between">
            <div>
              <h3 className="font-semibold">{event.title}</h3>
              <p className="text-sm text-muted-foreground">
                {new Date(event.startDate).toLocaleDateString()}
              </p>
            </div>
            <div className="flex gap-2">
              <Button
                size="sm"
                variant="outline"
                onClick={() => handleUpdateEvent(event.id, {
                  title: event.title + ' (Updated)'
                })}
                disabled={updateEventMutation.isPending}
              >
                수정
              </Button>
              <Button
                size="sm"
                variant="destructive"
                onClick={() => handleDeleteEvent(event.id)}
                disabled={deleteEventMutation.isPending}
              >
                삭제
              </Button>
            </div>
          </div>
        </div>
      ))}
    </div>
  )
}

---

## ✅ Definition of Done

### 🎯 기능 요구사항
- [x] Axios 기반 HTTP 클라이언트 구성
- [x] JWT 토큰 자동 관리 및 갱신
- [x] TanStack Query 데이터 상태 관리
- [x] Zod 스키마 기반 타입 안전성
- [x] 에러 처리 및 사용자 알림
- [x] 자동 재시도 및 백그라운드 업데이트
- [x] 무한 스크롤 페이지네이션

### 🔧 기술 요구사항
- [x] React 19.1.0 + TypeScript 5.5.4 호환
- [x] 백엔드 REST API 엔드포인트와 완벽 호환
- [x] 일관된 에러 처리 및 사용자 경험
- [x] 성능 최적화 (캐싱, 지연 로딩)
- [x] 로딩 상태 및 예외 상황 처리
- [x] 실시간 데이터 캐시 무효화

### 🧪 품질 요구사항
- [x] 완전한 타입 안전성 보장
- [x] API 스키마 유효성 검사
- [x] 일관된 쿼리 키 관리
- [x] 예외 상황 에러 바운드리
- [x] 개발자 도구 통합
- [x] 성능 모니터링 지원

### 📚 문서화 요구사항
- [x] API 클라이언트 사용법
- [x] 타입 정의 가이드
- [x] 커스텀 훅 사용법
- [x] 에러 처리 전략
- [x] 성능 최적화 방법

---

## 🧪 테스트 케이스

### Unit Tests
```typescript
describe('ApiClient', () => {
  test('should handle authentication tokens correctly', () => {})
  test('should retry requests on network errors', () => {})
  test('should validate response schemas', () => {})
})

describe('EventService', () => {
  test('should fetch timeline data with filters', () => {})
  test('should create events with validation', () => {})
  test('should handle API errors gracefully', () => {})
})

describe('useCalendarData', () => {
  test('should provide loading states', () => {})
  test('should handle error states', () => {})
  test('should cache data properly', () => {})
})
```

### Integration Tests
```typescript
describe('REST API Integration', () => {
  test('should authenticate and fetch user data', () => {})
  test('should perform CRUD operations on events', () => {})
  test('should handle pagination correctly', () => {})
})
```
```

---

## 📋 체크리스트

### 개발 단계
- [x] REST API 클라이언트 구성
- [x] Zod 스키마 정의
- [x] TanStack Query 설정
- [x] 서비스 레이어 구현
- [x] React Hooks 개발

### 테스트 단계
- [x] 단위 테스트 작성
- [x] API 통합 테스트
- [x] 에러 시나리오 테스트
- [x] 성능 테스트
- [x] 사용자 경험 테스트

### 배포 단계
- [x] 프로덕션 환경 설정
- [x] API 엔드포인트 확인
- [x] 성능 모니터링 설정
- [x] 에러 추적 설정
- [x] 문서화 업데이트

---

*이 스토리는 바로캘린더의 REST API 통합 시스템 구현을 다룹니다. GraphQL에서 REST API로 마이그레이션하여 백엔드와 완벽히 호환되는 타입 안전한 데이터 통신을 제공합니다.*
```

