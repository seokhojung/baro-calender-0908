# Story 2.5: 테스팅 전략 및 구현

## Status
Ready for Development

## Priority & Dependencies
- **Priority**: P1 (High) - 테스팅 인프라 조기 구축 필수
- **Story Points**: 5
- **Dependencies**: [1.1a, 1.1b, 1.1c] - 기본 프로젝트 설정 완료 후 즉시 적용
- **Blocked By**: None
- **⚡ Testing First Strategy**: TDD 방식으로 각 컴포넌트와 병행 개발

## Success Metrics
- **Business KPI**: 
  - 배포 전 버그 발견율 95% 이상
  - 테스트 실행 시간 5분 이내 (CI 파이프라인)
  - 개발자 테스트 작성 효율성 80% 향상
- **Technical KPI**:
  - 단위 테스트 커버리지 90% 이상
  - E2E 테스트 통과율 100%
  - 성능 회귀 방지율 100%
  - 접근성 위반 0개
- **Definition of Success**: 완전한 자동화 테스트 환경, CI/CD 통합 완료

## Risks & Mitigations
- **Technical Risks**: 
  - Risk: 테스트 환경 설정 복잡성으로 개발 지연
  - Impact: High
  - Mitigation: Sprint 2에서 즉시 테스팅 인프라 우선 구축, 템플릿화
- **Schedule Risks**:
  - Risk: 개발자의 테스트 코드 작성 미숙
  - Impact: Medium
  - Mitigation: 페어 프로그래밍, 테스트 템플릿 제공, 코드 리뷰 강화

---

## 🎯 **스토리 목표**

**완전한 테스팅 전략 및 자동화 시스템**
- 단위/통합/E2E 테스트 구현
- 접근성 및 시각적 회귀 테스트
- 성능 및 로드 테스트
- CI/CD 파이프라인 통합
- 테스트 커버리지 90%+ 달성

---

## 👤 **사용자 스토리**

**개발자로서, 나는:**
1. 코드 변경 시 기존 기능이 깨지지 않음을 확신하고 싶다
2. 자동화된 테스트로 배포 전 품질을 검증하고 싶다
3. 다양한 브라우저와 디바이스에서 일관된 동작을 보장하고 싶다
4. 성능 회귀를 미리 감지하고 싶다
5. 접근성 문제를 자동으로 탐지하고 싶다

---

## 🏗️ **기술적 구현 요구사항**

### **1. 단위 테스트 (Jest + Testing Library)**

**테스트 설정 및 유틸리티**
```typescript
// jest.config.js
const nextJest = require('next/jest')

const createJestConfig = nextJest({
  dir: './',
})

const customJestConfig = {
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  testEnvironment: 'jest-environment-jsdom',
  collectCoverageFrom: [
    'src/**/*.{js,jsx,ts,tsx}',
    '!src/**/*.d.ts',
    '!src/**/*.stories.{js,jsx,ts,tsx}',
  ],
  coverageThreshold: {
    global: {
      branches: 90,
      functions: 90,
      lines: 90,
      statements: 90,
    },
  },
  moduleNameMapping: {
    '^@/(.*)$': '<rootDir>/src/$1',
  },
  transform: {
    '^.+\\.(js|jsx|ts|tsx)$': ['babel-jest', { presets: ['next/babel'] }],
  },
}

module.exports = createJestConfig(customJestConfig)
```

**테스트 유틸리티**
```typescript
// src/test-utils/index.tsx
import React from 'react'
import { render, RenderOptions } from '@testing-library/react'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { ThemeProvider } from '@/contexts/ThemeContext'
import { CalendarProvider } from '@/contexts/CalendarContext'

const AllTheProviders: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        retry: false,
      },
    },
  })

  return (
    <QueryClientProvider client={queryClient}>
      <ThemeProvider>
        <CalendarProvider>
          {children}
        </CalendarProvider>
      </ThemeProvider>
    </QueryClientProvider>
  )
}

const customRender = (
  ui: React.ReactElement,
  options?: Omit<RenderOptions, 'wrapper'>
) => render(ui, { wrapper: AllTheProviders, ...options })

export * from '@testing-library/react'
export { customRender as render }

// Mock 유틸리티
export const mockEvent = (overrides?: Partial<CalendarEvent>): CalendarEvent => ({
  id: 'test-event-1',
  title: 'Test Event',
  description: 'Test Description',
  startDate: new Date('2025-01-15T10:00:00'),
  endDate: new Date('2025-01-15T11:00:00'),
  allDay: false,
  projectId: 'test-project-1',
  projectColor: '#3B82F6',
  status: 'confirmed',
  createdAt: new Date(),
  updatedAt: new Date(),
  ...overrides,
})

export const mockProject = (overrides?: Partial<Project>): Project => ({
  id: 'test-project-1',
  name: 'Test Project',
  color: '#3B82F6',
  description: 'Test Project Description',
  createdAt: new Date(),
  updatedAt: new Date(),
  ...overrides,
})
```

**컴포넌트 테스트 예시**
```typescript
// src/components/calendar/__tests__/MonthView.test.tsx
import { render, screen, fireEvent, waitFor } from '@/test-utils'
import { MonthView } from '../MonthView'
import { useCalendarStore } from '@/stores/calendarStore'

// Mock store
jest.mock('@/stores/calendarStore')
const mockUseCalendarStore = useCalendarStore as jest.MockedFunction<typeof useCalendarStore>

describe('MonthView', () => {
  const mockEvents = [
    mockEvent({
      id: '1',
      title: 'Meeting',
      startDate: new Date('2025-01-15T10:00:00'),
    }),
    mockEvent({
      id: '2', 
      title: 'Lunch',
      startDate: new Date('2025-01-15T12:00:00'),
    }),
  ]

  beforeEach(() => {
    mockUseCalendarStore.mockReturnValue({
      currentDate: new Date('2025-01-15'),
      events: mockEvents,
      viewMode: 'month',
      selectDate: jest.fn(),
      navigateNext: jest.fn(),
      navigatePrevious: jest.fn(),
      getVisibleDateRange: jest.fn(() => ({
        start: new Date('2025-01-01'),
        end: new Date('2025-01-31')
      })),
      getFilteredEvents: jest.fn(() => mockEvents),
    })
  })

  it('renders calendar grid with correct structure', () => {
    render(<MonthView />)
    
    // 주 헤더가 있는지 확인
    expect(screen.getByText('Sun')).toBeInTheDocument()
    expect(screen.getByText('Mon')).toBeInTheDocument()
    expect(screen.getByText('Sat')).toBeInTheDocument()
    
    // 날짜 그리드가 있는지 확인
    expect(screen.getByRole('grid')).toBeInTheDocument()
  })

  it('displays events on correct dates', () => {
    render(<MonthView />)
    
    // 15일에 이벤트들이 표시되는지 확인
    const day15 = screen.getByText('15').closest('.calendar-day')
    expect(day15).toBeInTheDocument()
    expect(screen.getByText('Meeting')).toBeInTheDocument()
    expect(screen.getByText('Lunch')).toBeInTheDocument()
  })

  it('handles date selection', async () => {
    const mockSelectDate = jest.fn()
    mockUseCalendarStore.mockReturnValue({
      ...mockUseCalendarStore(),
      selectDate: mockSelectDate,
    })

    render(<MonthView />)
    
    const day20 = screen.getByText('20')
    fireEvent.click(day20)
    
    await waitFor(() => {
      expect(mockSelectDate).toHaveBeenCalledWith(expect.any(Date))
    })
  })

  it('supports keyboard navigation', async () => {
    render(<MonthView />)
    
    const grid = screen.getByRole('grid')
    
    // 화살표 키 테스트
    fireEvent.keyDown(grid, { key: 'ArrowRight' })
    fireEvent.keyDown(grid, { key: 'ArrowDown' })
    fireEvent.keyDown(grid, { key: 'Enter' })
    
    // 키보드 이벤트가 처리되는지 확인
    await waitFor(() => {
      expect(grid).toHaveFocus()
    })
  })

  it('meets accessibility requirements', async () => {
    const { container } = render(<MonthView />)
    
    // ARIA 속성 확인
    const grid = screen.getByRole('grid')
    expect(grid).toHaveAttribute('aria-label')
    
    // 접근성 테스트
    const results = await runAccessibilityTests(container)
    expect(results).toHaveNoViolations()
  })
})
```

### **2. 통합 테스트**

**API 통합 테스트**
```typescript
// src/__tests__/integration/calendar-api.test.tsx
import { render, screen, fireEvent, waitFor } from '@/test-utils'
import { CalendarPage } from '@/pages/calendar'
import { server } from '@/mocks/server'
import { rest } from 'msw'

describe('Calendar API Integration', () => {
  it('loads events from API and displays them', async () => {
    // MSW로 API 모킹
    server.use(
      rest.get('/api/events', (req, res, ctx) => {
        return res(ctx.json({
          events: [
            {
              id: '1',
              title: 'API Event',
              startDate: '2025-01-15T10:00:00Z',
              endDate: '2025-01-15T11:00:00Z',
              projectId: 'project-1',
            }
          ]
        }))
      })
    )

    render(<CalendarPage />)
    
    // API에서 이벤트가 로드되기를 기다림
    await waitFor(() => {
      expect(screen.getByText('API Event')).toBeInTheDocument()
    })
  })

  it('creates new event via API', async () => {
    let createdEvent: any = null
    
    server.use(
      rest.post('/api/events', async (req, res, ctx) => {
        createdEvent = await req.json()
        return res(ctx.json({
          id: '2',
          ...createdEvent
        }))
      })
    )

    render(<CalendarPage />)
    
    // 이벤트 생성 버튼 클릭
    const createButton = screen.getByText('New Event')
    fireEvent.click(createButton)
    
    // 폼 작성
    fireEvent.change(screen.getByLabelText('Title'), {
      target: { value: 'New Meeting' }
    })
    
    // 저장 버튼 클릭
    const saveButton = screen.getByText('Save')
    fireEvent.click(saveButton)
    
    // API 호출 확인
    await waitFor(() => {
      expect(createdEvent).toMatchObject({
        title: 'New Meeting'
      })
    })
  })

  it('handles API errors gracefully', async () => {
    // API 에러 시뮬레이션
    server.use(
      rest.get('/api/events', (req, res, ctx) => {
        return res(ctx.status(500), ctx.json({
          error: 'Internal Server Error'
        }))
      })
    )

    render(<CalendarPage />)
    
    // 에러 메시지가 표시되는지 확인
    await waitFor(() => {
      expect(screen.getByText(/failed to load events/i)).toBeInTheDocument()
    })
  })
})
```

### **3. E2E 테스트 (Playwright)**

**Playwright 설정**
```typescript
// playwright.config.ts
import { defineConfig, devices } from '@playwright/test'

export default defineConfig({
  testDir: './e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',
  
  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
  },

  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },
    {
      name: 'mobile-chrome',
      use: { ...devices['Pixel 5'] },
    },
  ],

  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:3000',
    reuseExistingServer: !process.env.CI,
  },
})
```

**E2E 테스트 예시**
```typescript
// e2e/calendar-flow.spec.ts
import { test, expect } from '@playwright/test'

test.describe('Calendar Application', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/')
    
    // 로그인 (필요한 경우)
    await page.fill('[data-testid=email]', 'test@example.com')
    await page.fill('[data-testid=password]', 'password')
    await page.click('[data-testid=login-button]')
    
    // 캘린더 페이지 로드 대기
    await page.waitForSelector('[data-testid=calendar-view]')
  })

  test('complete event creation flow', async ({ page }) => {
    // 새 이벤트 버튼 클릭
    await page.click('[data-testid=new-event-button]')
    
    // 모달이 열렸는지 확인
    await expect(page.locator('[data-testid=event-modal]')).toBeVisible()
    
    // 이벤트 정보 입력
    await page.fill('[data-testid=event-title]', 'Team Meeting')
    await page.fill('[data-testid=event-description]', 'Weekly team sync')
    
    // 프로젝트 선택
    await page.click('[data-testid=project-select]')
    await page.click('[data-testid=project-option-1]')
    
    // 날짜 및 시간 설정
    await page.fill('[data-testid=start-date]', '2025-01-20')
    await page.fill('[data-testid=start-time]', '10:00')
    await page.fill('[data-testid=end-time]', '11:00')
    
    // 저장
    await page.click('[data-testid=save-event]')
    
    // 모달이 닫혔는지 확인
    await expect(page.locator('[data-testid=event-modal]')).not.toBeVisible()
    
    // 캘린더에 이벤트가 표시되는지 확인
    await expect(page.locator('text=Team Meeting')).toBeVisible()
  })

  test('drag and drop event rescheduling', async ({ page }) => {
    // 기존 이벤트 찾기
    const event = page.locator('[data-testid=event-item]').first()
    const sourceDate = page.locator('[data-testid=calendar-day-15]')
    const targetDate = page.locator('[data-testid=calendar-day-16]')
    
    // 드래그 앤 드롭 실행
    await event.dragTo(targetDate)
    
    // 이벤트가 새로운 날짜로 이동했는지 확인
    await expect(targetDate.locator('[data-testid=event-item]')).toBeVisible()
  })

  test('keyboard navigation', async ({ page }) => {
    const calendar = page.locator('[data-testid=calendar-grid]')
    
    // 캘린더에 포커스
    await calendar.focus()
    
    // 화살표 키로 네비게이션
    await page.keyboard.press('ArrowRight')
    await page.keyboard.press('ArrowDown')
    
    // Enter로 날짜 선택
    await page.keyboard.press('Enter')
    
    // 선택된 날짜가 강조표시되는지 확인
    await expect(page.locator('.selected-date')).toBeVisible()
  })

  test('responsive design on mobile', async ({ page }) => {
    // 모바일 뷰포트 설정
    await page.setViewportSize({ width: 375, height: 667 })
    
    // 모바일 네비게이션이 보이는지 확인
    await expect(page.locator('[data-testid=mobile-nav]')).toBeVisible()
    
    // 데스크톱 사이드바가 숨겨졌는지 확인
    await expect(page.locator('[data-testid=desktop-sidebar]')).not.toBeVisible()
    
    // 터치 제스처 시뮬레이션
    await page.touchscreen.tap(200, 300)
    await page.mouse.move(200, 300)
    await page.mouse.move(300, 300) // 스와이프
  })

  test('performance benchmarks', async ({ page }) => {
    // 성능 메트릭 수집
    const startTime = Date.now()
    
    await page.goto('/')
    await page.waitForSelector('[data-testid=calendar-view]')
    
    const loadTime = Date.now() - startTime
    expect(loadTime).toBeLessThan(3000) // 3초 이내 로딩
    
    // 많은 이벤트가 있는 상황에서 성능 테스트
    await page.evaluate(() => {
      // 100개 이벤트 생성
      const events = Array.from({ length: 100 }, (_, i) => ({
        id: `perf-test-${i}`,
        title: `Performance Test Event ${i}`,
        startDate: new Date(2025, 0, Math.floor(i / 4) + 1),
      }))
      
      window.testEvents = events
    })
    
    const renderStart = Date.now()
    await page.reload()
    await page.waitForSelector('[data-testid=calendar-view]')
    const renderTime = Date.now() - renderStart
    
    expect(renderTime).toBeLessThan(5000) // 5초 이내 렌더링
  })
})
```

### **4. 시각적 회귀 테스트**

**시각적 테스트 설정**
```typescript
// e2e/visual.spec.ts
import { test, expect } from '@playwright/test'

test.describe('Visual Regression Tests', () => {
  test('calendar month view appearance', async ({ page }) => {
    await page.goto('/calendar')
    await page.waitForSelector('[data-testid=calendar-view]')
    
    // 테스트 데이터 로드
    await page.evaluate(() => {
      window.testMode = true
    })
    
    // 스크린샷 비교
    await expect(page).toHaveScreenshot('calendar-month-view.png')
  })

  test('event creation modal', async ({ page }) => {
    await page.goto('/calendar')
    await page.click('[data-testid=new-event-button]')
    await page.waitForSelector('[data-testid=event-modal]')
    
    await expect(page.locator('[data-testid=event-modal]')).toHaveScreenshot('event-modal.png')
  })

  test('dark mode theme', async ({ page }) => {
    await page.goto('/calendar')
    
    // 다크 모드 활성화
    await page.click('[data-testid=theme-toggle]')
    await page.waitForTimeout(500) // 테마 전환 애니메이션 대기
    
    await expect(page).toHaveScreenshot('calendar-dark-mode.png')
  })

  test('mobile responsive layout', async ({ page }) => {
    await page.setViewportSize({ width: 375, height: 667 })
    await page.goto('/calendar')
    
    await expect(page).toHaveScreenshot('calendar-mobile.png')
  })
})
```

### **5. 성능 테스트**

**성능 테스트 설정**
```typescript
// tests/performance.spec.ts
import { test, expect } from '@playwright/test'

test.describe('Performance Tests', () => {
  test('Core Web Vitals', async ({ page }) => {
    await page.goto('/')
    
    // Web Vitals 수집
    const vitals = await page.evaluate(() => {
      return new Promise((resolve) => {
        const vitals: Record<string, number> = {}
        
        // LCP
        new PerformanceObserver((list) => {
          const entries = list.getEntries()
          vitals.lcp = entries[entries.length - 1].startTime
        }).observe({ type: 'largest-contentful-paint', buffered: true })
        
        // FID
        new PerformanceObserver((list) => {
          vitals.fid = list.getEntries()[0].processingStart - list.getEntries()[0].startTime
        }).observe({ type: 'first-input', buffered: true })
        
        // CLS
        let clsValue = 0
        new PerformanceObserver((list) => {
          list.getEntries().forEach((entry: any) => {
            if (!entry.hadRecentInput) {
              clsValue += entry.value
            }
          })
          vitals.cls = clsValue
        }).observe({ type: 'layout-shift', buffered: true })
        
        setTimeout(() => resolve(vitals), 3000)
      })
    })
    
    // Core Web Vitals 기준 검증
    expect(vitals.lcp).toBeLessThan(2500) // LCP < 2.5s
    expect(vitals.fid).toBeLessThan(100)  // FID < 100ms
    expect(vitals.cls).toBeLessThan(0.1)  // CLS < 0.1
  })

  test('bundle size monitoring', async ({ page }) => {
    const response = await page.goto('/')
    
    // JavaScript 번들 크기 확인
    const resources = await page.evaluate(() => {
      return performance.getEntriesByType('resource')
        .filter((entry: any) => entry.name.includes('.js'))
        .map((entry: any) => ({
          name: entry.name,
          size: entry.transferSize
        }))
    })
    
    const totalSize = resources.reduce((sum, resource) => sum + resource.size, 0)
    expect(totalSize).toBeLessThan(500 * 1024) // 500KB 미만
  })
})
```

### **6. 접근성 테스트 자동화**

```typescript
// tests/accessibility.spec.ts
import { test, expect } from '@playwright/test'
import AxeBuilder from '@axe-core/playwright'

test.describe('Accessibility Tests', () => {
  test('calendar page accessibility', async ({ page }) => {
    await page.goto('/calendar')
    
    const accessibilityScanResults = await new AxeBuilder({ page })
      .withTags(['wcag2a', 'wcag2aa'])
      .analyze()
    
    expect(accessibilityScanResults.violations).toEqual([])
  })

  test('keyboard navigation', async ({ page }) => {
    await page.goto('/calendar')
    
    // Tab 키로 포커스 이동
    await page.keyboard.press('Tab')
    await page.keyboard.press('Tab')
    
    // 현재 포커스된 요소 확인
    const focusedElement = await page.evaluate(() => document.activeElement?.tagName)
    expect(focusedElement).toBeTruthy()
  })
})
```

---

## 📊 **테스트 자동화 및 CI/CD 통합**

### **GitHub Actions 워크플로우**
```yaml
# .github/workflows/test.yml
name: Test Suite

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - run: npm ci
      - run: npm run test -- --coverage
      - run: npm run test:accessibility
      
      - uses: codecov/codecov-action@v3
        with:
          file: ./coverage/lcov.info

  e2e-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - run: npm ci
      - run: npx playwright install
      - run: npm run build
      - run: npm run test:e2e
      
      - uses: actions/upload-artifact@v3
        if: failure()
        with:
          name: playwright-report
          path: playwright-report/

  performance-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
      - run: npm ci
      - run: npm run build
      - run: npm run test:performance
```

---

## ✅ **Definition of Done**

### **기능 요구사항**
- [ ] 단위 테스트 커버리지 90%+
- [ ] 통합 테스트로 API 연동 검증
- [ ] E2E 테스트로 사용자 플로우 검증
- [ ] 접근성 테스트 자동화
- [ ] 시각적 회귀 테스트

### **기술 요구사항**
- [ ] Jest + Testing Library 설정
- [ ] Playwright E2E 테스트
- [ ] MSW API 모킹
- [ ] 성능 벤치마크 테스트

### **품질 요구사항**
- [ ] 모든 테스트가 CI에서 통과
- [ ] 브라우저 크로스 테스트
- [ ] 모바일 디바이스 테스트
- [ ] 성능 회귀 방지

### **자동화 요구사항**
- [ ] CI/CD 파이프라인 통합
- [ ] 테스트 실패 시 배포 차단
- [ ] 커버리지 리포트 자동 생성
- [ ] 성능 메트릭 모니터링

---

## 📚 **관련 문서 참조**

- [12. Monitoring & Testing](../ui-architecture/12-monitoring-testing.md)
- [22. CI Pipeline & Performance](../ui-architecture/22-ci-pipeline-performance.md)
- [11. Accessibility Implementation](../ui-architecture/11-accessibility-implementation.md)

---

**이 스토리는 바로캘린더의 종합적인 테스팅 전략 구현을 위한 기술 가이드입니다. 높은 품질과 안정성을 보장하는 자동화된 테스트 시스템을 구축합니다.**