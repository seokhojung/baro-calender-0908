# Story 2.6: ì ‘ê·¼ì„± êµ¬í˜„ ì‹œìŠ¤í…œ

## ğŸ“‹ ë¬¸ì„œ ì •ë³´
- **ìŠ¤í† ë¦¬ ë²„ì „**: 2.0
- **ì‘ì„±ì¼**: 2025-08-28
- **ì‘ì„±ì**: Bob (Scrum Master Agent)  
- **í”„ë¡œì íŠ¸ëª…**: ë°”ë¡œìº˜ë¦°ë” (Baro Calendar)
- **Epic**: í”„ë¡ íŠ¸ì—”ë“œ ì ‘ê·¼ì„± êµ¬í˜„
- **ìƒíƒœ**: Ready for Development

---

## ğŸ¯ **ìŠ¤í† ë¦¬ ëª©í‘œ**

**ì™„ì „í•œ ì ‘ê·¼ì„±(Accessibility) ì‹œìŠ¤í…œ êµ¬í˜„**
- WCAG 2.1 AA ê¸°ì¤€ ì¤€ìˆ˜
- ìŠ¤í¬ë¦° ë¦¬ë” ì™„ì „ ì§€ì›
- í‚¤ë³´ë“œ ì „ìš© ë„¤ë¹„ê²Œì´ì…˜
- ìƒ‰ìƒ ëŒ€ë¹„ìœ¨ ë° ê³ ëŒ€ë¹„ ëª¨ë“œ
- ë‹¤êµ­ì–´ ë° RTL ì§€ì›

---

## ğŸ‘¤ **ì‚¬ìš©ì ìŠ¤í† ë¦¬**

**ì‚¬ìš©ìë¡œì„œ, ë‚˜ëŠ”:**
1. ìŠ¤í¬ë¦° ë¦¬ë”ë¥¼ ì‚¬ìš©í•´ë„ ëª¨ë“  ê¸°ëŠ¥ì— ì ‘ê·¼í•˜ê³  ì‹¶ë‹¤
2. í‚¤ë³´ë“œë§Œìœ¼ë¡œë„ ì™„ì „íˆ ì•±ì„ ì¡°ì‘í•˜ê³  ì‹¶ë‹¤
3. ì‹œê° ì¥ì• ê°€ ìˆì–´ë„ ì¶©ë¶„í•œ ìƒ‰ìƒ ëŒ€ë¹„ë¡œ ë‚´ìš©ì„ ì½ê³  ì‹¶ë‹¤
4. ìš´ë™ ì¥ì• ê°€ ìˆì–´ë„ ì¶©ë¶„í•œ ì‹œê°„ì„ ê°–ê³  ì¡°ì‘í•˜ê³  ì‹¶ë‹¤
5. ë‹¤ì–‘í•œ ì–¸ì–´ì™€ ë¬¸í™”ê¶Œì—ì„œ ìì—°ìŠ¤ëŸ½ê²Œ ì‚¬ìš©í•˜ê³  ì‹¶ë‹¤

---

## ğŸ—ï¸ **ê¸°ìˆ ì  êµ¬í˜„ ìš”êµ¬ì‚¬í•­**

### **1. ARIA ë° ì‹œë§¨í‹± HTML**

**ì ‘ê·¼ ê°€ëŠ¥í•œ ìº˜ë¦°ë” ì»´í¬ë„ŒíŠ¸**
```typescript
// src/components/accessibility/AccessibleCalendar.tsx
import React, { useRef, useEffect, useState } from 'react'
import { format, isSameDay, startOfMonth, endOfMonth } from 'date-fns'
import { useKeyboardNavigation } from '@/hooks/useKeyboardNavigation'
import { useScreenReader } from '@/hooks/useScreenReader'

interface AccessibleCalendarProps {
  selectedDate: Date | null
  onDateSelect: (date: Date) => void
  onEventSelect: (event: CalendarEvent) => void
  events: CalendarEvent[]
}

export const AccessibleCalendar: React.FC<AccessibleCalendarProps> = ({
  selectedDate,
  onDateSelect,
  onEventSelect,
  events
}) => {
  const [focusedDate, setFocusedDate] = useState(new Date())
  const [announcements, setAnnouncements] = useState<string>('')
  const gridRef = useRef<HTMLDivElement>(null)
  const { announce } = useScreenReader()
  
  // í‚¤ë³´ë“œ ë„¤ë¹„ê²Œì´ì…˜
  const { handleKeyDown } = useKeyboardNavigation({
    onArrowLeft: () => navigateDate(-1, 0),
    onArrowRight: () => navigateDate(1, 0),
    onArrowUp: () => navigateDate(0, -1),
    onArrowDown: () => navigateDate(0, 1),
    onEnter: () => handleDateSelect(focusedDate),
    onSpace: () => handleDateSelect(focusedDate),
    onHome: () => goToStartOfWeek(),
    onEnd: () => goToEndOfWeek(),
    onPageUp: () => navigateMonth(-1),
    onPageDown: () => navigateMonth(1),
  })
  
  const navigateDate = (dayDelta: number, weekDelta: number) => {
    const newDate = new Date(focusedDate)
    newDate.setDate(newDate.getDate() + dayDelta + (weekDelta * 7))
    setFocusedDate(newDate)
    
    // ìŒì„± ì•ˆë‚´
    const dateStr = format(newDate, 'EEEE, MMMM do, yyyy')
    const eventCount = getEventsForDate(events, newDate).length
    const announcement = eventCount > 0 
      ? `${dateStr}, ${eventCount} events`
      : dateStr
    
    announce(announcement)
  }
  
  const handleDateSelect = (date: Date) => {
    onDateSelect(date)
    const eventsOnDate = getEventsForDate(events, date)
    
    if (eventsOnDate.length > 0) {
      announce(`Selected ${format(date, 'MMMM do')}, ${eventsOnDate.length} events available`)
    } else {
      announce(`Selected ${format(date, 'MMMM do')}, no events`)
    }
  }
  
  return (
    <div className="accessible-calendar">
      {/* Skip link */}
      <a 
        href="#main-content" 
        className="sr-only focus:not-sr-only focus:absolute focus:top-4 focus:left-4 z-50 bg-primary text-primary-foreground px-4 py-2 rounded"
      >
        Skip to main content
      </a>
      
      {/* Calendar instructions */}
      <div id="calendar-instructions" className="sr-only">
        Use arrow keys to navigate dates. Press Enter or Space to select a date.
        Press Page Up or Page Down to navigate months.
        Press Home to go to start of week, End to go to end of week.
      </div>
      
      {/* Live region for announcements */}
      <div 
        aria-live="polite" 
        aria-atomic="true" 
        className="sr-only"
        role="status"
      >
        {announcements}
      </div>
      
      {/* Calendar header */}
      <header className="calendar-header mb-4">
        <h2 id="calendar-title" className="text-xl font-semibold">
          {format(focusedDate, 'MMMM yyyy')}
        </h2>
        <div className="calendar-nav" role="group" aria-label="Calendar navigation">
          <button
            onClick={() => navigateMonth(-1)}
            aria-label={`Previous month, ${format(addMonths(focusedDate, -1), 'MMMM yyyy')}`}
            className="btn btn-secondary"
          >
            <ChevronLeft aria-hidden="true" />
            <span className="sr-only">Previous month</span>
          </button>
          <button
            onClick={() => navigateMonth(1)}
            aria-label={`Next month, ${format(addMonths(focusedDate, 1), 'MMMM yyyy')}`}
            className="btn btn-secondary"
          >
            <ChevronRight aria-hidden="true" />
            <span className="sr-only">Next month</span>
          </button>
        </div>
      </header>
      
      {/* Calendar grid */}
      <div
        ref={gridRef}
        role="grid"
        aria-labelledby="calendar-title"
        aria-describedby="calendar-instructions"
        onKeyDown={handleKeyDown}
        tabIndex={0}
        className="calendar-grid focus:outline-none focus:ring-2 focus:ring-primary"
      >
        {/* Weekday headers */}
        <div role="row" className="weekday-headers">
          {['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'].map((day) => (
            <div
              key={day}
              role="columnheader"
              className="weekday-header font-medium text-center p-2"
              abbr={day.slice(0, 3)}
            >
              <span aria-hidden="true">{day.slice(0, 3)}</span>
              <span className="sr-only">{day}</span>
            </div>
          ))}
        </div>
        
        {/* Calendar days */}
        {getCalendarWeeks(focusedDate).map((week, weekIndex) => (
          <div key={weekIndex} role="row" className="calendar-week">
            {week.map((date, dayIndex) => {
              const dayEvents = getEventsForDate(events, date)
              const isCurrentMonth = isSameMonth(date, focusedDate)
              const isSelected = selectedDate && isSameDay(date, selectedDate)
              const isFocused = isSameDay(date, focusedDate)
              const isToday = isSameDay(date, new Date())
              
              return (
                <CalendarDay
                  key={dayIndex}
                  date={date}
                  events={dayEvents}
                  isCurrentMonth={isCurrentMonth}
                  isSelected={isSelected}
                  isFocused={isFocused}
                  isToday={isToday}
                  onSelect={handleDateSelect}
                  onEventSelect={onEventSelect}
                />
              )
            })}
          </div>
        ))}
      </div>
    </div>
  )
}

// ì ‘ê·¼ ê°€ëŠ¥í•œ ë‚ ì§œ ì…€ ì»´í¬ë„ŒíŠ¸
const CalendarDay: React.FC<{
  date: Date
  events: CalendarEvent[]
  isCurrentMonth: boolean
  isSelected: boolean
  isFocused: boolean
  isToday: boolean
  onSelect: (date: Date) => void
  onEventSelect: (event: CalendarEvent) => void
}> = ({ 
  date, 
  events, 
  isCurrentMonth, 
  isSelected, 
  isFocused, 
  isToday,
  onSelect,
  onEventSelect 
}) => {
  const dayRef = useRef<HTMLDivElement>(null)
  
  // í¬ì»¤ìŠ¤ ê´€ë¦¬
  useEffect(() => {
    if (isFocused && dayRef.current) {
      dayRef.current.focus()
    }
  }, [isFocused])
  
  const handleClick = () => {
    onSelect(date)
  }
  
  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault()
      handleClick()
    }
  }
  
  const dayLabel = format(date, 'MMMM d, yyyy')
  const eventsLabel = events.length > 0 ? `, ${events.length} events` : ''
  const stateLabels = [
    isToday && 'today',
    isSelected && 'selected',
    !isCurrentMonth && 'outside current month'
  ].filter(Boolean).join(', ')
  
  const fullLabel = `${dayLabel}${eventsLabel}${stateLabels ? `, ${stateLabels}` : ''}`
  
  return (
    <div
      ref={dayRef}
      role="gridcell"
      tabIndex={isFocused ? 0 : -1}
      aria-label={fullLabel}
      aria-selected={isSelected}
      aria-current={isToday ? 'date' : undefined}
      onClick={handleClick}
      onKeyDown={handleKeyDown}
      className={cn(
        'calendar-day p-2 border cursor-pointer',
        'focus:outline-none focus:ring-2 focus:ring-primary focus:ring-inset',
        !isCurrentMonth && 'text-muted-foreground bg-muted/30',
        isSelected && 'bg-primary text-primary-foreground',
        isToday && !isSelected && 'ring-1 ring-primary',
        isFocused && 'ring-2 ring-primary ring-offset-2'
      )}
    >
      {/* Date number */}
      <div className="text-sm font-medium mb-1" aria-hidden="true">
        {format(date, 'd')}
      </div>
      
      {/* Events */}
      {events.length > 0 && (
        <div className="space-y-1" role="list" aria-label={`${events.length} events`}>
          {events.slice(0, 3).map((event) => (
            <div
              key={event.id}
              role="listitem"
              className="text-xs p-1 rounded truncate cursor-pointer hover:opacity-80"
              style={{ backgroundColor: `${event.projectColor}20` }}
              onClick={(e) => {
                e.stopPropagation()
                onEventSelect(event)
              }}
              onKeyDown={(e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                  e.preventDefault()
                  e.stopPropagation()
                  onEventSelect(event)
                }
              }}
              tabIndex={0}
              aria-label={`${event.title} at ${format(event.startDate, 'h:mm a')}`}
            >
              {event.title}
            </div>
          ))}
          {events.length > 3 && (
            <div className="text-xs text-muted-foreground" aria-hidden="true">
              +{events.length - 3} more
            </div>
          )}
        </div>
      )}
    </div>
  )
}
```

### **2. í‚¤ë³´ë“œ ë„¤ë¹„ê²Œì´ì…˜ ì‹œìŠ¤í…œ**

**ì¢…í•©ì ì¸ í‚¤ë³´ë“œ ë„¤ë¹„ê²Œì´ì…˜**
```typescript
// src/hooks/useKeyboardNavigation.ts
import { useEffect, useCallback, useRef } from 'react'

interface KeyboardNavigationOptions {
  onArrowLeft?: () => void
  onArrowRight?: () => void
  onArrowUp?: () => void
  onArrowDown?: () => void
  onEnter?: () => void
  onSpace?: () => void
  onEscape?: () => void
  onTab?: () => void
  onShiftTab?: () => void
  onHome?: () => void
  onEnd?: () => void
  onPageUp?: () => void
  onPageDown?: () => void
  disabled?: boolean
}

export const useKeyboardNavigation = (options: KeyboardNavigationOptions) => {
  const handleKeyDown = useCallback((e: KeyboardEvent | React.KeyboardEvent) => {
    if (options.disabled) return
    
    const { key, ctrlKey, metaKey, shiftKey } = e
    
    switch (key) {
      case 'ArrowLeft':
        e.preventDefault()
        options.onArrowLeft?.()
        break
        
      case 'ArrowRight':
        e.preventDefault()
        options.onArrowRight?.()
        break
        
      case 'ArrowUp':
        e.preventDefault()
        options.onArrowUp?.()
        break
        
      case 'ArrowDown':
        e.preventDefault()
        options.onArrowDown?.()
        break
        
      case 'Enter':
        options.onEnter?.()
        break
        
      case ' ':
        e.preventDefault()
        options.onSpace?.()
        break
        
      case 'Escape':
        options.onEscape?.()
        break
        
      case 'Tab':
        if (shiftKey) {
          options.onShiftTab?.()
        } else {
          options.onTab?.()
        }
        break
        
      case 'Home':
        e.preventDefault()
        options.onHome?.()
        break
        
      case 'End':
        e.preventDefault()
        options.onEnd?.()
        break
        
      case 'PageUp':
        e.preventDefault()
        options.onPageUp?.()
        break
        
      case 'PageDown':
        e.preventDefault()
        options.onPageDown?.()
        break
    }
  }, [options])
  
  return { handleKeyDown }
}

// Focus trap for modals
export const useFocusTrap = (isActive: boolean) => {
  const containerRef = useRef<HTMLDivElement>(null)
  const focusableElementsString = `
    a[href],
    area[href],
    input:not([disabled]):not([type="hidden"]),
    select:not([disabled]),
    textarea:not([disabled]),
    button:not([disabled]),
    iframe,
    object,
    embed,
    [tabindex]:not([tabindex="-1"]),
    [contenteditable]
  `
  
  useEffect(() => {
    if (!isActive || !containerRef.current) return
    
    const container = containerRef.current
    const focusableElements = container.querySelectorAll(focusableElementsString)
    const firstElement = focusableElements[0] as HTMLElement
    const lastElement = focusableElements[focusableElements.length - 1] as HTMLElement
    
    // Focus first element
    if (firstElement) {
      firstElement.focus()
    }
    
    const handleTab = (e: KeyboardEvent) => {
      if (e.key !== 'Tab') return
      
      if (e.shiftKey) {
        if (document.activeElement === firstElement) {
          e.preventDefault()
          lastElement?.focus()
        }
      } else {
        if (document.activeElement === lastElement) {
          e.preventDefault()
          firstElement?.focus()
        }
      }
    }
    
    container.addEventListener('keydown', handleTab)
    return () => container.removeEventListener('keydown', handleTab)
  }, [isActive])
  
  return containerRef
}
```

### **3. ìŠ¤í¬ë¦° ë¦¬ë” ì§€ì›**

**ìŠ¤í¬ë¦° ë¦¬ë” ìµœì í™”**
```typescript
// src/hooks/useScreenReader.ts
import { useEffect, useRef, useState } from 'react'

export const useScreenReader = () => {
  const announceRef = useRef<HTMLDivElement>(null)
  const [isScreenReaderActive, setIsScreenReaderActive] = useState(false)
  
  // ìŠ¤í¬ë¦° ë¦¬ë” ê°ì§€
  useEffect(() => {
    // ë‹¤ì–‘í•œ ë°©ë²•ìœ¼ë¡œ ìŠ¤í¬ë¦° ë¦¬ë” ê°ì§€
    const detectScreenReader = () => {
      // 1. ìŠ¤í¬ë¦° ë¦¬ë” User Agent í™•ì¸
      const userAgent = navigator.userAgent.toLowerCase()
      const screenReaderUA = ['nvda', 'jaws', 'sapi', 'guide', 'cmds', 'supernova', 'mad', 'thunder']
      const hasScreenReaderUA = screenReaderUA.some(sr => userAgent.includes(sr))
      
      // 2. ì ‘ê·¼ì„± API í™•ì¸
      const hasA11yAPIs = 'speechSynthesis' in window || 'webkitSpeechSynthesis' in window
      
      // 3. prefers-reduced-motion í™•ì¸ (ê°„ì ‘ ì§€í‘œ)
      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches
      
      return hasScreenReaderUA || hasA11yAPIs || prefersReducedMotion
    }
    
    setIsScreenReaderActive(detectScreenReader())
  }, [])
  
  const announce = useCallback((message: string, priority: 'polite' | 'assertive' = 'polite') => {
    if (!announceRef.current) return
    
    // Clear previous message
    announceRef.current.textContent = ''
    announceRef.current.setAttribute('aria-live', priority)
    
    // Add new message with slight delay
    setTimeout(() => {
      if (announceRef.current) {
        announceRef.current.textContent = message
      }
    }, 100)
  }, [])
  
  const announceNavigation = useCallback((from: string, to: string) => {
    announce(`Navigated from ${from} to ${to}`)
  }, [announce])
  
  const announceAction = useCallback((action: string, result?: string) => {
    const message = result ? `${action}. ${result}` : action
    announce(message, 'assertive')
  }, [announce])
  
  return {
    isScreenReaderActive,
    announce,
    announceNavigation,
    announceAction,
    announceRef
  }
}

// Live region component
export const LiveRegion: React.FC<{
  message: string
  level?: 'polite' | 'assertive'
  atomic?: boolean
}> = ({ message, level = 'polite', atomic = true }) => {
  return (
    <div
      aria-live={level}
      aria-atomic={atomic}
      className="sr-only"
      role="status"
    >
      {message}
    </div>
  )
}

// Screen reader only content
export const ScreenReaderOnly: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  return (
    <span className="sr-only">
      {children}
    </span>
  )
}
```

### **4. ìƒ‰ìƒ ë° ëŒ€ë¹„ ìµœì í™”**

**ìƒ‰ìƒ ì ‘ê·¼ì„± ê´€ë¦¬**
```typescript
// src/lib/accessibility/color-contrast.ts
import { TinyColor } from '@ctrl/tinycolor'

export class ColorContrastManager {
  // WCAG AA ê¸°ì¤€: 4.5:1 (ì¼ë°˜ í…ìŠ¤íŠ¸), 3:1 (ëŒ€í˜• í…ìŠ¤íŠ¸)
  // WCAG AAA ê¸°ì¤€: 7:1 (ì¼ë°˜ í…ìŠ¤íŠ¸), 4.5:1 (ëŒ€í˜• í…ìŠ¤íŠ¸)
  
  static calculateContrast(foreground: string, background: string): number {
    const fg = new TinyColor(foreground)
    const bg = new TinyColor(background)
    
    const fgLuminance = fg.getLuminance()
    const bgLuminance = bg.getLuminance()
    
    const lighter = Math.max(fgLuminance, bgLuminance)
    const darker = Math.min(fgLuminance, bgLuminance)
    
    return (lighter + 0.05) / (darker + 0.05)
  }
  
  static meetsWCAG_AA(foreground: string, background: string, isLargeText = false): boolean {
    const contrast = this.calculateContrast(foreground, background)
    return isLargeText ? contrast >= 3 : contrast >= 4.5
  }
  
  static meetsWCAG_AAA(foreground: string, background: string, isLargeText = false): boolean {
    const contrast = this.calculateContrast(foreground, background)
    return isLargeText ? contrast >= 4.5 : contrast >= 7
  }
  
  // ì¶©ë¶„í•œ ëŒ€ë¹„ë¥¼ ìœ„í•´ ìƒ‰ìƒ ì¡°ì •
  static adjustForContrast(
    foreground: string, 
    background: string, 
    targetRatio = 4.5
  ): string {
    let adjustedColor = new TinyColor(foreground)
    let currentRatio = this.calculateContrast(foreground, background)
    
    if (currentRatio >= targetRatio) {
      return foreground
    }
    
    const bgLuminance = new TinyColor(background).getLuminance()
    const shouldDarken = bgLuminance > 0.5
    
    let attempts = 0
    const maxAttempts = 100
    
    while (currentRatio < targetRatio && attempts < maxAttempts) {
      if (shouldDarken) {
        adjustedColor = adjustedColor.darken(2)
      } else {
        adjustedColor = adjustedColor.lighten(2)
      }
      
      currentRatio = this.calculateContrast(
        adjustedColor.toHexString(), 
        background
      )
      attempts++
    }
    
    return adjustedColor.toHexString()
  }
  
  // ìƒ‰ë§¹ ì‚¬ìš©ìë¥¼ ìœ„í•œ ìƒ‰ìƒ ì‹œë®¬ë ˆì´ì…˜
  static simulateColorBlindness(color: string, type: 'protanopia' | 'deuteranopia' | 'tritanopia'): string {
    const tinyColor = new TinyColor(color)
    const rgb = tinyColor.toRgb()
    
    let r = rgb.r / 255
    let g = rgb.g / 255
    let b = rgb.b / 255
    
    // ìƒ‰ë§¹ ë³€í™˜ ë§¤íŠ¸ë¦­ìŠ¤ ì ìš©
    switch (type) {
      case 'protanopia':
        // ì ìƒ‰ë§¹
        r = 0.567 * r + 0.433 * g
        g = 0.558 * r + 0.442 * g
        break
        
      case 'deuteranopia':
        // ë…¹ìƒ‰ë§¹
        r = 0.625 * r + 0.375 * g
        g = 0.7 * r + 0.3 * g
        break
        
      case 'tritanopia':
        // ì²­ìƒ‰ë§¹
        g = 0.95 * g + 0.05 * b
        b = 0.433 * g + 0.567 * b
        break
    }
    
    return new TinyColor({
      r: Math.round(r * 255),
      g: Math.round(g * 255),
      b: Math.round(b * 255)
    }).toHexString()
  }
}

// ì ‘ê·¼ì„± ìƒ‰ìƒ íŒ”ë ˆíŠ¸ ìƒì„±
export const generateAccessiblePalette = (baseColor: string) => {
  const base = new TinyColor(baseColor)
  
  return {
    // ê¸°ë³¸ ìƒ‰ìƒ
    50: base.lighten(45).desaturate(30).toHexString(),
    100: base.lighten(35).desaturate(20).toHexString(),
    200: base.lighten(25).desaturate(10).toHexString(),
    300: base.lighten(15).toHexString(),
    400: base.lighten(7).toHexString(),
    500: base.toHexString(), // ê¸°ì¤€ ìƒ‰ìƒ
    600: base.darken(7).toHexString(),
    700: base.darken(15).toHexString(),
    800: base.darken(25).saturate(10).toHexString(),
    900: base.darken(35).saturate(20).toHexString(),
    950: base.darken(45).saturate(30).toHexString(),
  }
}
```

### **5. ê³ ëŒ€ë¹„ ëª¨ë“œ ë° í…Œë§ˆ**

**ì ‘ê·¼ì„± í…Œë§ˆ ì‹œìŠ¤í…œ**
```typescript
// src/components/accessibility/AccessibilitySettings.tsx
import React from 'react'
import { useThemeStore } from '@/stores/themeStore'
import { ColorContrastManager } from '@/lib/accessibility/color-contrast'

export const AccessibilitySettings: React.FC = () => {
  const {
    highContrast,
    reducedMotion,
    fontSize,
    setHighContrast,
    setReducedMotion,
    setFontSize,
  } = useThemeStore()
  
  return (
    <div className="accessibility-settings space-y-6">
      <h2 className="text-lg font-semibold">ì ‘ê·¼ì„± ì„¤ì •</h2>
      
      {/* ê³ ëŒ€ë¹„ ëª¨ë“œ */}
      <div className="space-y-2">
        <div className="flex items-center justify-between">
          <div>
            <label htmlFor="high-contrast" className="font-medium">
              ê³ ëŒ€ë¹„ ëª¨ë“œ
            </label>
            <p className="text-sm text-muted-foreground">
              ë” ë†’ì€ ìƒ‰ìƒ ëŒ€ë¹„ë¡œ ê°€ë…ì„±ì„ í–¥ìƒì‹œí‚µë‹ˆë‹¤
            </p>
          </div>
          <Switch
            id="high-contrast"
            checked={highContrast}
            onCheckedChange={setHighContrast}
            aria-describedby="high-contrast-description"
          />
        </div>
        
        {/* ëŒ€ë¹„ ë¯¸ë¦¬ë³´ê¸° */}
        <ContrastPreview enabled={highContrast} />
      </div>
      
      {/* ì• ë‹ˆë©”ì´ì…˜ ì¤„ì´ê¸° */}
      <div className="space-y-2">
        <div className="flex items-center justify-between">
          <div>
            <label htmlFor="reduced-motion" className="font-medium">
              ì• ë‹ˆë©”ì´ì…˜ ì¤„ì´ê¸°
            </label>
            <p className="text-sm text-muted-foreground">
              ëª¨ì…˜ ë¯¼ê°ì„±ì´ ìˆëŠ” ê²½ìš° ì• ë‹ˆë©”ì´ì…˜ì„ ìµœì†Œí™”í•©ë‹ˆë‹¤
            </p>
          </div>
          <Switch
            id="reduced-motion"
            checked={reducedMotion}
            onCheckedChange={setReducedMotion}
          />
        </div>
      </div>
      
      {/* í°íŠ¸ í¬ê¸° */}
      <div className="space-y-2">
        <label className="font-medium">í°íŠ¸ í¬ê¸°</label>
        <div className="grid grid-cols-3 gap-2">
          {(['small', 'medium', 'large'] as const).map((size) => (
            <button
              key={size}
              onClick={() => setFontSize(size)}
              className={cn(
                "p-2 border rounded text-center",
                fontSize === size && "bg-primary text-primary-foreground"
              )}
              aria-pressed={fontSize === size}
            >
              <div className={cn(
                "font-medium",
                size === 'small' && "text-sm",
                size === 'medium' && "text-base",
                size === 'large' && "text-lg"
              )}>
                {size === 'small' && 'ì‘ê²Œ'}
                {size === 'medium' && 'ë³´í†µ'}
                {size === 'large' && 'í¬ê²Œ'}
              </div>
            </button>
          ))}
        </div>
      </div>
      
      {/* í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤ ì•ˆë‚´ */}
      <KeyboardShortcuts />
    </div>
  )
}

const ContrastPreview: React.FC<{ enabled: boolean }> = ({ enabled }) => {
  const textColor = enabled ? '#000000' : '#374151'
  const bgColor = enabled ? '#ffffff' : '#f9fafb'
  const primaryColor = enabled ? '#0000ff' : '#3b82f6'
  
  const contrast1 = ColorContrastManager.calculateContrast(textColor, bgColor)
  const contrast2 = ColorContrastManager.calculateContrast(primaryColor, bgColor)
  
  return (
    <div className="border rounded p-4" style={{ backgroundColor: bgColor }}>
      <p style={{ color: textColor }} className="mb-2">
        ì¼ë°˜ í…ìŠ¤íŠ¸ (ëŒ€ë¹„: {contrast1.toFixed(1)}:1)
      </p>
      <p style={{ color: primaryColor }} className="font-medium">
        ê°•ì¡° í…ìŠ¤íŠ¸ (ëŒ€ë¹„: {contrast2.toFixed(1)}:1)
      </p>
    </div>
  )
}

const KeyboardShortcuts: React.FC = () => {
  const shortcuts = [
    { key: 'Tab', description: 'ë‹¤ìŒ ìš”ì†Œë¡œ ì´ë™' },
    { key: 'Shift + Tab', description: 'ì´ì „ ìš”ì†Œë¡œ ì´ë™' },
    { key: 'í™”ì‚´í‘œ í‚¤', description: 'ìº˜ë¦°ë” ë‚ ì§œ ë„¤ë¹„ê²Œì´ì…˜' },
    { key: 'Enter / Space', description: 'ì„ íƒ ë˜ëŠ” í™œì„±í™”' },
    { key: 'Escape', description: 'ëª¨ë‹¬ ë‹«ê¸° ë˜ëŠ” ì·¨ì†Œ' },
    { key: 'Home / End', description: 'ì£¼ì˜ ì‹œì‘/ëìœ¼ë¡œ ì´ë™' },
    { key: 'Page Up/Down', description: 'ì›” ë„¤ë¹„ê²Œì´ì…˜' },
  ]
  
  return (
    <details className="space-y-2">
      <summary className="font-medium cursor-pointer">
        í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤ ì•ˆë‚´
      </summary>
      <div className="mt-2 space-y-2">
        {shortcuts.map((shortcut, index) => (
          <div key={index} className="flex justify-between text-sm">
            <kbd className="px-2 py-1 bg-muted rounded text-xs font-mono">
              {shortcut.key}
            </kbd>
            <span className="text-muted-foreground">{shortcut.description}</span>
          </div>
        ))}
      </div>
    </details>
  )
}
```

### **6. ë‹¤êµ­ì–´ ë° RTL ì§€ì›**

**êµ­ì œí™” ë° ë°©í–¥ ì§€ì›**
```typescript
// src/lib/accessibility/internationalization.ts
import { useRouter } from 'next/router'
import { useEffect } from 'react'

export const useInternationalization = () => {
  const router = useRouter()
  const { locale, locales, defaultLocale } = router
  
  // RTL ì–¸ì–´ ëª©ë¡
  const rtlLanguages = ['ar', 'he', 'fa', 'ur']
  const isRTL = rtlLanguages.includes(locale?.split('-')[0] || '')
  
  // ë¬¸ì„œ ë°©í–¥ ì„¤ì •
  useEffect(() => {
    document.dir = isRTL ? 'rtl' : 'ltr'
    document.lang = locale || defaultLocale || 'en'
  }, [locale, isRTL, defaultLocale])
  
  return {
    locale,
    locales,
    defaultLocale,
    isRTL,
    switchLocale: (newLocale: string) => {
      router.push(router.pathname, router.asPath, { locale: newLocale })
    }
  }
}

// RTL ëŒ€ì‘ ìŠ¤íƒ€ì¼ ìœ í‹¸ë¦¬í‹°
export const rtlStyles = {
  marginLeft: (value: string) => ({
    marginLeft: value,
    '[dir="rtl"] &': { marginRight: value, marginLeft: 'auto' }
  }),
  marginRight: (value: string) => ({
    marginRight: value,
    '[dir="rtl"] &': { marginLeft: value, marginRight: 'auto' }
  }),
  paddingLeft: (value: string) => ({
    paddingLeft: value,
    '[dir="rtl"] &': { paddingRight: value, paddingLeft: '0' }
  }),
  paddingRight: (value: string) => ({
    paddingRight: value,
    '[dir="rtl"] &': { paddingLeft: value, paddingRight: '0' }
  }),
  textAlign: (align: 'left' | 'right') => ({
    textAlign: align,
    '[dir="rtl"] &': { textAlign: align === 'left' ? 'right' : 'left' }
  }),
}
```

---

## ğŸ“Š **ì ‘ê·¼ì„± í…ŒìŠ¤íŠ¸**

### **ìë™í™”ëœ ì ‘ê·¼ì„± í…ŒìŠ¤íŠ¸**
```typescript
// src/lib/accessibility/testing.ts
import { axe, toHaveNoViolations } from 'jest-axe'

expect.extend(toHaveNoViolations)

export const runAccessibilityTests = async (element: HTMLElement) => {
  const results = await axe(element, {
    rules: {
      // WCAG AA ìˆ˜ì¤€ ê·œì¹™
      'color-contrast': { enabled: true },
      'focus-order-semantics': { enabled: true },
      'keyboard': { enabled: true },
      'label': { enabled: true },
      'region': { enabled: true },
    }
  })
  
  expect(results).toHaveNoViolations()
  
  return results
}

// í‚¤ë³´ë“œ ë„¤ë¹„ê²Œì´ì…˜ í…ŒìŠ¤íŠ¸
export const testKeyboardNavigation = (container: HTMLElement) => {
  const focusableElements = container.querySelectorAll(
    'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
  )
  
  // ëª¨ë“  focusable ìš”ì†Œê°€ í‚¤ë³´ë“œë¡œ ì ‘ê·¼ ê°€ëŠ¥í•œì§€ í™•ì¸
  focusableElements.forEach((element) => {
    expect(element).toHaveAttribute('tabindex')
    expect(parseInt(element.getAttribute('tabindex') || '0')).toBeGreaterThanOrEqual(0)
  })
}
```

---

## âœ… **Definition of Done**

### **ê¸°ëŠ¥ ìš”êµ¬ì‚¬í•­**
- [ ] ARIA ë ˆì´ë¸” ë° ì—­í•  ì™„ì „ êµ¬í˜„
- [ ] í‚¤ë³´ë“œ ì „ìš© ë„¤ë¹„ê²Œì´ì…˜ ì§€ì›
- [ ] ìŠ¤í¬ë¦° ë¦¬ë” ì™„ì „ ì§€ì›
- [ ] ê³ ëŒ€ë¹„ ëª¨ë“œ ë° ìƒ‰ìƒ ì ‘ê·¼ì„±
- [ ] ë‹¤êµ­ì–´ ë° RTL ì§€ì›

### **ê¸°ìˆ  ìš”êµ¬ì‚¬í•­**
- [ ] WCAG 2.1 AA ê¸°ì¤€ ì¤€ìˆ˜
- [ ] ìë™í™”ëœ ì ‘ê·¼ì„± í…ŒìŠ¤íŠ¸
- [ ] ì‹œë§¨í‹± HTML êµ¬ì¡°
- [ ] Focus trap ë° ê´€ë¦¬

### **ì‚¬ìš©ì„± ìš”êµ¬ì‚¬í•­**
- [ ] ëª¨ë“  ê¸°ëŠ¥ì— í‚¤ë³´ë“œ ì ‘ê·¼ ê°€ëŠ¥
- [ ] ëª…í™•í•œ í¬ì»¤ìŠ¤ ì¸ë””ì¼€ì´í„°
- [ ] ì¶©ë¶„í•œ í„°ì¹˜ íƒ€ê²Ÿ í¬ê¸° (44x44px)
- [ ] ì´í•´í•˜ê¸° ì‰¬ìš´ ì—ëŸ¬ ë©”ì‹œì§€

### **í…ŒìŠ¤íŠ¸ ìš”êµ¬ì‚¬í•­**
- [ ] axe-core ì ‘ê·¼ì„± í…ŒìŠ¤íŠ¸ í†µê³¼
- [ ] ìŠ¤í¬ë¦° ë¦¬ë” í…ŒìŠ¤íŠ¸ (NVDA, JAWS)
- [ ] í‚¤ë³´ë“œ ì „ìš© ë„¤ë¹„ê²Œì´ì…˜ í…ŒìŠ¤íŠ¸
- [ ] ìƒ‰ìƒ ëŒ€ë¹„ìœ¨ ê²€ì¦

---

## ğŸ“š **ê´€ë ¨ ë¬¸ì„œ ì°¸ì¡°**

- [11. Accessibility Implementation](../ui-architecture/11-accessibility-implementation.md)
- [05. Design System Foundations](../ui-architecture/05-design-system-foundations.md)
- [12. Monitoring & Testing](../ui-architecture/12-monitoring-testing.md)

---

**ì´ ìŠ¤í† ë¦¬ëŠ” ë°”ë¡œìº˜ë¦°ë”ì˜ ì ‘ê·¼ì„± êµ¬í˜„ì„ ìœ„í•œ ì¢…í•©ì ì¸ ê¸°ìˆ  ê°€ì´ë“œì…ë‹ˆë‹¤. ëª¨ë“  ì‚¬ìš©ìê°€ ì¥ì•  ì—¬ë¶€ì— ê´€ê³„ì—†ì´ ë™ë“±í•˜ê²Œ ì„œë¹„ìŠ¤ë¥¼ ì´ìš©í•  ìˆ˜ ìˆë„ë¡ í¬ìš©ì ì¸ ì‚¬ìš©ì ê²½í—˜ì„ ì œê³µí•©ë‹ˆë‹¤.**