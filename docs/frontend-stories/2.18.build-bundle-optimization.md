# Story 2.18: Build & Bundle Optimization Implementation

## ğŸ“‹ ë¬¸ì„œ ì •ë³´
- **ë¬¸ì„œ ë²„ì „**: 1.0
- **ì‘ì„±ì¼**: 2025-08-28
- **ì‘ì„±ì**: Frontend Team
- **í”„ë¡œì íŠ¸ëª…**: ë°”ë¡œìº˜ë¦°ë” (Baro Calendar)
- **ìƒíƒœ**: Active
- **ê´€ë ¨ ì•„í‚¤í…ì²˜ ë¬¸ì„œ**: [09-build-bundle-optimization.md](../ui-architecture/09-build-bundle-optimization.md)

---

## ğŸ¯ ìŠ¤í† ë¦¬ ëª©í‘œ

ë°”ë¡œìº˜ë¦°ë” ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ **ë¹Œë“œ ë° ë²ˆë“¤ ìµœì í™”**ë¥¼ êµ¬í˜„í•˜ì—¬ ì‚¬ìš©ìì—ê²Œ ë¹ ë¥¸ ì´ˆê¸° ë¡œë”©ê³¼ íš¨ìœ¨ì ì¸ ë¦¬ì†ŒìŠ¤ ì‚¬ìš©ì„ ì œê³µí•˜ë©°, ê°œë°œíŒ€ì—ê²ŒëŠ” ìµœì í™”ëœ ë°°í¬ íŒŒì´í”„ë¼ì¸ì„ ì œê³µí•œë‹¤.

### ì£¼ìš” êµ¬í˜„ ì‚¬í•­
- **ì§€ëŠ¥ì  ì½”ë“œ ìŠ¤í”Œë¦¬íŒ…** ë° ì²­í¬ ìµœì í™”
- **íŠ¸ë¦¬ ì…°ì´í‚¹** ë° ë°ë“œ ì½”ë“œ ì œê±°
- **ì´ë¯¸ì§€ ë° ë¯¸ë””ì–´ ìµœì í™”** íŒŒì´í”„ë¼ì¸
- **ì„œë¹„ìŠ¤ ì›Œì»¤ ê¸°ë°˜ ìºì‹±** ì „ëµ

---

## ğŸ‘¤ ì‚¬ìš©ì ìŠ¤í† ë¦¬

### US 2.18.1: ë¹ ë¥¸ ì´ˆê¸° ë¡œë”©
**As a** ì‚¬ìš©ì  
**I want** ë°”ë¡œìº˜ë¦°ë”ê°€ ìµœì†Œí•œì˜ íŒŒì¼ë§Œ ë¡œë“œí•˜ì—¬ ë¹ ë¥´ê²Œ ì‹œì‘ë˜ê¸°ë¥¼  
**So that** ë„¤íŠ¸ì›Œí¬ ìƒí™©ì— ê´€ê³„ì—†ì´ ì‹ ì†í•˜ê²Œ ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

**ì¸ìˆ˜ ì¡°ê±´:**
- [ ] ì´ˆê¸° JavaScript ë²ˆë“¤ í¬ê¸° < 250KB (gzipped)
- [ ] ì£¼ìš” CSS íŒŒì¼ í¬ê¸° < 50KB (gzipped)
- [ ] í°íŠ¸ ë° ì´ë¯¸ì§€ íŒŒì¼ ìµœì í™”ë¡œ ë¡œë”© ì‹œê°„ ë‹¨ì¶•
- [ ] ì½”ë“œ ìŠ¤í”Œë¦¬íŒ…ìœ¼ë¡œ í•„ìš”í•œ ì½”ë“œë§Œ ë¡œë“œ

### US 2.18.2: íš¨ìœ¨ì ì¸ ë¦¬ì†ŒìŠ¤ ê´€ë¦¬
**As a** ì‚¬ìš©ì  
**I want** ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ê¸°ëŠ¥ì˜ ì½”ë“œëŠ” ë¡œë“œí•˜ì§€ ì•Šê¸°ë¥¼  
**So that** ëª¨ë°”ì¼ ë°ì´í„°ë‚˜ ëŠë¦° ë„¤íŠ¸ì›Œí¬ì—ì„œë„ ì›í™œí•˜ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

**ì¸ìˆ˜ ì¡°ê±´:**
- [ ] íŠ¸ë¦¬ ì…°ì´í‚¹ìœ¼ë¡œ ë¯¸ì‚¬ìš© ì½”ë“œ ì™„ì „ ì œê±°
- [ ] ë¼ì´ë¸ŒëŸ¬ë¦¬ ì„ íƒì  ì„í¬íŠ¸ë¡œ ë²ˆë“¤ í¬ê¸° ìµœì†Œí™”
- [ ] ë™ì  ì„í¬íŠ¸ë¡œ í•„ìš” ì‹œì ì—ë§Œ ì½”ë“œ ë¡œë“œ
- [ ] ì¤‘ë³µ ì½”ë“œ ì œê±° ë° ì²­í¬ ìµœì í™”

### US 2.18.3: ìµœì í™”ëœ ë¯¸ë””ì–´ ì²˜ë¦¬
**As a** ì‚¬ìš©ì  
**I want** ì´ë¯¸ì§€ì™€ ë¯¸ë””ì–´ íŒŒì¼ì´ ë‚´ ë””ë°”ì´ìŠ¤ì— ë§ê²Œ ìµœì í™”ë˜ì–´ ë¡œë“œë˜ê¸°ë¥¼  
**So that** ë¹ ë¥¸ ë¡œë”©ê³¼ ë°ì´í„° ì ˆì•½ì„ ë™ì‹œì— ë‹¬ì„±í•  ìˆ˜ ìˆë‹¤.

**ì¸ìˆ˜ ì¡°ê±´:**
- [ ] WebP/AVIF í˜•ì‹ ì´ë¯¸ì§€ ìë™ ì œê³µ
- [ ] ë°˜ì‘í˜• ì´ë¯¸ì§€ë¡œ ë””ë°”ì´ìŠ¤ë³„ ìµœì í™”
- [ ] ì§€ì—° ë¡œë”©ìœ¼ë¡œ í•„ìš”í•œ ì´ë¯¸ì§€ë§Œ ë¡œë“œ
- [ ] ì´ë¯¸ì§€ ì••ì¶• ë° í¬ê¸° ìµœì í™”

### US 2.18.4: ì˜¤í”„ë¼ì¸ ì§€ì› ë° ìºì‹±
**As a** ì‚¬ìš©ì  
**I want** í•œ ë²ˆ ë¡œë“œí•œ ë¦¬ì†ŒìŠ¤ëŠ” ì˜¤í”„ë¼ì¸ì—ì„œë„ ì‚¬ìš©í•  ìˆ˜ ìˆê¸°ë¥¼  
**So that** ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì´ ë¶ˆì•ˆì •í•´ë„ ê¸°ë³¸ ê¸°ëŠ¥ì„ ê³„ì† ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

**ì¸ìˆ˜ ì¡°ê±´:**
- [ ] ì„œë¹„ìŠ¤ ì›Œì»¤ ê¸°ë°˜ ì˜¤í”„ë¼ì¸ ì§€ì›
- [ ] ì •ì  ë¦¬ì†ŒìŠ¤ íš¨ìœ¨ì  ìºì‹±
- [ ] ë„¤íŠ¸ì›Œí¬ ìš°ì„  + ìºì‹œ í´ë°± ì „ëµ
- [ ] ì˜¤í”„ë¼ì¸ ìƒíƒœì—ì„œ ê¸°ë³¸ ê¸°ëŠ¥ ì‚¬ìš© ê°€ëŠ¥

---

## ğŸ”§ ê¸°ìˆ ì  êµ¬í˜„ ìš”êµ¬ì‚¬í•­

### 1. Next.js ë²ˆë“¤ ìµœì í™” ì„¤ì •

**ì£¼ìš” íŒŒì¼**: `next.config.ts`

```typescript
// next.config.ts
import type { NextConfig } from 'next'
import { BundleAnalyzerPlugin } from 'webpack-bundle-analyzer'
import CompressionPlugin from 'compression-webpack-plugin'

const nextConfig: NextConfig = {
  // ì‹¤í—˜ì  ê¸°ëŠ¥ í™œìš©
  experimental: {
    // íŒ¨í‚¤ì§€ ì„í¬íŠ¸ ìµœì í™”
    optimizePackageImports: [
      'lucide-react',
      'date-fns',
      '@radix-ui/react-icons',
      'class-variance-authority'
    ],
    
    // Turbo ì„¤ì •
    turbo: {
      rules: {
        '*.svg': {
          loaders: ['@svgr/webpack'],
          as: '*.js',
        },
      },
    },
    
    // ì„œë²„ ì»´í¬ë„ŒíŠ¸ ë° ì•¡ì…˜ ìµœì í™”
    serverComponentsExternalPackages: ['sharp'],
  },
  
  // ì´ë¯¸ì§€ ìµœì í™” ì„¤ì •
  images: {
    formats: ['image/webp', 'image/avif'],
    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
    minimumCacheTTL: 31536000, // 1ë…„
    dangerouslyAllowSVG: true,
    contentSecurityPolicy: "default-src 'self'; script-src 'none'; sandbox;",
  },
  
  // ì›¹íŒ© ìµœì í™”
  webpack: (config, { dev, isServer, buildId }) => {
    // í”„ë¡œë•ì…˜ ë¹Œë“œì—ì„œë§Œ ìµœì í™” ì ìš©
    if (!dev && !isServer) {
      
      // ë²ˆë“¤ ë¶„ì„ê¸° (í™˜ê²½ ë³€ìˆ˜ë¡œ ì œì–´)
      if (process.env.ANALYZE === 'true') {
        config.plugins.push(
          new BundleAnalyzerPlugin({
            analyzerMode: 'static',
            reportFilename: '../analyze/bundle-report.html',
            openAnalyzer: false,
          })
        )
      }
      
      // ì••ì¶• í”ŒëŸ¬ê·¸ì¸
      config.plugins.push(
        new CompressionPlugin({
          algorithm: 'gzip',
          test: /\.(js|css|html|svg)$/,
          threshold: 8192,
          minRatio: 0.8,
        })
      )
      
      // ì½”ë“œ ìŠ¤í”Œë¦¬íŒ… ìµœì í™”
      config.optimization.splitChunks = {
        chunks: 'all',
        minSize: 20000,
        maxSize: 250000,
        cacheGroups: {
          // React ê´€ë ¨ ë¼ì´ë¸ŒëŸ¬ë¦¬
          react: {
            test: /[\\/]node_modules[\\/](react|react-dom|scheduler)[\\/]/,
            name: 'react-vendor',
            chunks: 'all',
            priority: 40,
            enforce: true,
          },
          
          // Next.js ì½”ì–´
          nextjs: {
            test: /[\\/]node_modules[\\/]next[\\/]/,
            name: 'nextjs-vendor',
            chunks: 'all',
            priority: 35,
            enforce: true,
          },
          
          // UI ë¼ì´ë¸ŒëŸ¬ë¦¬
          ui: {
            test: /[\\/]node_modules[\\/](@radix-ui|lucide-react|class-variance-authority)[\\/]/,
            name: 'ui-vendor',
            chunks: 'all',
            priority: 30,
          },
          
          // ë‚ ì§œ ë° ìœ í‹¸ë¦¬í‹° ë¼ì´ë¸ŒëŸ¬ë¦¬
          utils: {
            test: /[\\/]node_modules[\\/](date-fns|clsx|tailwind-merge)[\\/]/,
            name: 'utils-vendor',
            chunks: 'all',
            priority: 25,
          },
          
          // í¼ ê´€ë ¨ ë¼ì´ë¸ŒëŸ¬ë¦¬
          forms: {
            test: /[\\/]node_modules[\\/](react-hook-form|@hookform)[\\/]/,
            name: 'forms-vendor',
            chunks: 'all',
            priority: 20,
          },
          
          // ìº˜ë¦°ë” ê´€ë ¨ ì»´í¬ë„ŒíŠ¸
          calendar: {
            name: 'calendar-chunk',
            test: /[\\/]src[\\/]components[\\/]calendar[\\/]/,
            chunks: 'async',
            priority: 15,
            minChunks: 2,
          },
          
          // í”„ë¡œì íŠ¸ ê´€ë ¨ ì»´í¬ë„ŒíŠ¸
          projects: {
            name: 'projects-chunk',
            test: /[\\/]src[\\/]components[\\/]projects[\\/]/,
            chunks: 'async',
            priority: 15,
            minChunks: 2,
          },
          
          // ê¸°íƒ€ ë²¤ë” ë¼ì´ë¸ŒëŸ¬ë¦¬
          vendor: {
            test: /[\\/]node_modules[\\/]/,
            name: 'vendors',
            chunks: 'all',
            priority: 10,
          },
          
          // ê³µí†µ ëª¨ë“ˆ
          common: {
            name: 'common',
            minChunks: 2,
            chunks: 'all',
            priority: 5,
            reuseExistingChunk: true,
          },
        },
      }
      
      // ëª¨ë“ˆ ì—°ê²° ìµœì í™”
      config.optimization.concatenateModules = true
      
      // ì‚¬ì´ë“œ ì´í™íŠ¸ ìµœì í™”
      config.optimization.sideEffects = false
    }
    
    // SVG ìµœì í™”
    config.module.rules.push({
      test: /\.svg$/i,
      issuer: /\.[jt]sx?$/,
      use: ['@svgr/webpack'],
    })
    
    return config
  },
  
  // ì»´íŒŒì¼ëŸ¬ ìµœì í™”
  compiler: {
    removeConsole: process.env.NODE_ENV === 'production',
  },
  
  // ì •ì  íŒŒì¼ ìµœì í™”
  assetPrefix: process.env.CDN_URL || '',
  
  // ì„±ëŠ¥ ì„¤ì •
  onDemandEntries: {
    maxInactiveAge: 25 * 1000,
    pagesBufferLength: 2,
  },
  
  // HTTP í—¤ë” ìµœì í™”
  async headers() {
    return [
      {
        source: '/(.*)\\.(js|css|woff2|woff|png|jpg|jpeg|webp|avif|svg|ico)',
        headers: [
          {
            key: 'Cache-Control',
            value: 'public, max-age=31536000, immutable',
          },
        ],
      },
      {
        source: '/(.*)',
        headers: [
          {
            key: 'X-DNS-Prefetch-Control',
            value: 'on',
          },
        ],
      },
    ]
  },
}

export default nextConfig
```

### 2. íŠ¸ë¦¬ ì…°ì´í‚¹ ìµœì í™” ì‹œìŠ¤í…œ

**ì£¼ìš” íŒŒì¼**: `src/lib/utils/tree-shaking.ts`

```typescript
// src/lib/utils/tree-shaking.ts

// âœ… ì˜¬ë°”ë¥¸ ì„ íƒì  ì„í¬íŠ¸ íŒ¨í„´
export const optimizedImports = {
  // ë‚ ì§œ ìœ í‹¸ë¦¬í‹° ì„ íƒì  ì„í¬íŠ¸
  dateUtils: {
    // âœ… ì¢‹ì€ ì˜ˆ
    good: () => import('date-fns/format'),
    format: () => import('date-fns/format'),
    parseISO: () => import('date-fns/parseISO'),
    isValid: () => import('date-fns/isValid'),
    
    // âŒ ë‚˜ìœ ì˜ˆ (ì „ì²´ ì„í¬íŠ¸)
    // bad: () => import('date-fns'),
  },
  
  // ì•„ì´ì½˜ ì„ íƒì  ì„í¬íŠ¸
  icons: {
    Calendar: () => import('lucide-react/dist/esm/icons/calendar'),
    Plus: () => import('lucide-react/dist/esm/icons/plus'),
    Settings: () => import('lucide-react/dist/esm/icons/settings'),
    User: () => import('lucide-react/dist/esm/icons/user'),
  },
  
  // UI ì»´í¬ë„ŒíŠ¸ ì„ íƒì  ì„í¬íŠ¸
  ui: {
    Button: () => import('@/components/ui/Button'),
    Dialog: () => import('@/components/ui/Dialog'),
    Card: () => import('@/components/ui/Card'),
    Input: () => import('@/components/ui/Input'),
  },
}

// ë™ì  ì„í¬íŠ¸ í—¬í¼
export const createLazyLoader = <T>(
  importFn: () => Promise<{ default: T }>,
  fallback?: T
) => {
  let cached: T | null = null
  let loading: Promise<T> | null = null
  
  return {
    load: async (): Promise<T> => {
      if (cached) return cached
      
      if (!loading) {
        loading = importFn().then(module => {
          cached = module.default
          loading = null
          return cached
        }).catch(error => {
          loading = null
          if (fallback) {
            cached = fallback
            return fallback
          }
          throw error
        })
      }
      
      return loading
    },
    
    preload: () => {
      if (!cached && !loading) {
        loading = importFn().then(module => {
          cached = module.default
          loading = null
          return cached
        }).catch(() => {
          loading = null
          return null
        })
      }
    },
    
    get cached() {
      return cached
    },
  }
}

// ë²ˆë“¤ ë¶„ì„ ìœ í‹¸ë¦¬í‹°
export class BundleAnalyzer {
  private static importSizes = new Map<string, number>()
  
  static trackImport(name: string, size: number) {
    this.importSizes.set(name, size)
  }
  
  static getImportStats() {
    return Array.from(this.importSizes.entries())
      .sort(([, a], [, b]) => b - a)
      .map(([name, size]) => ({
        name,
        size: `${(size / 1024).toFixed(2)}KB`,
        percentage: `${((size / this.getTotalSize()) * 100).toFixed(1)}%`,
      }))
  }
  
  private static getTotalSize() {
    return Array.from(this.importSizes.values())
      .reduce((total, size) => total + size, 0)
  }
  
  static generateReport() {
    const stats = this.getImportStats()
    const report = {
      totalImports: stats.length,
      totalSize: `${(this.getTotalSize() / 1024).toFixed(2)}KB`,
      largestImports: stats.slice(0, 10),
      recommendations: this.generateRecommendations(stats),
    }
    
    if (process.env.NODE_ENV === 'development') {
      console.table(stats)
      console.log('Bundle Analysis Report:', report)
    }
    
    return report
  }
  
  private static generateRecommendations(stats: any[]) {
    const recommendations = []
    
    const largeImports = stats.filter(stat => parseInt(stat.size) > 50)
    if (largeImports.length > 0) {
      recommendations.push('Consider code splitting for large imports')
    }
    
    const duplicatePatterns = this.findDuplicatePatterns(stats)
    if (duplicatePatterns.length > 0) {
      recommendations.push('Potential duplicate imports detected')
    }
    
    return recommendations
  }
  
  private static findDuplicatePatterns(stats: any[]) {
    const patterns = new Map<string, number>()
    
    stats.forEach(({ name }) => {
      const pattern = name.split('/')[0] // íŒ¨í‚¤ì§€ëª… ì¶”ì¶œ
      patterns.set(pattern, (patterns.get(pattern) || 0) + 1)
    })
    
    return Array.from(patterns.entries())
      .filter(([, count]) => count > 3)
      .map(([pattern]) => pattern)
  }
}

// ì‚¬ì´ë“œ ì´í™íŠ¸ ìµœì í™”ë¥¼ ìœ„í•œ pure í•¨ìˆ˜ë“¤
export const pureFunctions = {
  // ìˆœìˆ˜ í•¨ìˆ˜ë¡œ ë§ˆí‚¹í•˜ì—¬ íŠ¸ë¦¬ ì…°ì´í‚¹ ìµœì í™”
  /*#__PURE__*/ formatDate: (date: Date, format: string) => {
    // ì™¸ë¶€ ì˜ì¡´ì„± ì—†ëŠ” ìˆœìˆ˜ í•¨ìˆ˜
    return date.toISOString()
  },
  
  /*#__PURE__*/ calculateDays: (start: Date, end: Date) => {
    const diffTime = Math.abs(end.getTime() - start.getTime())
    return Math.ceil(diffTime / (1000 * 60 * 60 * 24))
  },
  
  /*#__PURE__*/ generateId: () => {
    return Math.random().toString(36).substr(2, 9)
  },
}
```

### 3. ì´ë¯¸ì§€ ìµœì í™” íŒŒì´í”„ë¼ì¸

**ì£¼ìš” íŒŒì¼**: `src/components/ui/OptimizedImage.tsx`

```typescript
// src/components/ui/OptimizedImage.tsx
import React, { useState, useCallback, useRef } from 'react'
import Image from 'next/image'
import { cn } from '@/lib/utils'

interface OptimizedImageProps {
  src: string
  alt: string
  width: number
  height: number
  className?: string
  priority?: boolean
  quality?: number
  placeholder?: 'blur' | 'empty'
  blurDataURL?: string
  sizes?: string
  fill?: boolean
  objectFit?: 'cover' | 'contain' | 'fill' | 'none' | 'scale-down'
  loading?: 'lazy' | 'eager'
  onLoad?: () => void
  onError?: () => void
}

// ì´ë¯¸ì§€ í”Œë ˆì´ìŠ¤í™€ë” ìƒì„±
const generateBlurDataURL = (width: number, height: number): string => {
  const canvas = document.createElement('canvas')
  canvas.width = width
  canvas.height = height
  
  const ctx = canvas.getContext('2d')
  if (!ctx) return ''
  
  // ê·¸ë¼ë°ì´ì…˜ í”Œë ˆì´ìŠ¤í™€ë”
  const gradient = ctx.createLinearGradient(0, 0, width, height)
  gradient.addColorStop(0, '#f3f4f6')
  gradient.addColorStop(1, '#e5e7eb')
  
  ctx.fillStyle = gradient
  ctx.fillRect(0, 0, width, height)
  
  return canvas.toDataURL()
}

export const OptimizedImage: React.FC<OptimizedImageProps> = ({
  src,
  alt,
  width,
  height,
  className,
  priority = false,
  quality = 85,
  placeholder = 'blur',
  blurDataURL,
  sizes,
  fill = false,
  objectFit = 'cover',
  loading = 'lazy',
  onLoad,
  onError,
}) => {
  const [isLoading, setIsLoading] = useState(true)
  const [hasError, setHasError] = useState(false)
  const [actualSrc, setActualSrc] = useState(src)
  const imgRef = useRef<HTMLImageElement>(null)
  
  // ì´ë¯¸ì§€ ë¡œë“œ ì™„ë£Œ ì²˜ë¦¬
  const handleLoad = useCallback(() => {
    setIsLoading(false)
    onLoad?.()
  }, [onLoad])
  
  // ì´ë¯¸ì§€ ì—ëŸ¬ ì²˜ë¦¬
  const handleError = useCallback(() => {
    setHasError(true)
    setIsLoading(false)
    
    // í´ë°± ì´ë¯¸ì§€ ì‹œë„
    if (actualSrc !== '/images/placeholder.webp') {
      setActualSrc('/images/placeholder.webp')
      return
    }
    
    onError?.()
  }, [actualSrc, onError])
  
  // ì—ëŸ¬ ìƒíƒœ ë Œë”ë§
  if (hasError && actualSrc === '/images/placeholder.webp') {
    return (
      <div
        className={cn(
          'flex items-center justify-center bg-muted text-muted-foreground border border-border rounded-md',
          className
        )}
        style={{ width, height }}
      >
        <div className="text-center p-4">
          <div className="w-8 h-8 mx-auto mb-2 opacity-50">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
              <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
              <circle cx="8.5" cy="8.5" r="1.5"/>
              <polyline points="21,15 16,10 5,21"/>
            </svg>
          </div>
          <span className="text-xs">ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨</span>
        </div>
      </div>
    )
  }
  
  // ê¸°ë³¸ ë¸”ëŸ¬ ë°ì´í„° URL ìƒì„±
  const defaultBlurDataURL = blurDataURL || (
    typeof window !== 'undefined' && placeholder === 'blur'
      ? generateBlurDataURL(width, height)
      : undefined
  )
  
  return (
    <div className={cn('relative overflow-hidden', className)}>
      <Image
        ref={imgRef}
        src={actualSrc}
        alt={alt}
        width={fill ? undefined : width}
        height={fill ? undefined : height}
        fill={fill}
        className={cn(
          'transition-opacity duration-300',
          isLoading ? 'opacity-0' : 'opacity-100',
          fill ? `object-${objectFit}` : ''
        )}
        style={!fill ? { objectFit } : undefined}
        priority={priority}
        quality={quality}
        placeholder={placeholder}
        blurDataURL={defaultBlurDataURL}
        sizes={sizes}
        loading={loading}
        onLoad={handleLoad}
        onError={handleError}
      />
      
      {/* ë¡œë”© ìŠ¤ì¼ˆë ˆí†¤ */}
      {isLoading && !hasError && (
        <div
          className="absolute inset-0 bg-muted animate-pulse flex items-center justify-center"
          style={{ width: fill ? '100%' : width, height: fill ? '100%' : height }}
        >
          <div className="w-6 h-6 text-muted-foreground opacity-50">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
              <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
              <circle cx="8.5" cy="8.5" r="1.5"/>
              <polyline points="21,15 16,10 5,21"/>
            </svg>
          </div>
        </div>
      )}
    </div>
  )
}

// ë°˜ì‘í˜• ì´ë¯¸ì§€ ì»´í¬ë„ŒíŠ¸
interface ResponsiveImageProps extends Omit<OptimizedImageProps, 'width' | 'height' | 'sizes'> {
  aspectRatio: number // width/height
  maxWidth?: number
  breakpoints?: {
    sm?: number
    md?: number
    lg?: number
    xl?: number
  }
}

export const ResponsiveImage: React.FC<ResponsiveImageProps> = ({
  aspectRatio,
  maxWidth = 1920,
  breakpoints = { sm: 640, md: 768, lg: 1024, xl: 1280 },
  ...props
}) => {
  // sizes ì†ì„± ìë™ ìƒì„±
  const sizes = Object.entries(breakpoints)
    .reverse() // í° í¬ê¸°ë¶€í„°
    .map(([key, value]) => `(min-width: ${value}px) ${maxWidth}px`)
    .concat([`${maxWidth}px`])
    .join(', ')
  
  return (
    <div className="relative w-full" style={{ aspectRatio: aspectRatio }}>
      <OptimizedImage
        {...props}
        fill
        sizes={sizes}
        className="w-full h-full"
      />
    </div>
  )
}

// ì§€ì—° ë¡œë”© ì´ë¯¸ì§€ ì»´í¬ë„ŒíŠ¸
export const LazyImage: React.FC<OptimizedImageProps> = (props) => {
  const [isInView, setIsInView] = useState(false)
  const imgRef = useRef<HTMLDivElement>(null)
  
  // Intersection Observerë¥¼ ì‚¬ìš©í•œ ì§€ì—° ë¡œë”©
  React.useEffect(() => {
    if (!imgRef.current) return
    
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setIsInView(true)
          observer.disconnect()
        }
      },
      {
        rootMargin: '50px', // 50px ì „ì— ë¯¸ë¦¬ ë¡œë“œ
        threshold: 0.1,
      }
    )
    
    observer.observe(imgRef.current)
    
    return () => observer.disconnect()
  }, [])
  
  if (!isInView) {
    return (
      <div
        ref={imgRef}
        className={cn('bg-muted animate-pulse', props.className)}
        style={{ width: props.width, height: props.height }}
      />
    )
  }
  
  return <OptimizedImage {...props} />
}
```

### 4. ì„œë¹„ìŠ¤ ì›Œì»¤ ë° ìºì‹± ì „ëµ

**ì£¼ìš” íŒŒì¼**: `public/sw.js`

```javascript
// public/sw.js
const CACHE_NAME = 'baro-calendar-v2'
const STATIC_CACHE = 'baro-static-v2'
const DYNAMIC_CACHE = 'baro-dynamic-v2'
const IMAGE_CACHE = 'baro-images-v2'

// ìºì‹œí•  ì •ì  ìì›
const STATIC_ASSETS = [
  '/',
  '/calendar',
  '/projects',
  '/manifest.json',
  '/offline.html',
]

// ìºì‹œ ì „ëµ
const CACHE_STRATEGIES = {
  // ì •ì  ìì›: ìºì‹œ ìš°ì„ 
  static: ['/_next/static/', '/static/', '.css', '.js', '.woff2', '.woff'],
  // ì´ë¯¸ì§€: ìºì‹œ ìš°ì„ , ì˜¤ë˜ëœ ê²ƒ í—ˆìš©
  images: ['.jpg', '.jpeg', '.png', '.webp', '.avif', '.svg'],
  // API: ë„¤íŠ¸ì›Œí¬ ìš°ì„ , ìºì‹œ í´ë°±
  api: ['/api/'],
  // HTML: ë„¤íŠ¸ì›Œí¬ ìš°ì„ 
  html: ['.html', '/'],
}

// ì„¤ì¹˜ ì´ë²¤íŠ¸
self.addEventListener('install', (event) => {
  console.log('[SW] Install event')
  
  event.waitUntil(
    caches.open(STATIC_CACHE)
      .then((cache) => {
        console.log('[SW] Caching static assets')
        return cache.addAll(STATIC_ASSETS)
      })
      .then(() => {
        // ì¦‰ì‹œ í™œì„±í™”
        return self.skipWaiting()
      })
  )
})

// í™œì„±í™” ì´ë²¤íŠ¸
self.addEventListener('activate', (event) => {
  console.log('[SW] Activate event')
  
  event.waitUntil(
    caches.keys()
      .then((cacheNames) => {
        return Promise.all(
          cacheNames
            .filter((cacheName) => {
              // í˜„ì¬ ë²„ì „ì´ ì•„ë‹Œ ìºì‹œ ì‚­ì œ
              return ![CACHE_NAME, STATIC_CACHE, DYNAMIC_CACHE, IMAGE_CACHE].includes(cacheName)
            })
            .map((cacheName) => {
              console.log('[SW] Deleting old cache:', cacheName)
              return caches.delete(cacheName)
            })
        )
      })
      .then(() => {
        // ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ë¥¼ ì¦‰ì‹œ ì œì–´
        return self.clients.claim()
      })
  )
})

// ìš”ì²­ ê°€ë¡œì±„ê¸°
self.addEventListener('fetch', (event) => {
  const { request } = event
  const url = new URL(request.url)
  
  // Chrome extension ìš”ì²­ ë¬´ì‹œ
  if (url.protocol === 'chrome-extension:') {
    return
  }
  
  // HTTPSê°€ ì•„ë‹Œ ìš”ì²­ ë¬´ì‹œ
  if (url.protocol !== 'https:' && url.hostname !== 'localhost') {
    return
  }
  
  event.respondWith(handleRequest(request))
})

// ìš”ì²­ ì²˜ë¦¬ í•¨ìˆ˜
async function handleRequest(request) {
  const url = new URL(request.url)
  
  // API ìš”ì²­ ì²˜ë¦¬
  if (isAPIRequest(url)) {
    return handleAPIRequest(request)
  }
  
  // ì´ë¯¸ì§€ ìš”ì²­ ì²˜ë¦¬
  if (isImageRequest(url)) {
    return handleImageRequest(request)
  }
  
  // ì •ì  ìì› ì²˜ë¦¬
  if (isStaticAsset(url)) {
    return handleStaticAsset(request)
  }
  
  // HTML í˜ì´ì§€ ì²˜ë¦¬
  return handleHTMLRequest(request)
}

// API ìš”ì²­ ì²˜ë¦¬ (ë„¤íŠ¸ì›Œí¬ ìš°ì„ )
async function handleAPIRequest(request) {
  try {
    // ë„¤íŠ¸ì›Œí¬ ìš”ì²­ ì‹œë„
    const response = await fetch(request)
    
    // ì„±ê³µí•œ GET ìš”ì²­ë§Œ ìºì‹œ
    if (response.ok && request.method === 'GET') {
      const cache = await caches.open(DYNAMIC_CACHE)
      cache.put(request, response.clone())
    }
    
    return response
  } catch (error) {
    // ë„¤íŠ¸ì›Œí¬ ì‹¤íŒ¨ ì‹œ ìºì‹œì—ì„œ ì‘ë‹µ
    console.log('[SW] Network failed for API, trying cache:', request.url)
    
    const cachedResponse = await caches.match(request)
    if (cachedResponse) {
      return cachedResponse
    }
    
    // ì˜¤í”„ë¼ì¸ ì‘ë‹µ
    return new Response(
      JSON.stringify({ error: 'Offline', message: 'ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì„ í™•ì¸í•´ì£¼ì„¸ìš”' }),
      {
        status: 503,
        headers: { 'Content-Type': 'application/json' }
      }
    )
  }
}

// ì´ë¯¸ì§€ ìš”ì²­ ì²˜ë¦¬ (ìºì‹œ ìš°ì„ )
async function handleImageRequest(request) {
  const cache = await caches.open(IMAGE_CACHE)
  const cachedResponse = await cache.match(request)
  
  if (cachedResponse) {
    // ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì—…ë°ì´íŠ¸ í™•ì¸
    fetch(request).then((response) => {
      if (response.ok) {
        cache.put(request, response.clone())
      }
    }).catch(() => {
      // ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ ë¬´ì‹œ
    })
    
    return cachedResponse
  }
  
  try {
    const response = await fetch(request)
    
    if (response.ok) {
      cache.put(request, response.clone())
    }
    
    return response
  } catch (error) {
    // í”Œë ˆì´ìŠ¤í™€ë” ì´ë¯¸ì§€ ë°˜í™˜
    return new Response(
      generatePlaceholderImage(),
      {
        headers: { 'Content-Type': 'image/svg+xml' }
      }
    )
  }
}

// ì •ì  ìì› ì²˜ë¦¬ (ìºì‹œ ìš°ì„ )
async function handleStaticAsset(request) {
  const cachedResponse = await caches.match(request)
  
  if (cachedResponse) {
    return cachedResponse
  }
  
  try {
    const response = await fetch(request)
    
    if (response.ok) {
      const cache = await caches.open(STATIC_CACHE)
      cache.put(request, response.clone())
    }
    
    return response
  } catch (error) {
    console.log('[SW] Failed to fetch static asset:', request.url)
    throw error
  }
}

// HTML ìš”ì²­ ì²˜ë¦¬ (ë„¤íŠ¸ì›Œí¬ ìš°ì„ )
async function handleHTMLRequest(request) {
  try {
    return await fetch(request)
  } catch (error) {
    // ì˜¤í”„ë¼ì¸ í˜ì´ì§€ ë°˜í™˜
    const offlinePage = await caches.match('/offline.html')
    return offlinePage || new Response(
      '<h1>ì˜¤í”„ë¼ì¸ ìƒíƒœì…ë‹ˆë‹¤</h1><p>ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì„ í™•ì¸í•´ì£¼ì„¸ìš”.</p>',
      {
        headers: { 'Content-Type': 'text/html' }
      }
    )
  }
}

// ìš”ì²­ íƒ€ì… íŒë³„ í•¨ìˆ˜ë“¤
function isAPIRequest(url) {
  return CACHE_STRATEGIES.api.some(pattern => url.pathname.includes(pattern))
}

function isImageRequest(url) {
  return CACHE_STRATEGIES.images.some(ext => url.pathname.endsWith(ext))
}

function isStaticAsset(url) {
  return CACHE_STRATEGIES.static.some(pattern => 
    url.pathname.includes(pattern) || url.pathname.endsWith(pattern)
  )
}

// í”Œë ˆì´ìŠ¤í™€ë” ì´ë¯¸ì§€ ìƒì„±
function generatePlaceholderImage() {
  return `
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
      <rect width="100%" height="100%" fill="#f3f4f6"/>
      <text x="50%" y="50%" text-anchor="middle" dy="0.3em" fill="#9ca3af" font-family="sans-serif" font-size="16">
        ì´ë¯¸ì§€ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤
      </text>
    </svg>
  `
}

// ë©”ì‹œì§€ ì²˜ë¦¬
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting()
  }
  
  if (event.data && event.data.type === 'GET_CACHE_SIZE') {
    getCacheSize().then(size => {
      event.ports[0].postMessage({ cacheSize: size })
    })
  }
})

// ìºì‹œ í¬ê¸° ê³„ì‚°
async function getCacheSize() {
  const cacheNames = await caches.keys()
  let totalSize = 0
  
  for (const cacheName of cacheNames) {
    const cache = await caches.open(cacheName)
    const requests = await cache.keys()
    
    for (const request of requests) {
      const response = await cache.match(request)
      if (response) {
        const blob = await response.blob()
        totalSize += blob.size
      }
    }
  }
  
  return totalSize
}
```

### 5. ë²ˆë“¤ ë¶„ì„ ë° ìµœì í™” ë„êµ¬

**ì£¼ìš” íŒŒì¼**: `scripts/analyze-bundle.ts`

```typescript
// scripts/analyze-bundle.ts
import fs from 'fs'
import path from 'path'
import { gzipSync } from 'zlib'
import { execSync } from 'child_process'

interface BundleStats {
  totalSize: number
  gzippedSize: number
  assets: BundleAsset[]
  chunks: BundleChunk[]
  recommendations: string[]
}

interface BundleAsset {
  name: string
  size: number
  gzippedSize: number
  type: 'js' | 'css' | 'image' | 'font' | 'other'
}

interface BundleChunk {
  name: string
  size: number
  files: string[]
  isInitial: boolean
}

export class BundleAnalyzer {
  private buildPath: string
  private thresholds = {
    initialBundleSize: 250 * 1024, // 250KB
    chunkSize: 100 * 1024, // 100KB
    assetSize: 50 * 1024, // 50KB
  }
  
  constructor(buildPath = '.next') {
    this.buildPath = path.join(process.cwd(), buildPath)
  }
  
  async analyze(): Promise<BundleStats> {
    console.log('ğŸ” Analyzing bundle...')
    
    const assets = await this.analyzeAssets()
    const chunks = await this.analyzeChunks()
    
    const totalSize = assets.reduce((sum, asset) => sum + asset.size, 0)
    const gzippedSize = assets.reduce((sum, asset) => sum + asset.gzippedSize, 0)
    
    const recommendations = this.generateRecommendations(assets, chunks)
    
    const stats: BundleStats = {
      totalSize,
      gzippedSize,
      assets,
      chunks,
      recommendations,
    }
    
    this.printReport(stats)
    await this.saveReport(stats)
    
    return stats
  }
  
  private async analyzeAssets(): Promise<BundleAsset[]> {
    const staticPath = path.join(this.buildPath, 'static')
    
    if (!fs.existsSync(staticPath)) {
      throw new Error('Build directory not found. Run `npm run build` first.')
    }
    
    const assets: BundleAsset[] = []
    
    const scanDir = (dir: string) => {
      const entries = fs.readdirSync(dir)
      
      for (const entry of entries) {
        const fullPath = path.join(dir, entry)
        const stat = fs.statSync(fullPath)
        
        if (stat.isDirectory()) {
          scanDir(fullPath)
        } else {
          const content = fs.readFileSync(fullPath)
          const gzippedContent = gzipSync(content)
          
          assets.push({
            name: path.relative(this.buildPath, fullPath),
            size: content.length,
            gzippedSize: gzippedContent.length,
            type: this.getAssetType(fullPath),
          })
        }
      }
    }
    
    scanDir(staticPath)
    
    return assets.sort((a, b) => b.gzippedSize - a.gzippedSize)
  }
  
  private async analyzeChunks(): Promise<BundleChunk[]> {
    // Next.js build í†µê³„ íŒŒì¼ ì½ê¸°
    const buildManifestPath = path.join(this.buildPath, 'build-manifest.json')
    
    if (!fs.existsSync(buildManifestPath)) {
      return []
    }
    
    const buildManifest = JSON.parse(fs.readFileSync(buildManifestPath, 'utf8'))
    const chunks: BundleChunk[] = []
    
    // í˜ì´ì§€ë³„ ì²­í¬ ë¶„ì„
    for (const [page, files] of Object.entries(buildManifest.pages)) {
      const chunkFiles = files as string[]
      const chunkSize = chunkFiles.reduce((sum, file) => {
        const fullPath = path.join(this.buildPath, 'static', file)
        
        if (fs.existsSync(fullPath)) {
          return sum + fs.statSync(fullPath).size
        }
        
        return sum
      }, 0)
      
      chunks.push({
        name: page,
        size: chunkSize,
        files: chunkFiles,
        isInitial: page === '/_app' || page === '/index',
      })
    }
    
    return chunks.sort((a, b) => b.size - a.size)
  }
  
  private getAssetType(filePath: string): BundleAsset['type'] {
    const ext = path.extname(filePath)
    
    switch (ext) {
      case '.js':
        return 'js'
      case '.css':
        return 'css'
      case '.jpg':
      case '.jpeg':
      case '.png':
      case '.webp':
      case '.avif':
      case '.svg':
        return 'image'
      case '.woff':
      case '.woff2':
      case '.ttf':
        return 'font'
      default:
        return 'other'
    }
  }
  
  private generateRecommendations(assets: BundleAsset[], chunks: BundleChunk[]): string[] {
    const recommendations: string[] = []
    
    // ì´ˆê¸° ë²ˆë“¤ í¬ê¸° ì²´í¬
    const initialChunks = chunks.filter(chunk => chunk.isInitial)
    const initialSize = initialChunks.reduce((sum, chunk) => sum + chunk.size, 0)
    
    if (initialSize > this.thresholds.initialBundleSize) {
      recommendations.push(`Initial bundle size (${(initialSize / 1024).toFixed(2)}KB) exceeds threshold. Consider code splitting.`)
    }
    
    // í° ì²­í¬ ì‹ë³„
    const largeChunks = chunks.filter(chunk => chunk.size > this.thresholds.chunkSize)
    if (largeChunks.length > 0) {
      recommendations.push(`Found ${largeChunks.length} large chunks. Consider further splitting.`)
    }
    
    // í° ìì‚° ì‹ë³„
    const largeAssets = assets.filter(asset => asset.gzippedSize > this.thresholds.assetSize)
    if (largeAssets.length > 0) {
      recommendations.push(`Found ${largeAssets.length} large assets. Consider optimization.`)
    }
    
    // ì¤‘ë³µ ë¼ì´ë¸ŒëŸ¬ë¦¬ ê°ì§€
    const jsAssets = assets.filter(asset => asset.type === 'js')
    const duplicateLibs = this.findDuplicateLibraries(jsAssets)
    if (duplicateLibs.length > 0) {
      recommendations.push(`Potential duplicate libraries: ${duplicateLibs.join(', ')}`)
    }
    
    // ì´ë¯¸ì§€ ìµœì í™”
    const unoptimizedImages = assets.filter(asset => 
      asset.type === 'image' && 
      !asset.name.includes('.webp') && 
      !asset.name.includes('.avif')
    )
    if (unoptimizedImages.length > 0) {
      recommendations.push(`${unoptimizedImages.length} images could be converted to WebP/AVIF`)
    }
    
    return recommendations
  }
  
  private findDuplicateLibraries(jsAssets: BundleAsset[]): string[] {
    const libCounts = new Map<string, number>()
    
    jsAssets.forEach(asset => {
      // ë¼ì´ë¸ŒëŸ¬ë¦¬ëª… ì¶”ì¶œ ì‹œë„
      const matches = asset.name.match(/webpack\/(.+?)\./)
      if (matches && matches[1]) {
        const lib = matches[1].split('-')[0]
        libCounts.set(lib, (libCounts.get(lib) || 0) + 1)
      }
    })
    
    return Array.from(libCounts.entries())
      .filter(([, count]) => count > 1)
      .map(([lib]) => lib)
  }
  
  private printReport(stats: BundleStats) {
    console.log('\nğŸ“Š Bundle Analysis Report\n')
    
    // ì´ í¬ê¸°
    console.log(`Total Size: ${(stats.totalSize / 1024 / 1024).toFixed(2)}MB`)
    console.log(`Gzipped: ${(stats.gzippedSize / 1024 / 1024).toFixed(2)}MB`)
    console.log(`Compression: ${(((stats.totalSize - stats.gzippedSize) / stats.totalSize) * 100).toFixed(1)}%\n`)
    
    // ê°€ì¥ í° ìì‚°ë“¤
    console.log('ğŸ† Largest Assets (Gzipped):')
    stats.assets.slice(0, 10).forEach((asset, i) => {
      const size = `${(asset.gzippedSize / 1024).toFixed(2)}KB`
      console.log(`  ${i + 1}. ${asset.name} (${asset.type}) - ${size}`)
    })
    
    // ì²­í¬ ë¶„ì„
    if (stats.chunks.length > 0) {
      console.log('\nğŸ“¦ Largest Chunks:')
      stats.chunks.slice(0, 5).forEach((chunk, i) => {
        const size = `${(chunk.size / 1024).toFixed(2)}KB`
        const type = chunk.isInitial ? '(initial)' : '(async)'
        console.log(`  ${i + 1}. ${chunk.name} ${type} - ${size}`)
      })
    }
    
    // ê¶Œì¥ì‚¬í•­
    if (stats.recommendations.length > 0) {
      console.log('\nğŸ’¡ Recommendations:')
      stats.recommendations.forEach((rec, i) => {
        console.log(`  ${i + 1}. ${rec}`)
      })
    }
    
    // ì„±ëŠ¥ ë“±ê¸‰
    const grade = this.calculateGrade(stats)
    console.log(`\nğŸ¯ Performance Grade: ${grade}`)
  }
  
  private calculateGrade(stats: BundleStats): string {
    const gzippedMB = stats.gzippedSize / 1024 / 1024
    
    if (gzippedMB < 0.25) return 'A+ (Excellent)'
    if (gzippedMB < 0.5) return 'A (Very Good)'
    if (gzippedMB < 1) return 'B (Good)'
    if (gzippedMB < 2) return 'C (Fair)'
    return 'D (Needs Improvement)'
  }
  
  private async saveReport(stats: BundleStats) {
    const reportPath = path.join(process.cwd(), 'bundle-report.json')
    
    const report = {
      timestamp: new Date().toISOString(),
      ...stats,
    }
    
    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2))
    console.log(`\nğŸ“„ Report saved to ${reportPath}`)
  }
  
  async compareWithPrevious(): Promise<void> {
    const reportPath = path.join(process.cwd(), 'bundle-report.json')
    
    if (!fs.existsSync(reportPath)) {
      console.log('No previous report found.')
      return
    }
    
    const currentStats = await this.analyze()
    const previousReport = JSON.parse(fs.readFileSync(reportPath, 'utf8'))
    
    console.log('\nğŸ“ˆ Comparison with Previous Build:')
    
    const sizeDiff = currentStats.gzippedSize - previousReport.gzippedSize
    const sizeDiffPercent = ((sizeDiff / previousReport.gzippedSize) * 100).toFixed(1)
    
    if (sizeDiff > 0) {
      console.log(`ğŸ“ˆ Bundle size increased by ${(sizeDiff / 1024).toFixed(2)}KB (${sizeDiffPercent}%)`)
    } else if (sizeDiff < 0) {
      console.log(`ğŸ“‰ Bundle size decreased by ${Math.abs(sizeDiff / 1024).toFixed(2)}KB (${Math.abs(parseFloat(sizeDiffPercent))}%)`)
    } else {
      console.log('â¡ï¸ Bundle size unchanged')
    }
  }
}

// CLI ì‹¤í–‰
if (require.main === module) {
  const analyzer = new BundleAnalyzer()
  
  const command = process.argv[2]
  
  switch (command) {
    case 'compare':
      analyzer.compareWithPrevious().catch(console.error)
      break
    default:
      analyzer.analyze().catch(console.error)
  }
}
```

---

## ğŸ¨ UX ë””ìì¸ ê³ ë ¤ì‚¬í•­

### ë¡œë”© ê²½í—˜ ê°œì„ 
- **ì ì§„ì  ë¡œë”©**: ì¤‘ìš”í•œ ì½˜í…ì¸ ë¶€í„° ìš°ì„  í‘œì‹œ
- **ìŠ¤ì¼ˆë ˆí†¤ UI**: ì‹¤ì œ ë ˆì´ì•„ì›ƒê³¼ ìœ ì‚¬í•œ ë¡œë”© ì¸ë””ì¼€ì´í„°
- **ì„±ëŠ¥ ì¸ì‚¬ì´íŠ¸**: ê°œë°œì ë„êµ¬ì—ì„œ ë¡œë”© ì„±ëŠ¥ ì‹œê°í™”

### ì˜¤í”„ë¼ì¸ ëŒ€ì‘
- **ì˜¤í”„ë¼ì¸ ì•Œë¦¼**: ë„¤íŠ¸ì›Œí¬ ìƒíƒœ ë³€í™” ì‚¬ìš©ì ì•Œë¦¼
- **ìºì‹œëœ ì½˜í…ì¸ **: ì˜¤í”„ë¼ì¸ì—ì„œë„ ê¸°ë³¸ ê¸°ëŠ¥ ì œê³µ
- **ë™ê¸°í™”**: ì˜¨ë¼ì¸ ë³µêµ¬ ì‹œ ìë™ ë°ì´í„° ë™ê¸°í™”

### ì„±ëŠ¥ í”¼ë“œë°±
- **ë¡œë”© ì§„í–‰ë¥ **: í° ë¦¬ì†ŒìŠ¤ ë¡œë”© ì‹œ ì§„í–‰ë¥  í‘œì‹œ
- **ì—ëŸ¬ ë³µêµ¬**: ë¡œë”© ì‹¤íŒ¨ ì‹œ ì¬ì‹œë„ ì˜µì…˜ ì œê³µ
- **ë°ì´í„° ì‚¬ìš©ëŸ‰**: ëª¨ë°”ì¼ ì‚¬ìš©ìë¥¼ ìœ„í•œ ë°ì´í„° ì ˆì•½ ëª¨ë“œ

---

## âš¡ ì„±ëŠ¥ ìµœì í™”

### ë²ˆë“¤ í¬ê¸° ìµœì í™”
- **ì½”ë“œ ìŠ¤í”Œë¦¬íŒ…**: ë¼ìš°íŠ¸ ë° ê¸°ëŠ¥ë³„ ì²­í¬ ë¶„ë¦¬
- **íŠ¸ë¦¬ ì…°ì´í‚¹**: ë¯¸ì‚¬ìš© ì½”ë“œ ì™„ì „ ì œê±°
- **ë¼ì´ë¸ŒëŸ¬ë¦¬ ìµœì í™”**: í•„ìš”í•œ ë¶€ë¶„ë§Œ ì„ íƒì  ì„í¬íŠ¸

### ë¦¬ì†ŒìŠ¤ ìµœì í™”
- **ì´ë¯¸ì§€ ì••ì¶•**: WebP/AVIF í˜•ì‹ìœ¼ë¡œ ìë™ ë³€í™˜
- **í°íŠ¸ ì„œë¸Œì…‹**: ì‚¬ìš©í•˜ëŠ” ë¬¸ìë§Œ í¬í•¨í•œ ê²½ëŸ‰ í°íŠ¸
- **CSS ìµœì í™”**: ë¯¸ì‚¬ìš© ìŠ¤íƒ€ì¼ ì œê±° ë° ì••ì¶•

### ë„¤íŠ¸ì›Œí¬ ìµœì í™”
- **HTTP/2 í™œìš©**: ë‹¤ì¤‘ ìš”ì²­ ë³‘ë ¬ ì²˜ë¦¬
- **ìºì‹± ì „ëµ**: ì ì ˆí•œ ìºì‹œ í—¤ë”ë¡œ ì¬ë°©ë¬¸ ì„±ëŠ¥ í–¥ìƒ
- **CDN í™œìš©**: ì „ ì„¸ê³„ ì‚¬ìš©ìì—ê²Œ ë¹ ë¥¸ ë¦¬ì†ŒìŠ¤ ì œê³µ

---

## ğŸ§ª Definition of Done

### ë²ˆë“¤ í¬ê¸° ë‹¬ì„± ìš”êµ¬ì‚¬í•­
- [ ] ì´ˆê¸° JavaScript ë²ˆë“¤ < 250KB (gzipped)
- [ ] ì£¼ìš” CSS ë²ˆë“¤ < 50KB (gzipped)
- [ ] ê°œë³„ ì²­í¬ í¬ê¸° < 100KB (gzipped)
- [ ] ì „ì²´ ì •ì  ë¦¬ì†ŒìŠ¤ < 2MB (gzipped)

### ìµœì í™” ê¸°ëŠ¥ êµ¬í˜„ ìš”êµ¬ì‚¬í•­
- [ ] ìë™ ì½”ë“œ ìŠ¤í”Œë¦¬íŒ… ë° ì§€ì—° ë¡œë”©
- [ ] íŠ¸ë¦¬ ì…°ì´í‚¹ìœ¼ë¡œ ë¯¸ì‚¬ìš© ì½”ë“œ ì œê±°
- [ ] ì´ë¯¸ì§€ ìë™ ìµœì í™” (WebP/AVIF ë³€í™˜)
- [ ] ì„œë¹„ìŠ¤ ì›Œì»¤ ê¸°ë°˜ ìºì‹± ì‹œìŠ¤í…œ

### ê°œë°œ ë„êµ¬ ìš”êµ¬ì‚¬í•­
- [ ] ë²ˆë“¤ ë¶„ì„ ë„êµ¬ ë° ë¦¬í¬íŠ¸ ìƒì„±
- [ ] ì„±ëŠ¥ íšŒê·€ ê°ì§€ ì‹œìŠ¤í…œ
- [ ] ìë™í™”ëœ ìµœì í™” ì œì•ˆ
- [ ] CI/CD í†µí•© ë²ˆë“¤ í¬ê¸° ì²´í¬

### ì‚¬ìš©ì ê²½í—˜ ìš”êµ¬ì‚¬í•­
- [ ] ì´ˆê¸° ë¡œë”© ì‹œê°„ < 3ì´ˆ (3G ë„¤íŠ¸ì›Œí¬)
- [ ] ì˜¤í”„ë¼ì¸ì—ì„œ ê¸°ë³¸ ê¸°ëŠ¥ ì‚¬ìš© ê°€ëŠ¥
- [ ] ì´ë¯¸ì§€ ë¡œë”© ì‹¤íŒ¨ ì‹œ ì ì ˆí•œ í´ë°±
- [ ] ë„¤íŠ¸ì›Œí¬ ìƒíƒœ ë³€í™” ì‹œ ì‚¬ìš©ì ì•Œë¦¼

### í’ˆì§ˆ ë³´ì¦ ìš”êµ¬ì‚¬í•­
- [ ] Lighthouse ì„±ëŠ¥ ì ìˆ˜ > 90
- [ ] WebPageTest ë“±ê¸‰ A ë‹¬ì„±
- [ ] ë‹¤ì–‘í•œ ë„¤íŠ¸ì›Œí¬ ì¡°ê±´ì—ì„œ í…ŒìŠ¤íŠ¸ í†µê³¼
- [ ] ëª¨ë°”ì¼ ë””ë°”ì´ìŠ¤ ì„±ëŠ¥ ê²€ì¦

---

## ğŸ“š ê´€ë ¨ ë¬¸ì„œ

- [09-build-bundle-optimization.md](../ui-architecture/09-build-bundle-optimization.md) - ë¹Œë“œ ìµœì í™” ì•„í‚¤í…ì²˜
- [Story 2.17: Runtime Performance](./2.17.runtime-performance.md) - ëŸ°íƒ€ì„ ì„±ëŠ¥ ìµœì í™”
- [Story 2.5: Performance Optimization](./2.5.performance-optimization.md) - ê¸°ì¡´ ì„±ëŠ¥ ìµœì í™”
- [Story 2.22: CI Pipeline Performance](./2.22.ci-pipeline-performance.md) - CI/CD ì„±ëŠ¥

---

## ğŸ“ˆ ì„±ê³µ ì§€í‘œ

### ì„±ëŠ¥ ì§€í‘œ
- **ë²ˆë“¤ í¬ê¸°**: ì „ì²´ ë²ˆë“¤ í¬ê¸° 40% ê°ì†Œ
- **ë¡œë”© ì†ë„**: ì´ˆê¸° ë¡œë”© ì‹œê°„ 50% ë‹¨ì¶•
- **ìºì‹œ ì ì¤‘ë¥ **: ì •ì  ë¦¬ì†ŒìŠ¤ ìºì‹œ ì ì¤‘ë¥  > 85%
- **ì••ì¶•ë¥ **: Gzip ì••ì¶•ìœ¼ë¡œ í‰ê·  70% í¬ê¸° ê°ì†Œ

### ì‚¬ìš©ì ê²½í—˜ ì§€í‘œ
- **ì´íƒˆë¥  ê°ì†Œ**: ë¡œë”© ì‹œê°„ ê°œì„ ìœ¼ë¡œ ì´íƒˆë¥  30% ê°ì†Œ
- **í˜ì´ì§€ ë·°**: ë¹ ë¥¸ ë¡œë”©ìœ¼ë¡œ í˜ì´ì§€ ë·° 20% ì¦ê°€
- **ì‚¬ìš©ì ë§Œì¡±ë„**: ì„±ëŠ¥ ê´€ë ¨ ë§Œì¡±ë„ ì ìˆ˜ > 8/10
- **ì¬ë°©ë¬¸ë¥ **: ìºì‹± íš¨ê³¼ë¡œ ì¬ë°©ë¬¸ ì‹œ ë¡œë”© ì†ë„ 80% í–¥ìƒ

### ê°œë°œ íš¨ìœ¨ì„± ì§€í‘œ
- **ë°°í¬ ì‹œê°„**: ìµœì í™”ëœ ë¹Œë“œë¡œ ë°°í¬ ì‹œê°„ 25% ë‹¨ì¶•
- **ë””ë²„ê¹… ì‹œê°„**: ë²ˆë“¤ ë¶„ì„ ë„êµ¬ë¡œ ì„±ëŠ¥ ì´ìŠˆ íŒŒì•… ì‹œê°„ 60% ë‹¨ì¶•
- **ê°œë°œ ìƒì‚°ì„±**: ìµœì í™” ìë™í™”ë¡œ ê°œë°œì ìˆ˜ì‘ì—… ì‹œê°„ 70% ê°ì†Œ
- **CI/CD ì•ˆì •ì„±**: ì„±ëŠ¥ íšŒê·€ ìë™ ê°ì§€ë¡œ ì•ˆì •ì„± 95% ë‹¬ì„±

### ë¹„ì¦ˆë‹ˆìŠ¤ ì§€í‘œ
- **ë°ì´í„° ì ˆì•½**: ëª¨ë°”ì¼ ì‚¬ìš©ì ë°ì´í„° ì‚¬ìš©ëŸ‰ 40% ê°ì†Œ
- **ì„œë²„ ë¹„ìš©**: CDN ìºì‹±ìœ¼ë¡œ ì„œë²„ ë¶€í•˜ 30% ê°ì†Œ
- **ì „í™˜ìœ¨**: ë¹ ë¥¸ ë¡œë”©ìœ¼ë¡œ ì‚¬ìš©ì ì „í™˜ìœ¨ 15% í–¥ìƒ
- **ê²½ìŸ ìš°ìœ„**: ë™ì¢… ì—…ê³„ ëŒ€ë¹„ ë¡œë”© ì†ë„ 2ë°° ë¹ ë¥¸ ì„±ëŠ¥ ë‹¬ì„±