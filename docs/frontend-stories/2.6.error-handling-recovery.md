# Story 2.6: 에러 처리 및 복구 시스템

## 📋 문서 정보
- **스토리 버전**: 2.0
- **작성일**: 2025-08-28
- **작성자**: Bob (Scrum Master Agent)  
- **프로젝트명**: 바로캘린더 (Baro Calendar)
- **Epic**: 프론트엔드 안정성 향상
- **상태**: Ready for Development

---

## 🎯 **스토리 목표**

**완전한 에러 처리 및 복구 시스템**
- 글로벌 에러 바운더리 구현
- 네트워크 에러 처리 및 재시도
- 사용자 친화적 에러 메시지
- 자동 복구 메커니즘
- 에러 로깅 및 모니터링

---

## 👤 **사용자 스토리**

**사용자로서, 나는:**
1. 에러가 발생해도 앱이 완전히 멈추지 않기를 원한다
2. 무엇이 잘못되었는지 명확하게 알고 싶다
3. 문제를 쉽게 해결할 수 있는 방법을 제시받고 싶다
4. 네트워크 문제 시 자동으로 재시도해주기를 원한다
5. 작업 중이던 데이터가 손실되지 않기를 원한다

---

## 🏗️ **기술적 구현 요구사항**

### **1. 글로벌 에러 바운더리**

**에러 바운더리 구현**
```typescript
// src/components/error/ErrorBoundary.tsx
import React, { Component, ErrorInfo, ReactNode } from 'react'
import { Button } from '@/components/ui/button'
import { AlertTriangle, RefreshCw, Bug, Home } from 'lucide-react'

interface Props {
  children: ReactNode
  fallback?: React.ComponentType<ErrorBoundaryProps>
  onError?: (error: Error, errorInfo: ErrorInfo) => void
  level?: 'page' | 'section' | 'component'
}

interface State {
  hasError: boolean
  error: Error | null
  errorInfo: ErrorInfo | null
  retryCount: number
}

interface ErrorBoundaryProps {
  error: Error | null
  errorInfo: ErrorInfo | null
  retry: () => void
  retryCount: number
  level: string
}

export class ErrorBoundary extends Component<Props, State> {
  private retryTimeoutId: NodeJS.Timeout | null = null

  constructor(props: Props) {
    super(props)
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null,
      retryCount: 0,
    }
  }

  static getDerivedStateFromError(error: Error): State {
    return {
      hasError: true,
      error,
      errorInfo: null,
      retryCount: 0,
    }
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    this.setState({
      error,
      errorInfo,
    })

    // 에러 로깅
    this.logError(error, errorInfo)
    
    // 외부 에러 핸들러 호출
    this.props.onError?.(error, errorInfo)
  }

  private logError = (error: Error, errorInfo: ErrorInfo) => {
    const errorReport = {
      message: error.message,
      stack: error.stack,
      componentStack: errorInfo.componentStack,
      level: this.props.level || 'component',
      url: window.location.href,
      userAgent: navigator.userAgent,
      timestamp: new Date().toISOString(),
      userId: this.getCurrentUserId(),
    }

    // 로컬 스토리지에 에러 저장 (오프라인 시를 위해)
    this.storeErrorLocally(errorReport)

    // 에러 리포팅 서비스로 전송
    this.sendErrorReport(errorReport)
  }

  private getCurrentUserId = (): string | null => {
    // 사용자 ID 가져오기 로직
    return localStorage.getItem('userId')
  }

  private storeErrorLocally = (errorReport: any) => {
    try {
      const storedErrors = JSON.parse(localStorage.getItem('errorLogs') || '[]')
      storedErrors.push(errorReport)
      
      // 최대 50개 에러만 저장
      if (storedErrors.length > 50) {
        storedErrors.shift()
      }
      
      localStorage.setItem('errorLogs', JSON.stringify(storedErrors))
    } catch (e) {
      console.error('Failed to store error locally:', e)
    }
  }

  private sendErrorReport = async (errorReport: any) => {
    try {
      await fetch('/api/errors', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(errorReport),
      })
    } catch (e) {
      console.error('Failed to send error report:', e)
    }
  }

  private handleRetry = () => {
    const { retryCount } = this.state
    
    // 최대 3번 재시도
    if (retryCount >= 3) {
      return
    }

    this.setState({
      hasError: false,
      error: null,
      errorInfo: null,
      retryCount: retryCount + 1,
    })

    // 점진적 지연 (1초, 2초, 4초)
    const delay = Math.pow(2, retryCount) * 1000
    this.retryTimeoutId = setTimeout(() => {
      // 강제 리렌더링
      this.forceUpdate()
    }, delay)
  }

  private handleReload = () => {
    window.location.reload()
  }

  private handleGoHome = () => {
    window.location.href = '/'
  }

  componentWillUnmount() {
    if (this.retryTimeoutId) {
      clearTimeout(this.retryTimeoutId)
    }
  }

  render() {
    if (this.state.hasError) {
      const FallbackComponent = this.props.fallback || DefaultErrorFallback
      
      return (
        <FallbackComponent
          error={this.state.error}
          errorInfo={this.state.errorInfo}
          retry={this.handleRetry}
          retryCount={this.state.retryCount}
          level={this.props.level || 'component'}
        />
      )
    }

    return this.props.children
  }
}

// 기본 에러 폴백 컴포넌트
const DefaultErrorFallback: React.FC<ErrorBoundaryProps> = ({
  error,
  retry,
  retryCount,
  level,
}) => {
  const isPageLevel = level === 'page'
  const canRetry = retryCount < 3

  return (
    <div className={cn(
      "flex flex-col items-center justify-center p-8 text-center",
      isPageLevel ? "min-h-screen" : "min-h-[200px]"
    )}>
      <div className="mb-4">
        <AlertTriangle className="w-12 h-12 text-destructive mx-auto mb-4" />
        <h2 className="text-xl font-semibold mb-2">
          {isPageLevel ? '페이지 로딩 중 오류가 발생했습니다' : '일시적인 문제가 발생했습니다'}
        </h2>
        <p className="text-muted-foreground mb-6 max-w-md">
          {error?.message || '알 수 없는 오류가 발생했습니다. 잠시 후 다시 시도해 주세요.'}
        </p>
      </div>

      <div className="flex gap-2">
        {canRetry && (
          <Button onClick={retry} variant="outline">
            <RefreshCw className="w-4 h-4 mr-2" />
            다시 시도 ({3 - retryCount}회 남음)
          </Button>
        )}
        
        {isPageLevel && (
          <>
            <Button onClick={() => window.location.reload()}>
              <RefreshCw className="w-4 h-4 mr-2" />
              새로고침
            </Button>
            <Button onClick={() => window.location.href = '/'} variant="outline">
              <Home className="w-4 h-4 mr-2" />
              홈으로
            </Button>
          </>
        )}
      </div>

      {process.env.NODE_ENV === 'development' && error && (
        <details className="mt-6 p-4 bg-muted rounded max-w-2xl w-full text-left">
          <summary className="cursor-pointer font-medium mb-2">
            <Bug className="w-4 h-4 inline mr-2" />
            개발자 정보
          </summary>
          <pre className="text-xs overflow-auto whitespace-pre-wrap">
            {error.stack}
          </pre>
        </details>
      )}
    </div>
  )
}

// HOC for automatic error boundary
export const withErrorBoundary = <P extends object>(
  Component: React.ComponentType<P>,
  errorBoundaryProps?: Omit<Props, 'children'>
) => {
  const WrappedComponent = (props: P) => (
    <ErrorBoundary {...errorBoundaryProps}>
      <Component {...props} />
    </ErrorBoundary>
  )

  WrappedComponent.displayName = `withErrorBoundary(${Component.displayName || Component.name})`
  
  return WrappedComponent
}
```

### **2. 네트워크 에러 처리**

**HTTP 클라이언트 에러 처리**
```typescript
// src/lib/http/error-handler.ts
export interface NetworkError extends Error {
  status?: number
  response?: any
  retryable: boolean
  userMessage: string
}

export class NetworkErrorHandler {
  private retryAttempts = new Map<string, number>()
  private maxRetries = 3
  private baseDelay = 1000

  async handleRequest<T>(
    requestFn: () => Promise<T>,
    options: {
      retryable?: boolean
      maxRetries?: number
      onRetry?: (attempt: number) => void
      onError?: (error: NetworkError) => void
    } = {}
  ): Promise<T> {
    const requestId = crypto.randomUUID()
    const maxRetries = options.maxRetries || this.maxRetries

    let lastError: NetworkError | null = null

    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        if (attempt > 0) {
          // 지수적 백오프
          const delay = this.baseDelay * Math.pow(2, attempt - 1)
          await this.sleep(delay)
          
          options.onRetry?.(attempt)
        }

        const result = await requestFn()
        
        // 성공 시 재시도 카운터 리셋
        this.retryAttempts.delete(requestId)
        
        return result
      } catch (error) {
        const networkError = this.createNetworkError(error)
        lastError = networkError

        // 재시도 불가능한 에러는 즉시 throw
        if (!networkError.retryable || attempt >= maxRetries) {
          options.onError?.(networkError)
          throw networkError
        }

        this.retryAttempts.set(requestId, attempt)
        console.warn(`Request failed, retrying (${attempt + 1}/${maxRetries})`, networkError)
      }
    }

    throw lastError
  }

  private createNetworkError(error: any): NetworkError {
    if (error instanceof NetworkError) {
      return error
    }

    const networkError = new Error() as NetworkError
    networkError.name = 'NetworkError'

    if (error.response) {
      // HTTP 에러 응답이 있는 경우
      const status = error.response.status
      networkError.status = status
      networkError.response = error.response.data
      networkError.message = error.response.data?.message || error.message
      
      networkError.retryable = this.isRetryableStatus(status)
      networkError.userMessage = this.getUserMessage(status, error.response.data)
    } else if (error.request) {
      // 네트워크 에러 (요청이 전송되었지만 응답이 없음)
      networkError.message = 'Network error - no response received'
      networkError.retryable = true
      networkError.userMessage = '네트워크 연결을 확인해주세요'
    } else {
      // 요청 설정 에러
      networkError.message = error.message
      networkError.retryable = false
      networkError.userMessage = '요청 처리 중 오류가 발생했습니다'
    }

    return networkError
  }

  private isRetryableStatus(status: number): boolean {
    // 재시도 가능한 HTTP 상태 코드
    const retryableStatuses = [408, 429, 502, 503, 504]
    return retryableStatuses.includes(status)
  }

  private getUserMessage(status: number, responseData: any): string {
    const statusMessages: Record<number, string> = {
      400: '잘못된 요청입니다',
      401: '로그인이 필요합니다',
      403: '권한이 없습니다',
      404: '요청한 리소스를 찾을 수 없습니다',
      408: '요청 시간이 초과되었습니다',
      409: '데이터 충돌이 발생했습니다',
      422: '입력 데이터를 확인해주세요',
      429: '요청이 너무 많습니다. 잠시 후 다시 시도해주세요',
      500: '서버 오류가 발생했습니다',
      502: '서버 연결에 문제가 있습니다',
      503: '서비스를 일시적으로 사용할 수 없습니다',
      504: '서버 응답 시간이 초과되었습니다',
    }

    return responseData?.message || statusMessages[status] || '알 수 없는 오류가 발생했습니다'
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms))
  }
}

// API 클라이언트 래퍼
export const apiClient = {
  errorHandler: new NetworkErrorHandler(),

  async get<T>(url: string, options?: RequestInit): Promise<T> {
    return this.errorHandler.handleRequest(
      () => fetch(url, { ...options, method: 'GET' }).then(res => res.json()),
      { retryable: true }
    )
  },

  async post<T>(url: string, data: any, options?: RequestInit): Promise<T> {
    return this.errorHandler.handleRequest(
      () => fetch(url, {
        ...options,
        method: 'POST',
        headers: { 'Content-Type': 'application/json', ...options?.headers },
        body: JSON.stringify(data)
      }).then(res => res.json()),
      { retryable: false } // POST는 기본적으로 재시도하지 않음
    )
  },

  async put<T>(url: string, data: any, options?: RequestInit): Promise<T> {
    return this.errorHandler.handleRequest(
      () => fetch(url, {
        ...options,
        method: 'PUT',
        headers: { 'Content-Type': 'application/json', ...options?.headers },
        body: JSON.stringify(data)
      }).then(res => res.json()),
      { retryable: true }
    )
  },

  async delete<T>(url: string, options?: RequestInit): Promise<T> {
    return this.errorHandler.handleRequest(
      () => fetch(url, { ...options, method: 'DELETE' }).then(res => res.json()),
      { retryable: true }
    )
  }
}
```

### **3. React Query 에러 처리**

**Query 에러 처리**
```typescript
// src/lib/query/error-handler.ts
import { toast } from 'sonner'
import { QueryCache, MutationCache } from '@tanstack/react-query'

export const createQueryCache = () => {
  return new QueryCache({
    onError: (error, query) => {
      const networkError = error as NetworkError
      
      // 백그라운드 쿼리는 토스트 표시 안함
      if (!query.meta?.showErrorToast) {
        return
      }

      toast.error(networkError.userMessage || '데이터를 불러오는 중 오류가 발생했습니다', {
        description: process.env.NODE_ENV === 'development' ? networkError.message : undefined,
        action: {
          label: '다시 시도',
          onClick: () => query.reset()
        }
      })
    }
  })
}

export const createMutationCache = () => {
  return new MutationCache({
    onError: (error, variables, context, mutation) => {
      const networkError = error as NetworkError
      
      toast.error(networkError.userMessage || '작업 중 오류가 발생했습니다', {
        description: process.env.NODE_ENV === 'development' ? networkError.message : undefined,
      })
    },
    
    onSuccess: (data, variables, context, mutation) => {
      // 성공 시 토스트 (옵션)
      if (mutation.meta?.showSuccessToast) {
        toast.success('작업이 완료되었습니다')
      }
    }
  })
}

// 에러가 있는 쿼리 재시도 훅
export const useRetryFailedQueries = () => {
  const queryClient = useQueryClient()
  
  const retryFailed = useCallback(() => {
    // 실패한 모든 쿼리 재시도
    queryClient.getQueryCache().getAll().forEach(query => {
      if (query.state.error) {
        query.fetch()
      }
    })
  }, [queryClient])
  
  const retryFailedCount = queryClient.getQueryCache()
    .getAll()
    .filter(query => query.state.error).length
  
  return {
    retryFailed,
    retryFailedCount,
    hasFailedQueries: retryFailedCount > 0
  }
}
```

### **4. 사용자 친화적 에러 UI**

**에러 토스트 및 알림**
```typescript
// src/components/error/ErrorNotification.tsx
import React from 'react'
import { toast } from 'sonner'
import { AlertCircle, Wifi, WifiOff, RefreshCw } from 'lucide-react'
import { Button } from '@/components/ui/button'

export class ErrorNotificationManager {
  private static activeToasts = new Set<string>()

  static showNetworkError(error: NetworkError, options: {
    retry?: () => void
    persistent?: boolean
  } = {}) {
    const toastId = `network-error-${error.status || 'unknown'}`
    
    // 중복 토스트 방지
    if (this.activeToasts.has(toastId)) {
      return
    }
    
    this.activeToasts.add(toastId)
    
    toast.error(error.userMessage, {
      id: toastId,
      description: navigator.onLine ? undefined : '인터넷 연결을 확인해주세요',
      icon: navigator.onLine ? <AlertCircle /> : <WifiOff />,
      duration: options.persistent ? Infinity : 5000,
      action: options.retry ? {
        label: '다시 시도',
        onClick: options.retry
      } : undefined,
      onDismiss: () => this.activeToasts.delete(toastId),
      onAutoClose: () => this.activeToasts.delete(toastId)
    })
  }

  static showConnectionRestored() {
    toast.success('인터넷 연결이 복구되었습니다', {
      icon: <Wifi className="text-green-500" />,
      duration: 3000
    })
  }

  static showDataSaved() {
    toast.success('데이터가 로컬에 저장되었습니다', {
      description: '인터넷 연결 시 자동 동기화됩니다',
      duration: 4000
    })
  }

  static showSyncCompleted() {
    toast.success('오프라인 데이터가 동기화되었습니다', {
      duration: 3000
    })
  }
}

// 연결 상태 모니터링
export const ConnectionStatusMonitor: React.FC = () => {
  const [isOnline, setIsOnline] = useState(navigator.onLine)
  const [wasOffline, setWasOffline] = useState(false)
  const { retryFailed, hasFailedQueries } = useRetryFailedQueries()

  useEffect(() => {
    const handleOnline = () => {
      setIsOnline(true)
      
      if (wasOffline) {
        ErrorNotificationManager.showConnectionRestored()
        
        // 실패한 쿼리 자동 재시도
        if (hasFailedQueries) {
          setTimeout(retryFailed, 1000)
        }
        
        setWasOffline(false)
      }
    }

    const handleOffline = () => {
      setIsOnline(false)
      setWasOffline(true)
      
      toast.warning('인터넷 연결이 끊어졌습니다', {
        description: '오프라인 모드로 전환됩니다',
        icon: <WifiOff />,
        duration: 4000
      })
    }

    window.addEventListener('online', handleOnline)
    window.addEventListener('offline', handleOffline)

    return () => {
      window.removeEventListener('online', handleOnline)
      window.removeEventListener('offline', handleOffline)
    }
  }, [wasOffline, hasFailedQueries, retryFailed])

  // 오프라인 상태 표시
  if (!isOnline) {
    return (
      <div className="fixed top-4 left-1/2 transform -translate-x-1/2 z-50">
        <div className="bg-orange-100 border border-orange-400 text-orange-700 px-4 py-2 rounded-lg flex items-center gap-2 shadow-lg">
          <WifiOff className="w-4 h-4" />
          <span className="text-sm font-medium">오프라인 모드</span>
        </div>
      </div>
    )
  }

  return null
}
```

### **5. 데이터 복구 시스템**

**로컬 데이터 백업 및 복구**
```typescript
// src/lib/recovery/data-recovery.ts
export class DataRecoveryManager {
  private storageKey = 'baro-calendar-backup'
  private maxBackups = 10

  // 데이터 백업
  async backupData(data: any, operation: string) {
    try {
      const backup = {
        id: crypto.randomUUID(),
        timestamp: Date.now(),
        operation,
        data: JSON.parse(JSON.stringify(data)), // Deep clone
      }

      const existingBackups = this.getBackups()
      const newBackups = [backup, ...existingBackups].slice(0, this.maxBackups)
      
      localStorage.setItem(this.storageKey, JSON.stringify(newBackups))
    } catch (error) {
      console.error('Failed to backup data:', error)
    }
  }

  // 백업 목록 조회
  getBackups(): Array<{
    id: string
    timestamp: number
    operation: string
    data: any
  }> {
    try {
      const backups = localStorage.getItem(this.storageKey)
      return backups ? JSON.parse(backups) : []
    } catch (error) {
      console.error('Failed to get backups:', error)
      return []
    }
  }

  // 데이터 복구
  async recoverData(backupId: string): Promise<any | null> {
    try {
      const backups = this.getBackups()
      const backup = backups.find(b => b.id === backupId)
      
      if (!backup) {
        throw new Error('Backup not found')
      }

      return backup.data
    } catch (error) {
      console.error('Failed to recover data:', error)
      return null
    }
  }

  // 자동 복구 시도
  async attemptAutoRecovery(errorContext: string): Promise<boolean> {
    try {
      const recentBackups = this.getBackups()
        .filter(backup => Date.now() - backup.timestamp < 60000) // 1분 이내
        .slice(0, 3)

      for (const backup of recentBackups) {
        try {
          // 백업 데이터로 상태 복구 시도
          await this.restoreFromBackup(backup)
          
          toast.success('데이터가 복구되었습니다', {
            description: `${new Date(backup.timestamp).toLocaleTimeString()} 시점으로 복구됨`
          })
          
          return true
        } catch (restoreError) {
          continue
        }
      }

      return false
    } catch (error) {
      console.error('Auto recovery failed:', error)
      return false
    }
  }

  private async restoreFromBackup(backup: any) {
    // 상태 관리 스토어에 백업 데이터 적용
    const stores = await import('@/stores')
    
    if (backup.data.calendar) {
      stores.useCalendarStore.setState(backup.data.calendar)
    }
    
    if (backup.data.projects) {
      stores.useProjectStore.setState(backup.data.projects)
    }
  }

  // 백업 정리
  cleanupOldBackups() {
    try {
      const backups = this.getBackups()
      const oneWeekAgo = Date.now() - (7 * 24 * 60 * 60 * 1000)
      
      const validBackups = backups.filter(backup => 
        backup.timestamp > oneWeekAgo
      ).slice(0, this.maxBackups)
      
      localStorage.setItem(this.storageKey, JSON.stringify(validBackups))
    } catch (error) {
      console.error('Failed to cleanup backups:', error)
    }
  }
}

// 자동 백업 훅
export const useAutoBackup = () => {
  const recoveryManager = useMemo(() => new DataRecoveryManager(), [])
  const calendarState = useCalendarStore()
  const projectState = useProjectStore()
  
  // 상태 변경 시 자동 백업
  useEffect(() => {
    const backupData = {
      calendar: calendarState,
      projects: projectState,
    }
    
    recoveryManager.backupData(backupData, 'state-change')
  }, [calendarState, projectState, recoveryManager])
  
  // 페이지 언로드 시 백업
  useEffect(() => {
    const handleBeforeUnload = () => {
      const backupData = {
        calendar: calendarState,
        projects: projectState,
      }
      
      recoveryManager.backupData(backupData, 'page-unload')
    }
    
    window.addEventListener('beforeunload', handleBeforeUnload)
    return () => window.removeEventListener('beforeunload', handleBeforeUnload)
  }, [calendarState, projectState, recoveryManager])
  
  return recoveryManager
}
```

### **6. 에러 보고 및 모니터링**

**에러 보고 시스템**
```typescript
// src/lib/monitoring/error-reporting.ts
export class ErrorReportingService {
  private endpoint = '/api/errors'
  private batchSize = 10
  private flushInterval = 30000 // 30초
  private errorQueue: any[] = []
  private flushTimer: NodeJS.Timeout | null = null

  constructor() {
    this.startBatchProcessing()
    this.setupGlobalErrorHandlers()
  }

  // 에러 보고
  reportError(error: Error | NetworkError, context: {
    component?: string
    action?: string
    userId?: string
    sessionId?: string
    metadata?: any
  } = {}) {
    const errorReport = {
      id: crypto.randomUUID(),
      timestamp: Date.now(),
      message: error.message,
      stack: error.stack,
      name: error.name,
      url: window.location.href,
      userAgent: navigator.userAgent,
      ...context,
      // 네트워크 에러 특별 처리
      ...('status' in error && {
        httpStatus: error.status,
        retryable: error.retryable,
        userMessage: error.userMessage,
      }),
    }

    this.errorQueue.push(errorReport)

    // 즉시 처리가 필요한 심각한 에러
    if (this.isCriticalError(error)) {
      this.flushErrors()
    }
  }

  private isCriticalError(error: Error): boolean {
    return (
      error.name === 'ChunkLoadError' ||
      error.message.includes('Loading chunk') ||
      error.message.includes('Script error')
    )
  }

  private startBatchProcessing() {
    this.flushTimer = setInterval(() => {
      this.flushErrors()
    }, this.flushInterval)
  }

  private async flushErrors() {
    if (this.errorQueue.length === 0) return

    const batch = this.errorQueue.splice(0, this.batchSize)
    
    try {
      await fetch(this.endpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ errors: batch })
      })
    } catch (e) {
      // 전송 실패 시 다시 큐에 넣기 (최대 1회)
      batch.forEach(error => {
        if (!error._retried) {
          error._retried = true
          this.errorQueue.unshift(error)
        }
      })
    }
  }

  private setupGlobalErrorHandlers() {
    // 처리되지 않은 Promise rejection
    window.addEventListener('unhandledrejection', (event) => {
      this.reportError(new Error(event.reason), {
        component: 'global',
        action: 'unhandled-promise-rejection'
      })
    })

    // JavaScript 에러
    window.addEventListener('error', (event) => {
      this.reportError(new Error(event.message), {
        component: 'global',
        action: 'javascript-error',
        metadata: {
          filename: event.filename,
          lineno: event.lineno,
          colno: event.colno
        }
      })
    })

    // 리소스 로딩 에러
    window.addEventListener('error', (event) => {
      if (event.target && event.target !== window) {
        const element = event.target as HTMLElement
        this.reportError(new Error(`Resource loading failed: ${element.tagName}`), {
          component: 'global',
          action: 'resource-load-error',
          metadata: {
            tagName: element.tagName,
            src: (element as any).src || (element as any).href
          }
        })
      }
    }, true)
  }

  // 정리
  destroy() {
    if (this.flushTimer) {
      clearInterval(this.flushTimer)
    }
    this.flushErrors() // 마지막 배치 전송
  }
}

// 전역 에러 리포팅 인스턴스
export const errorReporting = new ErrorReportingService()
```

---

## 📊 **모니터링 대시보드**

### **에러 메트릭 수집**
```typescript
// src/lib/monitoring/metrics.ts
export const collectErrorMetrics = () => {
  return {
    errorRate: calculateErrorRate(),
    commonErrors: getCommonErrors(),
    browserSupport: getBrowserErrorStats(),
    userImpact: getUserImpactMetrics(),
  }
}
```

---

## ✅ **Definition of Done**

### **기능 요구사항**
- [ ] 글로벌 에러 바운더리 구현
- [ ] 네트워크 에러 자동 재시도
- [ ] 사용자 친화적 에러 메시지
- [ ] 오프라인 데이터 복구
- [ ] 자동 에러 보고

### **기술 요구사항**
- [ ] React Error Boundary
- [ ] HTTP 에러 처리 래퍼
- [ ] 로컬 데이터 백업
- [ ] 에러 로깅 시스템

### **사용성 요구사항**
- [ ] 명확한 에러 메시지
- [ ] 복구 액션 제공
- [ ] 오프라인 모드 지원
- [ ] 데이터 손실 방지

### **모니터링 요구사항**
- [ ] 에러 메트릭 수집
- [ ] 실시간 에러 알림
- [ ] 에러 트렌드 분석
- [ ] 사용자 영향도 측정

---

## 📚 **관련 문서 참조**

- [20. Error Handling](../ui-architecture/20-error-handling.md)
- [21. Observability & Monitoring](../ui-architecture/21-observability-monitoring.md)
- [04. State Management](../ui-architecture/04-state-management.md)

---

**이 스토리는 바로캘린더의 안정적인 에러 처리 및 복구 시스템 구현을 위한 기술 가이드입니다. 사용자에게 중단 없는 서비스 경험을 제공하고 개발팀에게 신속한 문제 해결 도구를 제공합니다.**