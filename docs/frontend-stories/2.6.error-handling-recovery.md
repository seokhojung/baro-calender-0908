# Story 2.8: ì—ëŸ¬ ì²˜ë¦¬ ë° ë³µêµ¬ ì‹œìŠ¤í…œ

## ğŸ“‹ ë¬¸ì„œ ì •ë³´
- **ìŠ¤í† ë¦¬ ë²„ì „**: 2.0
- **ì‘ì„±ì¼**: 2025-08-28
- **ì‘ì„±ì**: Bob (Scrum Master Agent)  
- **í”„ë¡œì íŠ¸ëª…**: ë°”ë¡œìº˜ë¦°ë” (Baro Calendar)
- **Epic**: í”„ë¡ íŠ¸ì—”ë“œ ì•ˆì •ì„± í–¥ìƒ
- **ìƒíƒœ**: Ready for Development

---

## ğŸ¯ **ìŠ¤í† ë¦¬ ëª©í‘œ**

**ì™„ì „í•œ ì—ëŸ¬ ì²˜ë¦¬ ë° ë³µêµ¬ ì‹œìŠ¤í…œ**
- ê¸€ë¡œë²Œ ì—ëŸ¬ ë°”ìš´ë”ë¦¬ êµ¬í˜„
- ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ ì²˜ë¦¬ ë° ì¬ì‹œë„
- ì‚¬ìš©ì ì¹œí™”ì  ì—ëŸ¬ ë©”ì‹œì§€
- ìë™ ë³µêµ¬ ë©”ì»¤ë‹ˆì¦˜
- ì—ëŸ¬ ë¡œê¹… ë° ëª¨ë‹ˆí„°ë§

---

## ğŸ‘¤ **ì‚¬ìš©ì ìŠ¤í† ë¦¬**

**ì‚¬ìš©ìë¡œì„œ, ë‚˜ëŠ”:**
1. ì—ëŸ¬ê°€ ë°œìƒí•´ë„ ì•±ì´ ì™„ì „íˆ ë©ˆì¶”ì§€ ì•Šê¸°ë¥¼ ì›í•œë‹¤
2. ë¬´ì—‡ì´ ì˜ëª»ë˜ì—ˆëŠ”ì§€ ëª…í™•í•˜ê²Œ ì•Œê³  ì‹¶ë‹¤
3. ë¬¸ì œë¥¼ ì‰½ê²Œ í•´ê²°í•  ìˆ˜ ìˆëŠ” ë°©ë²•ì„ ì œì‹œë°›ê³  ì‹¶ë‹¤
4. ë„¤íŠ¸ì›Œí¬ ë¬¸ì œ ì‹œ ìë™ìœ¼ë¡œ ì¬ì‹œë„í•´ì£¼ê¸°ë¥¼ ì›í•œë‹¤
5. ì‘ì—… ì¤‘ì´ë˜ ë°ì´í„°ê°€ ì†ì‹¤ë˜ì§€ ì•Šê¸°ë¥¼ ì›í•œë‹¤

---

## ğŸ—ï¸ **ê¸°ìˆ ì  êµ¬í˜„ ìš”êµ¬ì‚¬í•­**

### **1. ê¸€ë¡œë²Œ ì—ëŸ¬ ë°”ìš´ë”ë¦¬**

**ì—ëŸ¬ ë°”ìš´ë”ë¦¬ êµ¬í˜„**
```typescript
// src/components/error/ErrorBoundary.tsx
import React, { Component, ErrorInfo, ReactNode } from 'react'
import { Button } from '@/components/ui/button'
import { AlertTriangle, RefreshCw, Bug, Home } from 'lucide-react'

interface Props {
  children: ReactNode
  fallback?: React.ComponentType<ErrorBoundaryProps>
  onError?: (error: Error, errorInfo: ErrorInfo) => void
  level?: 'page' | 'section' | 'component'
}

interface State {
  hasError: boolean
  error: Error | null
  errorInfo: ErrorInfo | null
  retryCount: number
}

interface ErrorBoundaryProps {
  error: Error | null
  errorInfo: ErrorInfo | null
  retry: () => void
  retryCount: number
  level: string
}

export class ErrorBoundary extends Component<Props, State> {
  private retryTimeoutId: NodeJS.Timeout | null = null

  constructor(props: Props) {
    super(props)
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null,
      retryCount: 0,
    }
  }

  static getDerivedStateFromError(error: Error): State {
    return {
      hasError: true,
      error,
      errorInfo: null,
      retryCount: 0,
    }
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    this.setState({
      error,
      errorInfo,
    })

    // ì—ëŸ¬ ë¡œê¹…
    this.logError(error, errorInfo)
    
    // ì™¸ë¶€ ì—ëŸ¬ í•¸ë“¤ëŸ¬ í˜¸ì¶œ
    this.props.onError?.(error, errorInfo)
  }

  private logError = (error: Error, errorInfo: ErrorInfo) => {
    const errorReport = {
      message: error.message,
      stack: error.stack,
      componentStack: errorInfo.componentStack,
      level: this.props.level || 'component',
      url: window.location.href,
      userAgent: navigator.userAgent,
      timestamp: new Date().toISOString(),
      userId: this.getCurrentUserId(),
    }

    // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ì—ëŸ¬ ì €ì¥ (ì˜¤í”„ë¼ì¸ ì‹œë¥¼ ìœ„í•´)
    this.storeErrorLocally(errorReport)

    // ì—ëŸ¬ ë¦¬í¬íŒ… ì„œë¹„ìŠ¤ë¡œ ì „ì†¡
    this.sendErrorReport(errorReport)
  }

  private getCurrentUserId = (): string | null => {
    // ì‚¬ìš©ì ID ê°€ì ¸ì˜¤ê¸° ë¡œì§
    return localStorage.getItem('userId')
  }

  private storeErrorLocally = (errorReport: any) => {
    try {
      const storedErrors = JSON.parse(localStorage.getItem('errorLogs') || '[]')
      storedErrors.push(errorReport)
      
      // ìµœëŒ€ 50ê°œ ì—ëŸ¬ë§Œ ì €ì¥
      if (storedErrors.length > 50) {
        storedErrors.shift()
      }
      
      localStorage.setItem('errorLogs', JSON.stringify(storedErrors))
    } catch (e) {
      console.error('Failed to store error locally:', e)
    }
  }

  private sendErrorReport = async (errorReport: any) => {
    try {
      await fetch('/api/errors', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(errorReport),
      })
    } catch (e) {
      console.error('Failed to send error report:', e)
    }
  }

  private handleRetry = () => {
    const { retryCount } = this.state
    
    // ìµœëŒ€ 3ë²ˆ ì¬ì‹œë„
    if (retryCount >= 3) {
      return
    }

    this.setState({
      hasError: false,
      error: null,
      errorInfo: null,
      retryCount: retryCount + 1,
    })

    // ì ì§„ì  ì§€ì—° (1ì´ˆ, 2ì´ˆ, 4ì´ˆ)
    const delay = Math.pow(2, retryCount) * 1000
    this.retryTimeoutId = setTimeout(() => {
      // ê°•ì œ ë¦¬ë Œë”ë§
      this.forceUpdate()
    }, delay)
  }

  private handleReload = () => {
    window.location.reload()
  }

  private handleGoHome = () => {
    window.location.href = '/'
  }

  componentWillUnmount() {
    if (this.retryTimeoutId) {
      clearTimeout(this.retryTimeoutId)
    }
  }

  render() {
    if (this.state.hasError) {
      const FallbackComponent = this.props.fallback || DefaultErrorFallback
      
      return (
        <FallbackComponent
          error={this.state.error}
          errorInfo={this.state.errorInfo}
          retry={this.handleRetry}
          retryCount={this.state.retryCount}
          level={this.props.level || 'component'}
        />
      )
    }

    return this.props.children
  }
}

// ê¸°ë³¸ ì—ëŸ¬ í´ë°± ì»´í¬ë„ŒíŠ¸
const DefaultErrorFallback: React.FC<ErrorBoundaryProps> = ({
  error,
  retry,
  retryCount,
  level,
}) => {
  const isPageLevel = level === 'page'
  const canRetry = retryCount < 3

  return (
    <div className={cn(
      "flex flex-col items-center justify-center p-8 text-center",
      isPageLevel ? "min-h-screen" : "min-h-[200px]"
    )}>
      <div className="mb-4">
        <AlertTriangle className="w-12 h-12 text-destructive mx-auto mb-4" />
        <h2 className="text-xl font-semibold mb-2">
          {isPageLevel ? 'í˜ì´ì§€ ë¡œë”© ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤' : 'ì¼ì‹œì ì¸ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤'}
        </h2>
        <p className="text-muted-foreground mb-6 max-w-md">
          {error?.message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.'}
        </p>
      </div>

      <div className="flex gap-2">
        {canRetry && (
          <Button onClick={retry} variant="outline">
            <RefreshCw className="w-4 h-4 mr-2" />
            ë‹¤ì‹œ ì‹œë„ ({3 - retryCount}íšŒ ë‚¨ìŒ)
          </Button>
        )}
        
        {isPageLevel && (
          <>
            <Button onClick={() => window.location.reload()}>
              <RefreshCw className="w-4 h-4 mr-2" />
              ìƒˆë¡œê³ ì¹¨
            </Button>
            <Button onClick={() => window.location.href = '/'} variant="outline">
              <Home className="w-4 h-4 mr-2" />
              í™ˆìœ¼ë¡œ
            </Button>
          </>
        )}
      </div>

      {process.env.NODE_ENV === 'development' && error && (
        <details className="mt-6 p-4 bg-muted rounded max-w-2xl w-full text-left">
          <summary className="cursor-pointer font-medium mb-2">
            <Bug className="w-4 h-4 inline mr-2" />
            ê°œë°œì ì •ë³´
          </summary>
          <pre className="text-xs overflow-auto whitespace-pre-wrap">
            {error.stack}
          </pre>
        </details>
      )}
    </div>
  )
}

// HOC for automatic error boundary
export const withErrorBoundary = <P extends object>(
  Component: React.ComponentType<P>,
  errorBoundaryProps?: Omit<Props, 'children'>
) => {
  const WrappedComponent = (props: P) => (
    <ErrorBoundary {...errorBoundaryProps}>
      <Component {...props} />
    </ErrorBoundary>
  )

  WrappedComponent.displayName = `withErrorBoundary(${Component.displayName || Component.name})`
  
  return WrappedComponent
}
```

### **2. ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ ì²˜ë¦¬**

**HTTP í´ë¼ì´ì–¸íŠ¸ ì—ëŸ¬ ì²˜ë¦¬**
```typescript
// src/lib/http/error-handler.ts
export interface NetworkError extends Error {
  status?: number
  response?: any
  retryable: boolean
  userMessage: string
}

export class NetworkErrorHandler {
  private retryAttempts = new Map<string, number>()
  private maxRetries = 3
  private baseDelay = 1000

  async handleRequest<T>(
    requestFn: () => Promise<T>,
    options: {
      retryable?: boolean
      maxRetries?: number
      onRetry?: (attempt: number) => void
      onError?: (error: NetworkError) => void
    } = {}
  ): Promise<T> {
    const requestId = crypto.randomUUID()
    const maxRetries = options.maxRetries || this.maxRetries

    let lastError: NetworkError | null = null

    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        if (attempt > 0) {
          // ì§€ìˆ˜ì  ë°±ì˜¤í”„
          const delay = this.baseDelay * Math.pow(2, attempt - 1)
          await this.sleep(delay)
          
          options.onRetry?.(attempt)
        }

        const result = await requestFn()
        
        // ì„±ê³µ ì‹œ ì¬ì‹œë„ ì¹´ìš´í„° ë¦¬ì…‹
        this.retryAttempts.delete(requestId)
        
        return result
      } catch (error) {
        const networkError = this.createNetworkError(error)
        lastError = networkError

        // ì¬ì‹œë„ ë¶ˆê°€ëŠ¥í•œ ì—ëŸ¬ëŠ” ì¦‰ì‹œ throw
        if (!networkError.retryable || attempt >= maxRetries) {
          options.onError?.(networkError)
          throw networkError
        }

        this.retryAttempts.set(requestId, attempt)
        console.warn(`Request failed, retrying (${attempt + 1}/${maxRetries})`, networkError)
      }
    }

    throw lastError
  }

  private createNetworkError(error: any): NetworkError {
    if (error instanceof NetworkError) {
      return error
    }

    const networkError = new Error() as NetworkError
    networkError.name = 'NetworkError'

    if (error.response) {
      // HTTP ì—ëŸ¬ ì‘ë‹µì´ ìˆëŠ” ê²½ìš°
      const status = error.response.status
      networkError.status = status
      networkError.response = error.response.data
      networkError.message = error.response.data?.message || error.message
      
      networkError.retryable = this.isRetryableStatus(status)
      networkError.userMessage = this.getUserMessage(status, error.response.data)
    } else if (error.request) {
      // ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ (ìš”ì²­ì´ ì „ì†¡ë˜ì—ˆì§€ë§Œ ì‘ë‹µì´ ì—†ìŒ)
      networkError.message = 'Network error - no response received'
      networkError.retryable = true
      networkError.userMessage = 'ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì„ í™•ì¸í•´ì£¼ì„¸ìš”'
    } else {
      // ìš”ì²­ ì„¤ì • ì—ëŸ¬
      networkError.message = error.message
      networkError.retryable = false
      networkError.userMessage = 'ìš”ì²­ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤'
    }

    return networkError
  }

  private isRetryableStatus(status: number): boolean {
    // ì¬ì‹œë„ ê°€ëŠ¥í•œ HTTP ìƒíƒœ ì½”ë“œ
    const retryableStatuses = [408, 429, 502, 503, 504]
    return retryableStatuses.includes(status)
  }

  private getUserMessage(status: number, responseData: any): string {
    const statusMessages: Record<number, string> = {
      400: 'ì˜ëª»ëœ ìš”ì²­ì…ë‹ˆë‹¤',
      401: 'ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤',
      403: 'ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤',
      404: 'ìš”ì²­í•œ ë¦¬ì†ŒìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤',
      408: 'ìš”ì²­ ì‹œê°„ì´ ì´ˆê³¼ë˜ì—ˆìŠµë‹ˆë‹¤',
      409: 'ë°ì´í„° ì¶©ëŒì´ ë°œìƒí–ˆìŠµë‹ˆë‹¤',
      422: 'ì…ë ¥ ë°ì´í„°ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”',
      429: 'ìš”ì²­ì´ ë„ˆë¬´ ë§ìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”',
      500: 'ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤',
      502: 'ì„œë²„ ì—°ê²°ì— ë¬¸ì œê°€ ìˆìŠµë‹ˆë‹¤',
      503: 'ì„œë¹„ìŠ¤ë¥¼ ì¼ì‹œì ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤',
      504: 'ì„œë²„ ì‘ë‹µ ì‹œê°„ì´ ì´ˆê³¼ë˜ì—ˆìŠµë‹ˆë‹¤',
    }

    return responseData?.message || statusMessages[status] || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤'
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms))
  }
}

// API í´ë¼ì´ì–¸íŠ¸ ë˜í¼
export const apiClient = {
  errorHandler: new NetworkErrorHandler(),

  async get<T>(url: string, options?: RequestInit): Promise<T> {
    return this.errorHandler.handleRequest(
      () => fetch(url, { ...options, method: 'GET' }).then(res => res.json()),
      { retryable: true }
    )
  },

  async post<T>(url: string, data: any, options?: RequestInit): Promise<T> {
    return this.errorHandler.handleRequest(
      () => fetch(url, {
        ...options,
        method: 'POST',
        headers: { 'Content-Type': 'application/json', ...options?.headers },
        body: JSON.stringify(data)
      }).then(res => res.json()),
      { retryable: false } // POSTëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ì¬ì‹œë„í•˜ì§€ ì•ŠìŒ
    )
  },

  async put<T>(url: string, data: any, options?: RequestInit): Promise<T> {
    return this.errorHandler.handleRequest(
      () => fetch(url, {
        ...options,
        method: 'PUT',
        headers: { 'Content-Type': 'application/json', ...options?.headers },
        body: JSON.stringify(data)
      }).then(res => res.json()),
      { retryable: true }
    )
  },

  async delete<T>(url: string, options?: RequestInit): Promise<T> {
    return this.errorHandler.handleRequest(
      () => fetch(url, { ...options, method: 'DELETE' }).then(res => res.json()),
      { retryable: true }
    )
  }
}
```

### **3. React Query ì—ëŸ¬ ì²˜ë¦¬**

**Query ì—ëŸ¬ ì²˜ë¦¬**
```typescript
// src/lib/query/error-handler.ts
import { toast } from 'sonner'
import { QueryCache, MutationCache } from '@tanstack/react-query'

export const createQueryCache = () => {
  return new QueryCache({
    onError: (error, query) => {
      const networkError = error as NetworkError
      
      // ë°±ê·¸ë¼ìš´ë“œ ì¿¼ë¦¬ëŠ” í† ìŠ¤íŠ¸ í‘œì‹œ ì•ˆí•¨
      if (!query.meta?.showErrorToast) {
        return
      }

      toast.error(networkError.userMessage || 'ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤', {
        description: process.env.NODE_ENV === 'development' ? networkError.message : undefined,
        action: {
          label: 'ë‹¤ì‹œ ì‹œë„',
          onClick: () => query.reset()
        }
      })
    }
  })
}

export const createMutationCache = () => {
  return new MutationCache({
    onError: (error, variables, context, mutation) => {
      const networkError = error as NetworkError
      
      toast.error(networkError.userMessage || 'ì‘ì—… ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤', {
        description: process.env.NODE_ENV === 'development' ? networkError.message : undefined,
      })
    },
    
    onSuccess: (data, variables, context, mutation) => {
      // ì„±ê³µ ì‹œ í† ìŠ¤íŠ¸ (ì˜µì…˜)
      if (mutation.meta?.showSuccessToast) {
        toast.success('ì‘ì—…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤')
      }
    }
  })
}

// ì—ëŸ¬ê°€ ìˆëŠ” ì¿¼ë¦¬ ì¬ì‹œë„ í›…
export const useRetryFailedQueries = () => {
  const queryClient = useQueryClient()
  
  const retryFailed = useCallback(() => {
    // ì‹¤íŒ¨í•œ ëª¨ë“  ì¿¼ë¦¬ ì¬ì‹œë„
    queryClient.getQueryCache().getAll().forEach(query => {
      if (query.state.error) {
        query.fetch()
      }
    })
  }, [queryClient])
  
  const retryFailedCount = queryClient.getQueryCache()
    .getAll()
    .filter(query => query.state.error).length
  
  return {
    retryFailed,
    retryFailedCount,
    hasFailedQueries: retryFailedCount > 0
  }
}
```

### **4. ì‚¬ìš©ì ì¹œí™”ì  ì—ëŸ¬ UI**

**ì—ëŸ¬ í† ìŠ¤íŠ¸ ë° ì•Œë¦¼**
```typescript
// src/components/error/ErrorNotification.tsx
import React from 'react'
import { toast } from 'sonner'
import { AlertCircle, Wifi, WifiOff, RefreshCw } from 'lucide-react'
import { Button } from '@/components/ui/button'

export class ErrorNotificationManager {
  private static activeToasts = new Set<string>()

  static showNetworkError(error: NetworkError, options: {
    retry?: () => void
    persistent?: boolean
  } = {}) {
    const toastId = `network-error-${error.status || 'unknown'}`
    
    // ì¤‘ë³µ í† ìŠ¤íŠ¸ ë°©ì§€
    if (this.activeToasts.has(toastId)) {
      return
    }
    
    this.activeToasts.add(toastId)
    
    toast.error(error.userMessage, {
      id: toastId,
      description: navigator.onLine ? undefined : 'ì¸í„°ë„· ì—°ê²°ì„ í™•ì¸í•´ì£¼ì„¸ìš”',
      icon: navigator.onLine ? <AlertCircle /> : <WifiOff />,
      duration: options.persistent ? Infinity : 5000,
      action: options.retry ? {
        label: 'ë‹¤ì‹œ ì‹œë„',
        onClick: options.retry
      } : undefined,
      onDismiss: () => this.activeToasts.delete(toastId),
      onAutoClose: () => this.activeToasts.delete(toastId)
    })
  }

  static showConnectionRestored() {
    toast.success('ì¸í„°ë„· ì—°ê²°ì´ ë³µêµ¬ë˜ì—ˆìŠµë‹ˆë‹¤', {
      icon: <Wifi className="text-green-500" />,
      duration: 3000
    })
  }

  static showDataSaved() {
    toast.success('ë°ì´í„°ê°€ ë¡œì»¬ì— ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤', {
      description: 'ì¸í„°ë„· ì—°ê²° ì‹œ ìë™ ë™ê¸°í™”ë©ë‹ˆë‹¤',
      duration: 4000
    })
  }

  static showSyncCompleted() {
    toast.success('ì˜¤í”„ë¼ì¸ ë°ì´í„°ê°€ ë™ê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤', {
      duration: 3000
    })
  }
}

// ì—°ê²° ìƒíƒœ ëª¨ë‹ˆí„°ë§
export const ConnectionStatusMonitor: React.FC = () => {
  const [isOnline, setIsOnline] = useState(navigator.onLine)
  const [wasOffline, setWasOffline] = useState(false)
  const { retryFailed, hasFailedQueries } = useRetryFailedQueries()

  useEffect(() => {
    const handleOnline = () => {
      setIsOnline(true)
      
      if (wasOffline) {
        ErrorNotificationManager.showConnectionRestored()
        
        // ì‹¤íŒ¨í•œ ì¿¼ë¦¬ ìë™ ì¬ì‹œë„
        if (hasFailedQueries) {
          setTimeout(retryFailed, 1000)
        }
        
        setWasOffline(false)
      }
    }

    const handleOffline = () => {
      setIsOnline(false)
      setWasOffline(true)
      
      toast.warning('ì¸í„°ë„· ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤', {
        description: 'ì˜¤í”„ë¼ì¸ ëª¨ë“œë¡œ ì „í™˜ë©ë‹ˆë‹¤',
        icon: <WifiOff />,
        duration: 4000
      })
    }

    window.addEventListener('online', handleOnline)
    window.addEventListener('offline', handleOffline)

    return () => {
      window.removeEventListener('online', handleOnline)
      window.removeEventListener('offline', handleOffline)
    }
  }, [wasOffline, hasFailedQueries, retryFailed])

  // ì˜¤í”„ë¼ì¸ ìƒíƒœ í‘œì‹œ
  if (!isOnline) {
    return (
      <div className="fixed top-4 left-1/2 transform -translate-x-1/2 z-50">
        <div className="bg-orange-100 border border-orange-400 text-orange-700 px-4 py-2 rounded-lg flex items-center gap-2 shadow-lg">
          <WifiOff className="w-4 h-4" />
          <span className="text-sm font-medium">ì˜¤í”„ë¼ì¸ ëª¨ë“œ</span>
        </div>
      </div>
    )
  }

  return null
}
```

### **5. ë°ì´í„° ë³µêµ¬ ì‹œìŠ¤í…œ**

**ë¡œì»¬ ë°ì´í„° ë°±ì—… ë° ë³µêµ¬**
```typescript
// src/lib/recovery/data-recovery.ts
export class DataRecoveryManager {
  private storageKey = 'baro-calendar-backup'
  private maxBackups = 10

  // ë°ì´í„° ë°±ì—…
  async backupData(data: any, operation: string) {
    try {
      const backup = {
        id: crypto.randomUUID(),
        timestamp: Date.now(),
        operation,
        data: JSON.parse(JSON.stringify(data)), // Deep clone
      }

      const existingBackups = this.getBackups()
      const newBackups = [backup, ...existingBackups].slice(0, this.maxBackups)
      
      localStorage.setItem(this.storageKey, JSON.stringify(newBackups))
    } catch (error) {
      console.error('Failed to backup data:', error)
    }
  }

  // ë°±ì—… ëª©ë¡ ì¡°íšŒ
  getBackups(): Array<{
    id: string
    timestamp: number
    operation: string
    data: any
  }> {
    try {
      const backups = localStorage.getItem(this.storageKey)
      return backups ? JSON.parse(backups) : []
    } catch (error) {
      console.error('Failed to get backups:', error)
      return []
    }
  }

  // ë°ì´í„° ë³µêµ¬
  async recoverData(backupId: string): Promise<any | null> {
    try {
      const backups = this.getBackups()
      const backup = backups.find(b => b.id === backupId)
      
      if (!backup) {
        throw new Error('Backup not found')
      }

      return backup.data
    } catch (error) {
      console.error('Failed to recover data:', error)
      return null
    }
  }

  // ìë™ ë³µêµ¬ ì‹œë„
  async attemptAutoRecovery(errorContext: string): Promise<boolean> {
    try {
      const recentBackups = this.getBackups()
        .filter(backup => Date.now() - backup.timestamp < 60000) // 1ë¶„ ì´ë‚´
        .slice(0, 3)

      for (const backup of recentBackups) {
        try {
          // ë°±ì—… ë°ì´í„°ë¡œ ìƒíƒœ ë³µêµ¬ ì‹œë„
          await this.restoreFromBackup(backup)
          
          toast.success('ë°ì´í„°ê°€ ë³µêµ¬ë˜ì—ˆìŠµë‹ˆë‹¤', {
            description: `${new Date(backup.timestamp).toLocaleTimeString()} ì‹œì ìœ¼ë¡œ ë³µêµ¬ë¨`
          })
          
          return true
        } catch (restoreError) {
          continue
        }
      }

      return false
    } catch (error) {
      console.error('Auto recovery failed:', error)
      return false
    }
  }

  private async restoreFromBackup(backup: any) {
    // ìƒíƒœ ê´€ë¦¬ ìŠ¤í† ì–´ì— ë°±ì—… ë°ì´í„° ì ìš©
    const stores = await import('@/stores')
    
    if (backup.data.calendar) {
      stores.useCalendarStore.setState(backup.data.calendar)
    }
    
    if (backup.data.projects) {
      stores.useProjectStore.setState(backup.data.projects)
    }
  }

  // ë°±ì—… ì •ë¦¬
  cleanupOldBackups() {
    try {
      const backups = this.getBackups()
      const oneWeekAgo = Date.now() - (7 * 24 * 60 * 60 * 1000)
      
      const validBackups = backups.filter(backup => 
        backup.timestamp > oneWeekAgo
      ).slice(0, this.maxBackups)
      
      localStorage.setItem(this.storageKey, JSON.stringify(validBackups))
    } catch (error) {
      console.error('Failed to cleanup backups:', error)
    }
  }
}

// ìë™ ë°±ì—… í›…
export const useAutoBackup = () => {
  const recoveryManager = useMemo(() => new DataRecoveryManager(), [])
  const calendarState = useCalendarStore()
  const projectState = useProjectStore()
  
  // ìƒíƒœ ë³€ê²½ ì‹œ ìë™ ë°±ì—…
  useEffect(() => {
    const backupData = {
      calendar: calendarState,
      projects: projectState,
    }
    
    recoveryManager.backupData(backupData, 'state-change')
  }, [calendarState, projectState, recoveryManager])
  
  // í˜ì´ì§€ ì–¸ë¡œë“œ ì‹œ ë°±ì—…
  useEffect(() => {
    const handleBeforeUnload = () => {
      const backupData = {
        calendar: calendarState,
        projects: projectState,
      }
      
      recoveryManager.backupData(backupData, 'page-unload')
    }
    
    window.addEventListener('beforeunload', handleBeforeUnload)
    return () => window.removeEventListener('beforeunload', handleBeforeUnload)
  }, [calendarState, projectState, recoveryManager])
  
  return recoveryManager
}
```

### **6. ì—ëŸ¬ ë³´ê³  ë° ëª¨ë‹ˆí„°ë§**

**ì—ëŸ¬ ë³´ê³  ì‹œìŠ¤í…œ**
```typescript
// src/lib/monitoring/error-reporting.ts
export class ErrorReportingService {
  private endpoint = '/api/errors'
  private batchSize = 10
  private flushInterval = 30000 // 30ì´ˆ
  private errorQueue: any[] = []
  private flushTimer: NodeJS.Timeout | null = null

  constructor() {
    this.startBatchProcessing()
    this.setupGlobalErrorHandlers()
  }

  // ì—ëŸ¬ ë³´ê³ 
  reportError(error: Error | NetworkError, context: {
    component?: string
    action?: string
    userId?: string
    sessionId?: string
    metadata?: any
  } = {}) {
    const errorReport = {
      id: crypto.randomUUID(),
      timestamp: Date.now(),
      message: error.message,
      stack: error.stack,
      name: error.name,
      url: window.location.href,
      userAgent: navigator.userAgent,
      ...context,
      // ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ íŠ¹ë³„ ì²˜ë¦¬
      ...('status' in error && {
        httpStatus: error.status,
        retryable: error.retryable,
        userMessage: error.userMessage,
      }),
    }

    this.errorQueue.push(errorReport)

    // ì¦‰ì‹œ ì²˜ë¦¬ê°€ í•„ìš”í•œ ì‹¬ê°í•œ ì—ëŸ¬
    if (this.isCriticalError(error)) {
      this.flushErrors()
    }
  }

  private isCriticalError(error: Error): boolean {
    return (
      error.name === 'ChunkLoadError' ||
      error.message.includes('Loading chunk') ||
      error.message.includes('Script error')
    )
  }

  private startBatchProcessing() {
    this.flushTimer = setInterval(() => {
      this.flushErrors()
    }, this.flushInterval)
  }

  private async flushErrors() {
    if (this.errorQueue.length === 0) return

    const batch = this.errorQueue.splice(0, this.batchSize)
    
    try {
      await fetch(this.endpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ errors: batch })
      })
    } catch (e) {
      // ì „ì†¡ ì‹¤íŒ¨ ì‹œ ë‹¤ì‹œ íì— ë„£ê¸° (ìµœëŒ€ 1íšŒ)
      batch.forEach(error => {
        if (!error._retried) {
          error._retried = true
          this.errorQueue.unshift(error)
        }
      })
    }
  }

  private setupGlobalErrorHandlers() {
    // ì²˜ë¦¬ë˜ì§€ ì•Šì€ Promise rejection
    window.addEventListener('unhandledrejection', (event) => {
      this.reportError(new Error(event.reason), {
        component: 'global',
        action: 'unhandled-promise-rejection'
      })
    })

    // JavaScript ì—ëŸ¬
    window.addEventListener('error', (event) => {
      this.reportError(new Error(event.message), {
        component: 'global',
        action: 'javascript-error',
        metadata: {
          filename: event.filename,
          lineno: event.lineno,
          colno: event.colno
        }
      })
    })

    // ë¦¬ì†ŒìŠ¤ ë¡œë”© ì—ëŸ¬
    window.addEventListener('error', (event) => {
      if (event.target && event.target !== window) {
        const element = event.target as HTMLElement
        this.reportError(new Error(`Resource loading failed: ${element.tagName}`), {
          component: 'global',
          action: 'resource-load-error',
          metadata: {
            tagName: element.tagName,
            src: (element as any).src || (element as any).href
          }
        })
      }
    }, true)
  }

  // ì •ë¦¬
  destroy() {
    if (this.flushTimer) {
      clearInterval(this.flushTimer)
    }
    this.flushErrors() // ë§ˆì§€ë§‰ ë°°ì¹˜ ì „ì†¡
  }
}

// ì „ì—­ ì—ëŸ¬ ë¦¬í¬íŒ… ì¸ìŠ¤í„´ìŠ¤
export const errorReporting = new ErrorReportingService()
```

---

## ğŸ“Š **ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ**

### **ì—ëŸ¬ ë©”íŠ¸ë¦­ ìˆ˜ì§‘**
```typescript
// src/lib/monitoring/metrics.ts
export const collectErrorMetrics = () => {
  return {
    errorRate: calculateErrorRate(),
    commonErrors: getCommonErrors(),
    browserSupport: getBrowserErrorStats(),
    userImpact: getUserImpactMetrics(),
  }
}
```

---

## âœ… **Definition of Done**

### **ê¸°ëŠ¥ ìš”êµ¬ì‚¬í•­**
- [ ] ê¸€ë¡œë²Œ ì—ëŸ¬ ë°”ìš´ë”ë¦¬ êµ¬í˜„
- [ ] ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ ìë™ ì¬ì‹œë„
- [ ] ì‚¬ìš©ì ì¹œí™”ì  ì—ëŸ¬ ë©”ì‹œì§€
- [ ] ì˜¤í”„ë¼ì¸ ë°ì´í„° ë³µêµ¬
- [ ] ìë™ ì—ëŸ¬ ë³´ê³ 

### **ê¸°ìˆ  ìš”êµ¬ì‚¬í•­**
- [ ] React Error Boundary
- [ ] HTTP ì—ëŸ¬ ì²˜ë¦¬ ë˜í¼
- [ ] ë¡œì»¬ ë°ì´í„° ë°±ì—…
- [ ] ì—ëŸ¬ ë¡œê¹… ì‹œìŠ¤í…œ

### **ì‚¬ìš©ì„± ìš”êµ¬ì‚¬í•­**
- [ ] ëª…í™•í•œ ì—ëŸ¬ ë©”ì‹œì§€
- [ ] ë³µêµ¬ ì•¡ì…˜ ì œê³µ
- [ ] ì˜¤í”„ë¼ì¸ ëª¨ë“œ ì§€ì›
- [ ] ë°ì´í„° ì†ì‹¤ ë°©ì§€

### **ëª¨ë‹ˆí„°ë§ ìš”êµ¬ì‚¬í•­**
- [ ] ì—ëŸ¬ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
- [ ] ì‹¤ì‹œê°„ ì—ëŸ¬ ì•Œë¦¼
- [ ] ì—ëŸ¬ íŠ¸ë Œë“œ ë¶„ì„
- [ ] ì‚¬ìš©ì ì˜í–¥ë„ ì¸¡ì •

---

## ğŸ“š **ê´€ë ¨ ë¬¸ì„œ ì°¸ì¡°**

- [20. Error Handling](../ui-architecture/20-error-handling.md)
- [21. Observability & Monitoring](../ui-architecture/21-observability-monitoring.md)
- [04. State Management](../ui-architecture/04-state-management.md)

---

**ì´ ìŠ¤í† ë¦¬ëŠ” ë°”ë¡œìº˜ë¦°ë”ì˜ ì•ˆì •ì ì¸ ì—ëŸ¬ ì²˜ë¦¬ ë° ë³µêµ¬ ì‹œìŠ¤í…œ êµ¬í˜„ì„ ìœ„í•œ ê¸°ìˆ  ê°€ì´ë“œì…ë‹ˆë‹¤. ì‚¬ìš©ìì—ê²Œ ì¤‘ë‹¨ ì—†ëŠ” ì„œë¹„ìŠ¤ ê²½í—˜ì„ ì œê³µí•˜ê³  ê°œë°œíŒ€ì—ê²Œ ì‹ ì†í•œ ë¬¸ì œ í•´ê²° ë„êµ¬ë¥¼ ì œê³µí•©ë‹ˆë‹¤.**