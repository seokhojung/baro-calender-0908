# Story 1.10: 디자인 시스템 및 테마 구현

## Status
Ready for Development

## Priority & Dependencies
- **Priority**: P1 (High)
- **Story Points**: 5
- **Dependencies**: [1.1b]
- **Blocked By**: None

## Success Metrics
- **Business KPI**: 
  - 테마 전환 사용률 40% 이상
  - 색상 구분 만족도 4.5/5.0 이상
  - 접근성 준수율 100%
- **Technical KPI**:
  - 테마 전환 시간 300ms 이내
  - 색상 대비비 4.5:1 이상 (WCAG AA)
  - CSS 변수 적용률 100%
- **Definition of Success**: 모든 테마 정상 작동, 접근성 기준 충족

---

## 🎯 **스토리 목표**

**완전한 디자인 시스템 및 테마 구현**
- 8가지 프로젝트 색상 기반 디자인 토큰 시스템
- 라이트/다크 테마 지원 및 자동 전환
- 접근성 준수 타이포그래피 및 간격 시스템
- 반응형 디자인 및 모바일 최적화
- 컴포넌트 스타일링 패턴 및 테마 커스터마이징

---

## Story
**As a** 사용자,
**I want** 프로젝트별 색상 구분과 라이트/다크 테마를 지원하는 일관된 디자인 시스템을 사용하여,
**so that** 모든 디바이스에서 접근 가능하고 시각적으로 구분되는 편안한 환경에서 작업할 수 있다.

## Acceptance Criteria
1. 프로젝트별로 구분된 색상으로 일정을 시각적으로 구분하고 싶다
2. 라이트/다크 테마를 선택하여 편안한 환경에서 작업하고 싶다
3. 모든 디바이스에서 일관된 디자인과 사용성을 경험하고 싶다
4. 접근성이 보장된 글꼴과 색상 대비로 편리하게 사용하고 싶다
5. 개인 취향에 맞게 테마를 커스터마이징하고 싶다

---

## 🏗️ **기술적 구현 요구사항**

### **1. Design Tokens 시스템 구현**

**CSS Variables 기반 디자인 토큰**
```css
/* src/styles/design-tokens.css */
:root {
  /* 프로젝트 색상 시스템 - 8가지 기본 색상 */
  --project-blue: #3B82F6;
  --project-green: #10B981;
  --project-purple: #8B5CF6;
  --project-orange: #F59E0B;
  --project-red: #EF4444;
  --project-teal: #14B8A6;
  --project-pink: #EC4899;
  --project-indigo: #6366F1;
  
  /* 시맨틱 색상 */
  --primary: var(--project-blue);
  --primary-foreground: #ffffff;
  --secondary: #f8fafc;
  --secondary-foreground: #0f172a;
  --accent: #f1f5f9;
  --accent-foreground: #0f172a;
  --destructive: #ef4444;
  --destructive-foreground: #ffffff;
  --muted: #f8fafc;
  --muted-foreground: #64748b;
  --border: #e2e8f0;
  --input: #e2e8f0;
  --ring: var(--primary);
  --background: #ffffff;
  --foreground: #0f172a;
  --card: #ffffff;
  --card-foreground: #0f172a;
  --popover: #ffffff;
  --popover-foreground: #0f172a;
  
  /* 타이포그래피 */
  --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
  --font-mono: 'JetBrains Mono', 'Fira Code', 'Monaco', 'Consolas', monospace;
  
  /* 간격 시스템 */
  --spacing-xs: 0.25rem;    /* 4px */
  --spacing-sm: 0.5rem;     /* 8px */
  --spacing-md: 1rem;       /* 16px */
  --spacing-lg: 1.5rem;     /* 24px */
  --spacing-xl: 2rem;       /* 32px */
  --spacing-2xl: 3rem;      /* 48px */
  --spacing-3xl: 4rem;      /* 64px */
  
  /* 그림자 시스템 */
  --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
  --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
  --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
  --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
  
  /* 애니메이션 */
  --transition-fast: 150ms ease-in-out;
  --transition-normal: 300ms ease-in-out;
  --transition-slow: 500ms ease-in-out;
  
  /* 반응형 브레이크포인트 */
  --breakpoint-sm: 640px;
  --breakpoint-md: 768px;
  --breakpoint-lg: 1024px;
  --breakpoint-xl: 1280px;
  --breakpoint-2xl: 1536px;
}

/* 다크 모드 */
[data-theme="dark"] {
  --background: #0f172a;
  --foreground: #f8fafc;
  --card: #1e293b;
  --card-foreground: #f8fafc;
  --popover: #1e293b;
  --popover-foreground: #f8fafc;
  --primary: #3b82f6;
  --primary-foreground: #ffffff;
  --secondary: #1e293b;
  --secondary-foreground: #f8fafc;
  --muted: #1e293b;
  --muted-foreground: #64748b;
  --accent: #1e293b;
  --accent-foreground: #f8fafc;
  --destructive: #ef4444;
  --destructive-foreground: #ffffff;
  --border: #334155;
  --input: #334155;
  --ring: #3b82f6;
}
```

**TypeScript 색상 시스템**
```typescript
// src/lib/design-tokens/colors.ts
export const PROJECT_COLORS = {
  blue: {
    50: '#EFF6FF',
    100: '#DBEAFE', 
    200: '#BFDBFE',
    300: '#93C5FD',
    400: '#60A5FA',
    500: '#3B82F6', // 기본값
    600: '#2563EB',
    700: '#1D4ED8',
    800: '#1E40AF',
    900: '#1E3A8A',
  },
  green: {
    50: '#ECFDF5',
    100: '#D1FAE5',
    200: '#A7F3D0',
    300: '#6EE7B7',
    400: '#34D399',
    500: '#10B981', // 기본값
    600: '#059669',
    700: '#047857',
    800: '#065F46',
    900: '#064E3B',
  },
  purple: {
    50: '#F5F3FF',
    100: '#EDE9FE',
    200: '#DDD6FE',
    300: '#C4B5FD',
    400: '#A78BFA',
    500: '#8B5CF6', // 기본값
    600: '#7C3AED',
    700: '#6D28D9',
    800: '#5B21B6',
    900: '#4C1D95',
  },
  orange: {
    50: '#FFFBEB',
    100: '#FEF3C7',
    200: '#FDE68A',
    300: '#FCD34D',
    400: '#FBBF24',
    500: '#F59E0B', // 기본값
    600: '#D97706',
    700: '#B45309',
    800: '#92400E',
    900: '#78350F',
  },
  red: {
    50: '#FEF2F2',
    100: '#FEE2E2',
    200: '#FECACA',
    300: '#FCA5A5',
    400: '#F87171',
    500: '#EF4444', // 기본값
    600: '#DC2626',
    700: '#B91C1C',
    800: '#991B1B',
    900: '#7F1D1D',
  },
  teal: {
    50: '#F0FDFA',
    100: '#CCFBF1',
    200: '#99F6E4',
    300: '#5EEAD4',
    400: '#2DD4BF',
    500: '#14B8A6', // 기본값
    600: '#0D9488',
    700: '#0F766E',
    800: '#115E59',
    900: '#134E4A',
  },
  pink: {
    50: '#FDF2F8',
    100: '#FCE7F3',
    200: '#FBCFE8',
    300: '#F9A8D4',
    400: '#F472B6',
    500: '#EC4899', // 기본값
    600: '#DB2777',
    700: '#BE185D',
    800: '#9D174D',
    900: '#831843',
  },
  indigo: {
    50: '#EEF2FF',
    100: '#E0E7FF',
    200: '#C7D2FE',
    300: '#A5B4FC',
    400: '#818CF8',
    500: '#6366F1', // 기본값
    600: '#4F46E5',
    700: '#4338CA',
    800: '#3730A3',
    900: '#312E81',
  },
} as const

export type ProjectColor = keyof typeof PROJECT_COLORS
export type ColorScale = keyof (typeof PROJECT_COLORS)[ProjectColor]

// 색상 유틸리티 함수
export const getProjectColor = (color: ProjectColor, scale: ColorScale = 500) => {
  return PROJECT_COLORS[color][scale]
}

export const getCSSVariable = (name: string) => `var(--${name})`
```

### **2. 테마 관리 시스템**

**테마 상태 관리 (Zustand)**
```typescript
// src/stores/themeStore.ts
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

type ThemeMode = 'light' | 'dark' | 'system'
type ProjectColorTheme = ProjectColor

interface ThemeState {
  // 테마 상태
  mode: ThemeMode
  primaryColor: ProjectColorTheme
  fontSize: 'small' | 'medium' | 'large'
  reducedMotion: boolean
  highContrast: boolean
  
  // 사용자 설정
  customColors: Record<string, string>
  
  // Actions
  setMode: (mode: ThemeMode) => void
  setPrimaryColor: (color: ProjectColorTheme) => void
  setFontSize: (size: 'small' | 'medium' | 'large') => void
  setReducedMotion: (enabled: boolean) => void
  setHighContrast: (enabled: boolean) => void
  updateCustomColor: (key: string, color: string) => void
  
  // 테마 적용
  applyTheme: () => void
  resetToDefaults: () => void
}

export const useThemeStore = create<ThemeState>()(
  persist(
    (set, get) => ({
      mode: 'system',
      primaryColor: 'blue',
      fontSize: 'medium',
      reducedMotion: false,
      highContrast: false,
      customColors: {},
      
      setMode: (mode) => {
        set({ mode })
        get().applyTheme()
      },
      
      setPrimaryColor: (color) => {
        set({ primaryColor: color })
        get().applyTheme()
      },
      
      setFontSize: (fontSize) => {
        set({ fontSize })
        get().applyTheme()
      },
      
      setReducedMotion: (reducedMotion) => {
        set({ reducedMotion })
        get().applyTheme()
      },
      
      setHighContrast: (highContrast) => {
        set({ highContrast })
        get().applyTheme()
      },
      
      updateCustomColor: (key, color) => {
        set((state) => ({
          customColors: { ...state.customColors, [key]: color }
        }))
        get().applyTheme()
      },
      
      applyTheme: () => {
        const state = get()
        const root = document.documentElement
        
        // 다크/라이트 모드 적용
        if (state.mode === 'system') {
          const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches
          root.setAttribute('data-theme', isDark ? 'dark' : 'light')
        } else {
          root.setAttribute('data-theme', state.mode)
        }
        
        // 주 색상 적용
        root.style.setProperty('--primary', getProjectColor(state.primaryColor))
        
        // 폰트 크기 적용
        const fontSizes = {
          small: '14px',
          medium: '16px',
          large: '18px'
        }
        root.style.setProperty('--base-font-size', fontSizes[state.fontSize])
        
        // 모션 설정
        if (state.reducedMotion) {
          root.style.setProperty('--transition-fast', 'none')
          root.style.setProperty('--transition-normal', 'none')
          root.style.setProperty('--transition-slow', 'none')
        }
        
        // 고대비 모드
        if (state.highContrast) {
          root.classList.add('high-contrast')
        } else {
          root.classList.remove('high-contrast')
        }
        
        // 커스텀 색상 적용
        Object.entries(state.customColors).forEach(([key, color]) => {
          root.style.setProperty(`--custom-${key}`, color)
        })
      },
      
      resetToDefaults: () => {
        set({
          mode: 'system',
          primaryColor: 'blue',
          fontSize: 'medium',
          reducedMotion: false,
          highContrast: false,
          customColors: {}
        })
        get().applyTheme()
      }
    }),
    {
      name: 'theme-store',
      partialize: (state) => ({
        mode: state.mode,
        primaryColor: state.primaryColor,
        fontSize: state.fontSize,
        reducedMotion: state.reducedMotion,
        highContrast: state.highContrast,
        customColors: state.customColors
      })
    }
  )
)

// 시스템 테마 변경 감지
export const useSystemTheme = () => {
  const { mode, applyTheme } = useThemeStore()
  
  useEffect(() => {
    if (mode !== 'system') return
    
    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)')
    const handleChange = () => applyTheme()
    
    mediaQuery.addEventListener('change', handleChange)
    return () => mediaQuery.removeEventListener('change', handleChange)
  }, [mode, applyTheme])
}
```

### **3. 타이포그래피 시스템**

**타이포그래피 컴포넌트**
```typescript
// src/components/ui/Typography.tsx
interface TypographyProps {
  variant: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6' | 'body1' | 'body2' | 'caption' | 'overline'
  children: React.ReactNode
  className?: string
  as?: React.ElementType
  color?: 'default' | 'muted' | 'primary' | 'secondary' | 'destructive'
  weight?: 'normal' | 'medium' | 'semibold' | 'bold'
  align?: 'left' | 'center' | 'right' | 'justify'
}

const typographyVariants = {
  h1: 'text-4xl font-bold leading-tight tracking-tight',
  h2: 'text-3xl font-semibold leading-tight tracking-tight',
  h3: 'text-2xl font-semibold leading-snug',
  h4: 'text-xl font-medium leading-snug',
  h5: 'text-lg font-medium leading-normal',
  h6: 'text-base font-medium leading-normal',
  body1: 'text-base leading-relaxed',
  body2: 'text-sm leading-relaxed',
  caption: 'text-xs leading-normal text-muted-foreground',
  overline: 'text-xs font-medium uppercase tracking-wider text-muted-foreground',
} as const

const colorVariants = {
  default: 'text-foreground',
  muted: 'text-muted-foreground',
  primary: 'text-primary',
  secondary: 'text-secondary-foreground',
  destructive: 'text-destructive',
} as const

const weightVariants = {
  normal: 'font-normal',
  medium: 'font-medium',
  semibold: 'font-semibold',
  bold: 'font-bold',
} as const

const alignVariants = {
  left: 'text-left',
  center: 'text-center',
  right: 'text-right',
  justify: 'text-justify',
} as const

export const Typography: React.FC<TypographyProps> = ({
  variant,
  children,
  className,
  as,
  color = 'default',
  weight,
  align = 'left',
}) => {
  const Component = as || getDefaultElement(variant)
  
  return (
    <Component 
      className={cn(
        typographyVariants[variant],
        colorVariants[color],
        weight && weightVariants[weight],
        alignVariants[align],
        className
      )}
    >
      {children}
    </Component>
  )
}

const getDefaultElement = (variant: TypographyProps['variant']): React.ElementType => {
  switch (variant) {
    case 'h1': return 'h1'
    case 'h2': return 'h2'
    case 'h3': return 'h3'
    case 'h4': return 'h4'
    case 'h5': return 'h5'
    case 'h6': return 'h6'
    case 'overline': return 'span'
    default: return 'p'
  }
}

// 사용 예시
export const TypographyExample = () => (
  <div className="space-y-4">
    <Typography variant="h1" color="primary">
      바로캘린더
    </Typography>
    <Typography variant="body1" color="muted">
      프로젝트 기반 일정 관리 시스템
    </Typography>
    <Typography variant="caption" align="center">
      © 2025 Baro Calendar. All rights reserved.
    </Typography>
  </div>
)
```

### **4. 반응형 디자인 시스템**

**반응형 유틸리티 훅**
```typescript
// src/hooks/useResponsive.ts
import { useEffect, useState } from 'react'

type Breakpoint = 'sm' | 'md' | 'lg' | 'xl' | '2xl'
type BreakpointValues = Record<Breakpoint, number>

const breakpoints: BreakpointValues = {
  sm: 640,
  md: 768,
  lg: 1024,
  xl: 1280,
  '2xl': 1536,
}

export const useResponsive = () => {
  const [windowWidth, setWindowWidth] = useState<number>(0)
  
  useEffect(() => {
    if (typeof window === 'undefined') return
    
    const handleResize = () => setWindowWidth(window.innerWidth)
    handleResize() // 초기값 설정
    
    window.addEventListener('resize', handleResize)
    return () => window.removeEventListener('resize', handleResize)
  }, [])
  
  const isBreakpoint = (breakpoint: Breakpoint) => {
    return windowWidth >= breakpoints[breakpoint]
  }
  
  const isMobile = !isBreakpoint('sm')
  const isTablet = isBreakpoint('sm') && !isBreakpoint('lg')
  const isDesktop = isBreakpoint('lg')
  
  const currentBreakpoint = (): Breakpoint => {
    if (windowWidth >= breakpoints['2xl']) return '2xl'
    if (windowWidth >= breakpoints.xl) return 'xl'
    if (windowWidth >= breakpoints.lg) return 'lg'
    if (windowWidth >= breakpoints.md) return 'md'
    if (windowWidth >= breakpoints.sm) return 'sm'
    return 'sm' // 기본값
  }
  
  return {
    windowWidth,
    isBreakpoint,
    isMobile,
    isTablet,
    isDesktop,
    currentBreakpoint: currentBreakpoint(),
  }
}

// 반응형 그리드 컴포넌트
export interface ResponsiveGridProps {
  children: React.ReactNode
  cols?: {
    default?: number
    sm?: number
    md?: number
    lg?: number
    xl?: number
    '2xl'?: number
  }
  gap?: number
  className?: string
}

export const ResponsiveGrid: React.FC<ResponsiveGridProps> = ({
  children,
  cols = { default: 1, md: 2, lg: 3 },
  gap = 4,
  className,
}) => {
  const gridClasses = [
    cols.default && `grid-cols-${cols.default}`,
    cols.sm && `sm:grid-cols-${cols.sm}`,
    cols.md && `md:grid-cols-${cols.md}`,
    cols.lg && `lg:grid-cols-${cols.lg}`,
    cols.xl && `xl:grid-cols-${cols.xl}`,
    cols['2xl'] && `2xl:grid-cols-${cols['2xl']}`,
    `gap-${gap}`,
  ].filter(Boolean).join(' ')
  
  return (
    <div className={cn('grid', gridClasses, className)}>
      {children}
    </div>
  )
}
```

### **5. 테마 커스터마이징 UI**

**테마 설정 컴포넌트**
```typescript
// src/components/settings/ThemeSettings.tsx
export const ThemeSettings = () => {
  const { 
    mode, primaryColor, fontSize, reducedMotion, highContrast,
    setMode, setPrimaryColor, setFontSize, setReducedMotion, setHighContrast,
    resetToDefaults
  } = useThemeStore()

  return (
    <Card className="w-full max-w-2xl">
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <Palette className="w-5 h-5" />
          테마 설정
        </CardTitle>
        <CardDescription>
          원하는 테마를 선택하여 개인화된 환경을 만들어보세요.
        </CardDescription>
      </CardHeader>
      
      <CardContent className="space-y-6">
        {/* 다크모드 설정 */}
        <div className="space-y-3">
          <Typography variant="h6">모드 설정</Typography>
          <Tabs value={mode} onValueChange={(value) => setMode(value as ThemeMode)}>
            <TabsList className="grid w-full grid-cols-3">
              <TabsTrigger value="light" className="flex items-center gap-2">
                <Sun className="w-4 h-4" />
                라이트
              </TabsTrigger>
              <TabsTrigger value="dark" className="flex items-center gap-2">
                <Moon className="w-4 h-4" />
                다크
              </TabsTrigger>
              <TabsTrigger value="system" className="flex items-center gap-2">
                <Monitor className="w-4 h-4" />
                자동
              </TabsTrigger>
            </TabsList>
          </Tabs>
        </div>
        
        {/* 주 색상 선택 */}
        <div className="space-y-3">
          <Typography variant="h6">주 색상</Typography>
          <div className="grid grid-cols-4 gap-3">
            {Object.keys(PROJECT_COLORS).map((color) => (
              <button
                key={color}
                onClick={() => setPrimaryColor(color as ProjectColor)}
                className={cn(
                  'w-12 h-12 rounded-full border-2 transition-all',
                  primaryColor === color ? 'border-ring scale-110' : 'border-transparent hover:scale-105'
                )}
                style={{ 
                  backgroundColor: getProjectColor(color as ProjectColor),
                }}
                aria-label={`${color} 색상 선택`}
              >
                {primaryColor === color && (
                  <Check className="w-6 h-6 text-white mx-auto" />
                )}
              </button>
            ))}
          </div>
        </div>
        
        {/* 폰트 크기 설정 */}
        <div className="space-y-3">
          <Typography variant="h6">폰트 크기</Typography>
          <Select value={fontSize} onValueChange={(value) => setFontSize(value as any)}>
            <SelectTrigger>
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="small">작게 (14px)</SelectItem>
              <SelectItem value="medium">보통 (16px)</SelectItem>
              <SelectItem value="large">크게 (18px)</SelectItem>
            </SelectContent>
          </Select>
        </div>
        
        {/* 접근성 설정 */}
        <div className="space-y-4">
          <Typography variant="h6">접근성</Typography>
          
          <div className="flex items-center justify-between">
            <div className="space-y-1">
              <Typography variant="body2" weight="medium">
                애니메이션 줄이기
              </Typography>
              <Typography variant="caption" color="muted">
                모션 민감성이 있는 경우 애니메이션을 비활성화합니다
              </Typography>
            </div>
            <Switch
              checked={reducedMotion}
              onCheckedChange={setReducedMotion}
            />
          </div>
          
          <div className="flex items-center justify-between">
            <div className="space-y-1">
              <Typography variant="body2" weight="medium">
                고대비 모드
              </Typography>
              <Typography variant="caption" color="muted">
                더 높은 색상 대비로 가독성을 향상시킵니다
              </Typography>
            </div>
            <Switch
              checked={highContrast}
              onCheckedChange={setHighContrast}
            />
          </div>
        </div>
        
        {/* 미리보기 */}
        <div className="space-y-3">
          <Typography variant="h6">미리보기</Typography>
          <Card className="p-4 border-2 border-dashed">
            <div className="space-y-2">
              <Typography variant="h4" color="primary">
                바로캘린더
              </Typography>
              <Typography variant="body1">
                선택한 테마로 표시되는 예시입니다.
              </Typography>
              <div className="flex gap-2">
                <Button size="sm">
                  기본 버튼
                </Button>
                <Button variant="secondary" size="sm">
                  보조 버튼
                </Button>
              </div>
            </div>
          </Card>
        </div>
      </CardContent>
      
      <CardFooter className="flex gap-3">
        <Button variant="outline" onClick={resetToDefaults} className="flex-1">
          기본값 복원
        </Button>
        <Button className="flex-1">
          적용
        </Button>
      </CardFooter>
    </Card>
  )
}
```

---

## 🎨 **사용자 경험 (UX) 설계**

### **1. 다크 모드 전환 애니메이션**

**부드러운 테마 전환 효과**
```css
/* src/styles/theme-transitions.css */
:root {
  color-scheme: light;
  transition: background-color 0.3s ease-in-out, color 0.3s ease-in-out;
}

[data-theme="dark"] {
  color-scheme: dark;
}

/* 테마 전환 시 플래시 방지 */
* {
  transition: 
    background-color 0.3s ease-in-out,
    border-color 0.3s ease-in-out,
    box-shadow 0.3s ease-in-out;
}

/* 모션 줄이기 설정 */
@media (prefers-reduced-motion: reduce) {
  *,
  *::before,
  *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}

/* 고대비 모드 */
.high-contrast {
  --border: #000000;
  --foreground: #000000;
  --background: #ffffff;
  --muted-foreground: #000000;
}

[data-theme="dark"].high-contrast {
  --border: #ffffff;
  --foreground: #ffffff;
  --background: #000000;
  --muted-foreground: #ffffff;
}
```

### **2. 테마 인식 컴포넌트**

**테마 변화에 반응하는 컴포넌트**
```typescript
// src/components/common/ThemeAwareComponent.tsx
export const ThemeAwareIcon = ({ 
  lightIcon: LightIcon, 
  darkIcon: DarkIcon,
  className 
}: {
  lightIcon: React.ComponentType<any>
  darkIcon: React.ComponentType<any>
  className?: string
}) => {
  const [isDark, setIsDark] = useState(false)
  
  useEffect(() => {
    const checkTheme = () => {
      const theme = document.documentElement.getAttribute('data-theme')
      const isSystemDark = window.matchMedia('(prefers-color-scheme: dark)').matches
      setIsDark(theme === 'dark' || (theme === 'system' && isSystemDark))
    }
    
    checkTheme()
    
    // 테마 변경 감지
    const observer = new MutationObserver(checkTheme)
    observer.observe(document.documentElement, { 
      attributes: true, 
      attributeFilter: ['data-theme'] 
    })
    
    // 시스템 테마 변경 감지
    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)')
    mediaQuery.addEventListener('change', checkTheme)
    
    return () => {
      observer.disconnect()
      mediaQuery.removeEventListener('change', checkTheme)
    }
  }, [])
  
  const Icon = isDark ? DarkIcon : LightIcon
  
  return <Icon className={className} />
}

// 사용 예시
export const ThemeToggle = () => {
  const { mode, setMode } = useThemeStore()
  
  const toggleTheme = () => {
    if (mode === 'light') {
      setMode('dark')
    } else if (mode === 'dark') {
      setMode('system')
    } else {
      setMode('light')
    }
  }
  
  return (
    <Button
      variant="ghost"
      size="icon"
      onClick={toggleTheme}
      aria-label="테마 변경"
    >
      <ThemeAwareIcon 
        lightIcon={Sun}
        darkIcon={Moon}
        className="w-5 h-5"
      />
    </Button>
  )
}
```

---

## 📊 **성능 최적화**

### **1. CSS-in-JS 최적화**

**동적 스타일 최적화**
```typescript
// src/lib/theme/cssVariables.ts
export class ThemeOptimizer {
  private static cache = new Map<string, string>()
  
  // CSS 변수 생성 최적화
  static getCSSVariable(name: string, fallback?: string): string {
    const cacheKey = `${name}-${fallback || ''}`
    
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey)!
    }
    
    const variable = fallback 
      ? `var(--${name}, ${fallback})`
      : `var(--${name})`
    
    this.cache.set(cacheKey, variable)
    return variable
  }
  
  // 테마별 CSS 번들 생성
  static generateThemeCSS(theme: 'light' | 'dark'): string {
    const variables = theme === 'dark' 
      ? DARK_THEME_VARIABLES 
      : LIGHT_THEME_VARIABLES
    
    return Object.entries(variables)
      .map(([key, value]) => `--${key}: ${value};`)
      .join('\n')
  }
  
  // Critical CSS 추출
  static extractCriticalCSS(): string {
    return `
      :root { ${this.generateThemeCSS('light')} }
      [data-theme="dark"] { ${this.generateThemeCSS('dark')} }
      
      /* Critical 애니메이션 */
      * {
        transition: background-color 0.3s ease-in-out, color 0.3s ease-in-out;
      }
    `
  }
}

// 테마 로딩 최적화
export const useOptimizedTheme = () => {
  const [isLoading, setIsLoading] = useState(true)
  const { applyTheme } = useThemeStore()
  
  useEffect(() => {
    // 테마 적용 최적화
    const optimizedApply = debounce(() => {
      requestAnimationFrame(() => {
        applyTheme()
        setIsLoading(false)
      })
    }, 100)
    
    optimizedApply()
  }, [applyTheme])
  
  return { isLoading }
}
```

---

## ✅ **Definition of Done**

### **기능 요구사항**
- [ ] 8가지 프로젝트 색상 기반 디자인 토큰 시스템 구현
- [ ] 라이트/다크/시스템 테마 자동 전환 지원
- [ ] 반응형 타이포그래피 시스템 (3가지 폰트 크기)
- [ ] 모바일 퍼스트 반응형 디자인
- [ ] 접근성 지원 (고대비, 애니메이션 줄이기)

### **기술 요구사항**
- [ ] CSS Variables 기반 디자인 토큰 시스템
- [ ] Zustand를 활용한 테마 상태 관리
- [ ] localStorage 기반 테마 설정 영속화
- [ ] 시스템 테마 변경 자동 감지
- [ ] 컴포넌트별 테마 반응형 구현

### **접근성 요구사항**
- [ ] WCAG AA 수준 색상 대비율 준수
- [ ] prefers-reduced-motion 미디어 쿼리 지원
- [ ] 고대비 모드 구현
- [ ] 키보드 네비게이션 완전 지원
- [ ] 스크린 리더 호환성

### **성능 요구사항**
- [ ] 테마 전환 시 60fps 애니메이션 유지
- [ ] CSS-in-JS 스타일 캐싱 최적화
- [ ] 불필요한 리렌더링 방지
- [ ] Critical CSS 인라인 처리
- [ ] 테마 변경 debounce 처리

### **사용성 요구사항**
- [ ] 직관적인 테마 설정 UI
- [ ] 실시간 테마 미리보기
- [ ] 부드러운 테마 전환 애니메이션
- [ ] 모든 디바이스에서 일관된 경험
- [ ] 개인화 설정 내보내기/가져오기

### **테스트 요구사항**
- [ ] 테마 전환 단위 테스트
- [ ] 색상 대비율 자동 검증
- [ ] 반응형 디자인 E2E 테스트
- [ ] 접근성 자동 검증 테스트

---

## 📚 **관련 문서 참조**

- [05. 디자인 시스템 기초](../ui-architecture/05-design-system-foundations.md)
- [06. 컴포넌트 스타일링 패턴](../ui-architecture/06-component-styling-patterns.md)
- [07. 테마 및 반응형 디자인](../ui-architecture/07-theme-responsive-design.md)
- [11. 접근성 구현](../ui-architecture/11-accessibility-implementation.md)

---

**이 스토리는 바로캘린더의 완전한 디자인 시스템 및 테마 구현을 위한 종합적인 기술 가이드입니다. 8가지 프로젝트 색상 기반의 일관된 디자인 토큰 시스템과 사용자 친화적인 테마 커스터마이징을 통해 개인화된 사용자 경험을 제공합니다.**