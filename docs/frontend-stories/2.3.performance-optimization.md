# Story 2.5: ì„±ëŠ¥ ìµœì í™” ì‹œìŠ¤í…œ

## Status
Ready for Development

## Priority & Dependencies
- **Priority**: P1 (High)
- **Story Points**: 5
- **Dependencies**: [1.2, 2.2, 2.4]
- **Blocked By**: None

## Success Metrics
- **Business KPI**: 
  - í˜ì´ì§€ ë¡œë“œ ì‹œê°„ 2ì´ˆ ì´ë‚´
  - ì‚¬ìš©ì ì´íƒˆë¥  10% ê°ì†Œ
  - ëª¨ë°”ì¼ ì‚¬ìš©ì ë§Œì¡±ë„ 4.3/5.0 ì´ìƒ
- **Technical KPI**:
  - Core Web Vitals: LCP <2.5s, FID <100ms, CLS <0.1
  - ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ 100MB ì´í•˜
  - 60fps ìœ ì§€ (1000ê°œ ì´ë²¤íŠ¸)
- **Definition of Success**: ëª¨ë“  Core Web Vitals "Good" ë‹¬ì„±

## Risks & Mitigations
- **Technical Risks**: 
  - Risk: ê³¼ë„í•œ ìµœì í™”ë¡œ ì½”ë“œ ë³µì¡ë„ ì¦ê°€
  - Impact: Medium
  - Mitigation: ì„±ëŠ¥ ë²„ì ¯ ì ìš©, ì ì§„ì  ìµœì í™”
- **Schedule Risks**:
  - Risk: ë¸Œë¼ìš°ì €ë³„ ì„±ëŠ¥ ì°¨ì´
  - Impact: Low
  - Mitigation: í´ë¦¬í•„ ì „ëµ, ì ì§„ì  í–¥ìƒ

---

## ğŸ¯ **ìŠ¤í† ë¦¬ ëª©í‘œ**

**ì™„ì „í•œ ì„±ëŠ¥ ìµœì í™” ì‹œìŠ¤í…œ êµ¬í˜„**
- ëŸ°íƒ€ì„ ì„±ëŠ¥ ìµœì í™” (ë©”ëª¨ì´ì œì´ì…˜, ê°€ìƒí™”)
- ë¹Œë“œ ë° ë²ˆë“¤ ìµœì í™”
- ë„¤íŠ¸ì›Œí¬ ì„±ëŠ¥ ìµœì í™”
- ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ìµœì í™”
- Core Web Vitals ê°œì„ 

---

## Story
**As a** ì‚¬ìš©ì,
**I want** ë¹ ë¥´ê³  ë¶€ë“œëŸ½ê²Œ ì‘ë™í•˜ëŠ” ê³ ì„±ëŠ¥ ìº˜ë¦°ë” ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ì‚¬ìš©í•˜ì—¬,
**so that** ëŒ€ëŸ‰ì˜ ì¼ì •ë„ ëŠê¹€ ì—†ì´ ê´€ë¦¬í•˜ê³  ì–´ë–¤ ë””ë°”ì´ìŠ¤ì—ì„œë„ ì¿¨ì í•œ ì‚¬ìš© ê²½í—˜ì„ ëŠë‚„ ìˆ˜ ìˆë‹¤.

## Acceptance Criteria
1. ì•±ì´ ë¹ ë¥´ê²Œ ë¡œë”©ë˜ê³  ë¶€ë“œëŸ½ê²Œ ì‘ë™í•˜ê¸°ë¥¼ ì›í•œë‹¤
2. ë§ì€ ì´ë²¤íŠ¸ê°€ ìˆì–´ë„ ìŠ¤í¬ë¡¤ì´ ëŠê¸°ì§€ ì•Šê¸°ë¥¼ ì›í•œë‹¤
3. ë„¤íŠ¸ì›Œí¬ê°€ ëŠë ¤ë„ ê¸°ë³¸ ê¸°ëŠ¥ì€ ì‚¬ìš©í•  ìˆ˜ ìˆê¸°ë¥¼ ì›í•œë‹¤
4. ë©”ëª¨ë¦¬ ë¶€ì¡±ìœ¼ë¡œ ì¸í•œ ë¸Œë¼ìš°ì € í¬ë˜ì‹œê°€ ì—†ê¸°ë¥¼ ì›í•œë‹¤
5. ëª¨ë“  ë””ë°”ì´ìŠ¤ì—ì„œ ì¼ê´€ëœ ì„±ëŠ¥ì„ ê²½í—˜í•˜ê³  ì‹¶ë‹¤

---

## ğŸ—ï¸ **ê¸°ìˆ ì  êµ¬í˜„ ìš”êµ¬ì‚¬í•­**

### **1. ëŸ°íƒ€ì„ ì„±ëŠ¥ ìµœì í™”**

**React ë©”ëª¨ì´ì œì´ì…˜ ìµœì í™”**
```typescript
// src/lib/performance/memo-utils.ts
import React, { useMemo, useCallback, useRef } from 'react'
import { isEqual } from 'lodash-es'

// ê¹Šì€ ë©”ëª¨ì´ì œì´ì…˜ì„ ìœ„í•œ ì»¤ìŠ¤í…€ í›…
export const useDeepMemo = <T>(factory: () => T, deps: React.DependencyList) => {
  const ref = useRef<{ deps: React.DependencyList; value: T }>()
  
  if (!ref.current || !isEqual(ref.current.deps, deps)) {
    ref.current = { deps, value: factory() }
  }
  
  return ref.current.value
}

// ì•ˆì •ì ì¸ ì½œë°± ì°¸ì¡°ë¥¼ ìœ„í•œ í›…
export const useStableCallback = <T extends (...args: any[]) => any>(callback: T): T => {
  const callbackRef = useRef(callback)
  callbackRef.current = callback
  
  return useCallback(((...args: Parameters<T>) => {
    return callbackRef.current(...args)
  }) as T, [])
}

// ë¹„ì‹¼ ê³„ì‚°ì„ ìœ„í•œ ë©”ëª¨ì´ì œì´ì…˜
export const useMemoizedEvents = (events: CalendarEvent[], filters: EventFilters) => {
  return useMemo(() => {
    console.time('Event filtering')
    
    let filtered = events
    
    // ë‚ ì§œ í•„í„°ë§
    if (filters.startDate && filters.endDate) {
      filtered = filtered.filter(event => 
        event.startDate >= filters.startDate! && 
        event.endDate <= filters.endDate!
      )
    }
    
    // í”„ë¡œì íŠ¸ í•„í„°ë§
    if (filters.projectIds?.length) {
      filtered = filtered.filter(event => 
        filters.projectIds!.includes(event.projectId)
      )
    }
    
    // ìƒíƒœ í•„í„°ë§
    if (filters.status?.length) {
      filtered = filtered.filter(event => 
        filters.status!.includes(event.status)
      )
    }
    
    // ì •ë ¬
    const sorted = filtered.sort((a, b) => 
      a.startDate.getTime() - b.startDate.getTime()
    )
    
    console.timeEnd('Event filtering')
    return sorted
  }, [events, filters.startDate, filters.endDate, filters.projectIds, filters.status])
}

// ìµœì í™”ëœ ì´ë²¤íŠ¸ ì»´í¬ë„ŒíŠ¸
export const OptimizedEventItem = React.memo<{
  event: CalendarEvent
  onClick?: (event: CalendarEvent) => void
  onUpdate?: (id: string, updates: Partial<CalendarEvent>) => void
}>(({ event, onClick, onUpdate }) => {
  const handleClick = useStableCallback(() => onClick?.(event))
  const handleUpdate = useStableCallback((updates: Partial<CalendarEvent>) => 
    onUpdate?.(event.id, updates)
  )
  
  return (
    <div 
      className="event-item"
      onClick={handleClick}
      style={{ borderColor: event.projectColor }}
    >
      <h3>{event.title}</h3>
      <p>{format(event.startDate, 'MMM d, h:mm a')}</p>
    </div>
  )
}, (prevProps, nextProps) => {
  // ì»¤ìŠ¤í…€ ë¹„êµ í•¨ìˆ˜
  return (
    prevProps.event.id === nextProps.event.id &&
    prevProps.event.title === nextProps.event.title &&
    prevProps.event.startDate.getTime() === nextProps.event.startDate.getTime() &&
    prevProps.event.updatedAt?.getTime() === nextProps.event.updatedAt?.getTime()
  )
})
```

**ê°€ìƒí™” êµ¬í˜„**
```typescript
// src/components/performance/VirtualizedCalendar.tsx
import React, { useMemo, useCallback, useRef, useEffect, useState } from 'react'
import { VariableSizeList as List, areEqual } from 'react-window'
import { CalendarEvent } from '@/types/calendar'

interface VirtualizedCalendarProps {
  events: CalendarEvent[]
  containerHeight: number
  onEventClick?: (event: CalendarEvent) => void
}

const ITEM_HEIGHT = 80
const OVERSCAN_COUNT = 5

export const VirtualizedCalendar: React.FC<VirtualizedCalendarProps> = ({
  events,
  containerHeight,
  onEventClick
}) => {
  const listRef = useRef<List>(null)
  const [scrollOffset, setScrollOffset] = useState(0)
  
  // ì´ë²¤íŠ¸ ê·¸ë£¹í™” (ë‚ ì§œë³„)
  const groupedEvents = useMemo(() => {
    const groups = new Map<string, CalendarEvent[]>()
    
    events.forEach(event => {
      const dateKey = format(event.startDate, 'yyyy-MM-dd')
      if (!groups.has(dateKey)) {
        groups.set(dateKey, [])
      }
      groups.get(dateKey)!.push(event)
    })
    
    return Array.from(groups.entries()).map(([date, events]) => ({
      date,
      events,
      type: 'group' as const
    }))
  }, [events])
  
  // ê°€ë³€ ë†’ì´ ê³„ì‚°
  const getItemSize = useCallback((index: number) => {
    const group = groupedEvents[index]
    return 40 + (group.events.length * ITEM_HEIGHT) // í—¤ë” + ì´ë²¤íŠ¸ë“¤
  }, [groupedEvents])
  
  // ìŠ¤í¬ë¡¤ ìµœì í™”ë¥¼ ìœ„í•œ debounce
  const debouncedScrollHandler = useCallback(
    debounce((scrollTop: number) => {
      setScrollOffset(scrollTop)
    }, 16), // ~60fps
    []
  )
  
  const handleScroll = ({ scrollTop }: { scrollTop: number }) => {
    debouncedScrollHandler(scrollTop)
  }
  
  return (
    <List
      ref={listRef}
      height={containerHeight}
      itemCount={groupedEvents.length}
      itemSize={getItemSize}
      overscanCount={OVERSCAN_COUNT}
      onScroll={handleScroll}
    >
      {({ index, style }) => (
        <VirtualizedEventGroup
          index={index}
          style={style}
          group={groupedEvents[index]}
          onEventClick={onEventClick}
        />
      )}
    </List>
  )
}

// ê°€ìƒí™”ëœ ì´ë²¤íŠ¸ ê·¸ë£¹ ì»´í¬ë„ŒíŠ¸
const VirtualizedEventGroup = React.memo<{
  index: number
  style: React.CSSProperties
  group: { date: string; events: CalendarEvent[] }
  onEventClick?: (event: CalendarEvent) => void
}>(({ index, style, group, onEventClick }) => {
  return (
    <div style={style} className="virtual-event-group">
      {/* ë‚ ì§œ í—¤ë” */}
      <div className="event-group-header">
        <h3>{format(new Date(group.date), 'EEEE, MMMM d')}</h3>
      </div>
      
      {/* ì´ë²¤íŠ¸ ëª©ë¡ */}
      <div className="event-list">
        {group.events.map(event => (
          <OptimizedEventItem
            key={event.id}
            event={event}
            onClick={onEventClick}
          />
        ))}
      </div>
    </div>
  )
}, areEqual)
```

### **2. ë¹Œë“œ ë° ë²ˆë“¤ ìµœì í™”**

**Next.js ì„¤ì • ìµœì í™”**
```javascript
// next.config.js
const withBundleAnalyzer = require('@next/bundle-analyzer')({
  enabled: process.env.ANALYZE === 'true',
})

/** @type {import('next').NextConfig} */
const nextConfig = {
  // ì‹¤í—˜ì  ê¸°ëŠ¥
  experimental: {
    optimizeCss: true,
    modularizeImports: {
      'lucide-react': {
        transform: 'lucide-react/dist/esm/icons/{{member}}',
        skipDefaultConversion: true,
      },
      'date-fns': {
        transform: 'date-fns/{{member}}',
      },
    },
  },
  
  // ì»´íŒŒì¼ëŸ¬ ìµœì í™”
  compiler: {
    removeConsole: process.env.NODE_ENV === 'production',
    styledComponents: true,
  },
  
  // ì´ë¯¸ì§€ ìµœì í™”
  images: {
    domains: ['example.com'],
    formats: ['image/webp', 'image/avif'],
    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
  },
  
  // Webpack ì„¤ì •
  webpack: (config, { dev, isServer }) => {
    // í”„ë¡œë•ì…˜ì—ì„œ ì†ŒìŠ¤ë§µ ìµœì í™”
    if (!dev && !isServer) {
      config.devtool = 'source-map'
    }
    
    // ë²ˆë“¤ ë¶„í•  ìµœì í™”
    config.optimization = {
      ...config.optimization,
      splitChunks: {
        chunks: 'all',
        cacheGroups: {
          vendor: {
            test: /[\\/]node_modules[\\/]/,
            name: 'vendors',
            chunks: 'all',
          },
          common: {
            name: 'common',
            minChunks: 2,
            priority: -10,
            reuseExistingChunk: true,
          },
        },
      },
    }
    
    // Tree shaking ìµœì í™”
    config.optimization.usedExports = true
    config.optimization.sideEffects = false
    
    // Gzip ì••ì¶•
    if (!dev) {
      const CompressionPlugin = require('compression-webpack-plugin')
      config.plugins.push(
        new CompressionPlugin({
          algorithm: 'gzip',
          test: /\.(js|css|html|svg)$/,
          threshold: 8192,
          minRatio: 0.8,
        })
      )
    }
    
    return config
  },
  
  // í—¤ë” ì„¤ì •
  async headers() {
    return [
      {
        source: '/(.*)',
        headers: [
          {
            key: 'X-Content-Type-Options',
            value: 'nosniff',
          },
          {
            key: 'X-Frame-Options',
            value: 'DENY',
          },
          {
            key: 'X-XSS-Protection',
            value: '1; mode=block',
          },
        ],
      },
      // ì •ì  ìì‚° ìºì‹±
      {
        source: '/static/(.*)',
        headers: [
          {
            key: 'Cache-Control',
            value: 'public, max-age=31536000, immutable',
          },
        ],
      },
    ]
  },
}

module.exports = withBundleAnalyzer(nextConfig)
```

**ì½”ë“œ ìŠ¤í”Œë¦¬íŒ… ìµœì í™”**
```typescript
// src/lib/performance/code-splitting.ts
import { lazy, Suspense } from 'react'
import { ErrorBoundary } from 'react-error-boundary'

// ì§€ì—° ë¡œë”©ëœ ì»´í¬ë„ŒíŠ¸ë“¤
export const LazyEventModal = lazy(() => 
  import('../components/event/EventModal').then(module => ({
    default: module.EventModal
  }))
)

export const LazyCalendarSettings = lazy(() => 
  import('../components/settings/CalendarSettings')
)

export const LazyReportDashboard = lazy(() => 
  import('../components/reports/ReportDashboard')
)

// HOC for lazy loading with error boundary
export function withLazyLoading<P extends object>(
  Component: React.LazyExoticComponent<React.ComponentType<P>>,
  fallback?: React.ReactNode
) {
  return function LazyComponent(props: P) {
    return (
      <ErrorBoundary
        fallback={<div>ì»´í¬ë„ŒíŠ¸ ë¡œë”© ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.</div>}
        onError={(error) => console.error('Lazy loading error:', error)}
      >
        <Suspense fallback={fallback || <LoadingSpinner />}>
          <Component {...props} />
        </Suspense>
      </ErrorBoundary>
    )
  }
}

// ë™ì  import helper
export const dynamicImport = {
  eventModal: () => import('../components/event/EventModal'),
  reportDashboard: () => import('../components/reports/ReportDashboard'),
  settingsPanel: () => import('../components/settings/SettingsPanel'),
}

// Preload critical components
export const preloadComponents = () => {
  if (typeof window !== 'undefined') {
    // Critical components ë¯¸ë¦¬ ë¡œë“œ
    setTimeout(() => {
      dynamicImport.eventModal()
    }, 2000)
  }
}
```

### **3. ë„¤íŠ¸ì›Œí¬ ì„±ëŠ¥ ìµœì í™”**

**HTTP ìºì‹± ì „ëµ**
```typescript
// src/lib/performance/cache-manager.ts
interface CacheConfig {
  maxAge: number
  staleWhileRevalidate?: number
  maxEntries?: number
}

export class CacheManager {
  private cache = new Map<string, { data: any; timestamp: number; maxAge: number }>()
  private maxEntries: number
  
  constructor(maxEntries = 100) {
    this.maxEntries = maxEntries
  }
  
  set(key: string, data: any, config: CacheConfig) {
    // LRU ìºì‹œ êµ¬í˜„
    if (this.cache.size >= this.maxEntries) {
      const firstKey = this.cache.keys().next().value
      this.cache.delete(firstKey)
    }
    
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      maxAge: config.maxAge
    })
  }
  
  get(key: string): any | null {
    const cached = this.cache.get(key)
    
    if (!cached) return null
    
    const isExpired = Date.now() - cached.timestamp > cached.maxAge
    
    if (isExpired) {
      this.cache.delete(key)
      return null
    }
    
    // Move to end (LRU)
    this.cache.delete(key)
    this.cache.set(key, cached)
    
    return cached.data
  }
  
  invalidate(key: string) {
    this.cache.delete(key)
  }
  
  clear() {
    this.cache.clear()
  }
}

// API ìš”ì²­ ìµœì í™”
export const optimizedFetch = async <T>(
  url: string,
  options: RequestInit & { cache?: CacheConfig } = {}
): Promise<T> => {
  const cacheKey = `${url}-${JSON.stringify(options)}`
  const cacheManager = new CacheManager()
  
  // ìºì‹œ í™•ì¸
  if (options.cache) {
    const cached = cacheManager.get(cacheKey)
    if (cached) return cached
  }
  
  try {
    const controller = new AbortController()
    const timeoutId = setTimeout(() => controller.abort(), 10000) // 10ì´ˆ íƒ€ì„ì•„ì›ƒ
    
    const response = await fetch(url, {
      ...options,
      signal: controller.signal,
    })
    
    clearTimeout(timeoutId)
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`)
    }
    
    const data = await response.json()
    
    // ìºì‹œ ì €ì¥
    if (options.cache) {
      cacheManager.set(cacheKey, data, options.cache)
    }
    
    return data
  } catch (error) {
    if (error instanceof Error && error.name === 'AbortError') {
      throw new Error('Request timeout')
    }
    throw error
  }
}
```

**ë°ì´í„° íŒ¨ì¹­ ìµœì í™”**
```typescript
// src/hooks/useOptimizedQuery.ts
import { useQuery, useQueryClient } from '@tanstack/react-query'
import { useIntersectionObserver } from './useIntersectionObserver'

export const useOptimizedEvents = (filters: EventFilters) => {
  const queryClient = useQueryClient()
  
  return useQuery({
    queryKey: ['events', filters],
    queryFn: async () => {
      // ë°±ê·¸ë¼ìš´ë“œì—ì„œ ë‹¤ìŒ í˜ì´ì§€ ë¯¸ë¦¬ ë¡œë“œ
      setTimeout(() => {
        const nextFilters = { ...filters, page: (filters.page || 1) + 1 }
        queryClient.prefetchQuery({
          queryKey: ['events', nextFilters],
          queryFn: () => fetchEvents(nextFilters)
        })
      }, 1000)
      
      return fetchEvents(filters)
    },
    staleTime: 5 * 60 * 1000, // 5ë¶„ê°„ fresh
    cacheTime: 30 * 60 * 1000, // 30ë¶„ê°„ ìºì‹œ
    refetchOnWindowFocus: false,
    retry: 3,
  })
}

// Intersection Observerë¥¼ í™œìš©í•œ ë¬´í•œ ìŠ¤í¬ë¡¤
export const useInfiniteEvents = () => {
  const [hasMore, setHasMore] = useState(true)
  const [isIntersecting, targetRef] = useIntersectionObserver({
    threshold: 0.1,
    rootMargin: '100px'
  })
  
  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage
  } = useInfiniteQuery({
    queryKey: ['events-infinite'],
    queryFn: ({ pageParam = 0 }) => fetchEvents({ page: pageParam }),
    getNextPageParam: (lastPage) => lastPage.nextPage,
  })
  
  useEffect(() => {
    if (isIntersecting && hasNextPage && !isFetchingNextPage) {
      fetchNextPage()
    }
  }, [isIntersecting, hasNextPage, isFetchingNextPage, fetchNextPage])
  
  return {
    events: data?.pages.flatMap(page => page.events) || [],
    targetRef,
    hasMore,
    isLoading: isFetchingNextPage
  }
}
```

### **4. ë©”ëª¨ë¦¬ ê´€ë¦¬ ìµœì í™”**

**ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€**
```typescript
// src/lib/performance/memory-manager.ts
export class MemoryManager {
  private static timers = new Set<NodeJS.Timeout>()
  private static listeners = new Set<{ element: EventTarget; event: string; listener: EventListener }>()
  private static observers = new Set<IntersectionObserver | ResizeObserver | MutationObserver>()
  
  // íƒ€ì´ë¨¸ ê´€ë¦¬
  static setTimeout(callback: () => void, ms: number): NodeJS.Timeout {
    const timer = setTimeout(() => {
      callback()
      this.timers.delete(timer)
    }, ms)
    
    this.timers.add(timer)
    return timer
  }
  
  static setInterval(callback: () => void, ms: number): NodeJS.Timeout {
    const timer = setInterval(callback, ms)
    this.timers.add(timer)
    return timer
  }
  
  static clearTimer(timer: NodeJS.Timeout) {
    clearTimeout(timer)
    clearInterval(timer)
    this.timers.delete(timer)
  }
  
  // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ê´€ë¦¬
  static addEventListener(
    element: EventTarget,
    event: string,
    listener: EventListener,
    options?: boolean | AddEventListenerOptions
  ) {
    element.addEventListener(event, listener, options)
    this.listeners.add({ element, event, listener })
  }
  
  static removeEventListener(
    element: EventTarget,
    event: string,
    listener: EventListener
  ) {
    element.removeEventListener(event, listener)
    this.listeners.delete(
      Array.from(this.listeners).find(l => 
        l.element === element && l.event === event && l.listener === listener
      )!
    )
  }
  
  // Observer ê´€ë¦¬
  static addObserver(observer: IntersectionObserver | ResizeObserver | MutationObserver) {
    this.observers.add(observer)
  }
  
  static removeObserver(observer: IntersectionObserver | ResizeObserver | MutationObserver) {
    observer.disconnect()
    this.observers.delete(observer)
  }
  
  // ëª¨ë“  ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  static cleanup() {
    // íƒ€ì´ë¨¸ ì •ë¦¬
    this.timers.forEach(timer => this.clearTimer(timer))
    this.timers.clear()
    
    // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì •ë¦¬
    this.listeners.forEach(({ element, event, listener }) => {
      element.removeEventListener(event, listener)
    })
    this.listeners.clear()
    
    // Observer ì •ë¦¬
    this.observers.forEach(observer => observer.disconnect())
    this.observers.clear()
  }
}

// ìë™ ì •ë¦¬ Hook
export const useAutoCleanup = () => {
  useEffect(() => {
    return () => {
      MemoryManager.cleanup()
    }
  }, [])
}
```

### **5. ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§**

**Core Web Vitals ëª¨ë‹ˆí„°ë§**
```typescript
// src/lib/performance/vitals.ts
export const measureWebVitals = () => {
  if (typeof window === 'undefined') return
  
  // LCP (Largest Contentful Paint)
  new PerformanceObserver((entryList) => {
    const entries = entryList.getEntries()
    const lastEntry = entries[entries.length - 1] as PerformanceEventTiming
    
    console.log('LCP:', lastEntry.startTime)
    
    // ë¶„ì„ ë„êµ¬ë¡œ ì „ì†¡
    sendAnalytics('lcp', lastEntry.startTime)
  }).observe({ type: 'largest-contentful-paint', buffered: true })
  
  // FID (First Input Delay)
  new PerformanceObserver((entryList) => {
    const entries = entryList.getEntries()
    entries.forEach((entry) => {
      console.log('FID:', entry.processingStart - entry.startTime)
      sendAnalytics('fid', entry.processingStart - entry.startTime)
    })
  }).observe({ type: 'first-input', buffered: true })
  
  // CLS (Cumulative Layout Shift)
  let clsValue = 0
  new PerformanceObserver((entryList) => {
    const entries = entryList.getEntries()
    entries.forEach((entry) => {
      if (!(entry as any).hadRecentInput) {
        clsValue += (entry as any).value
      }
    })
    
    console.log('CLS:', clsValue)
    sendAnalytics('cls', clsValue)
  }).observe({ type: 'layout-shift', buffered: true })
  
  // Runtime Performance
  const measureRenderTime = () => {
    const start = performance.now()
    
    requestAnimationFrame(() => {
      const end = performance.now()
      const renderTime = end - start
      
      if (renderTime > 16) { // 60fpsë¥¼ ëª» ë§ì·„ì„ ë•Œ
        console.warn('Slow render:', renderTime)
        sendAnalytics('slow-render', renderTime)
      }
    })
  }
  
  // ì£¼ê¸°ì ìœ¼ë¡œ ë Œë”ë§ ì‹œê°„ ì¸¡ì •
  setInterval(measureRenderTime, 5000)
}

const sendAnalytics = (metric: string, value: number) => {
  if (process.env.NODE_ENV === 'production') {
    fetch('/api/analytics', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ metric, value, url: window.location.pathname })
    })
  }
}
```

---

## ğŸ“Š **ì„±ëŠ¥ ëª©í‘œ**

### **Core Web Vitals ëª©í‘œ**
- LCP (Largest Contentful Paint): < 2.5ì´ˆ
- FID (First Input Delay): < 100ms  
- CLS (Cumulative Layout Shift): < 0.1

### **ê¸°íƒ€ ì„±ëŠ¥ ì§€í‘œ**
- Time to Interactive (TTI): < 3.8ì´ˆ
- First Contentful Paint (FCP): < 1.8ì´ˆ
- Bundle Size: < 500KB (gzipped)
- Memory Usage: < 50MB

---

## âœ… **Definition of Done**

### **ê¸°ëŠ¥ ìš”êµ¬ì‚¬í•­**
- [ ] ë©”ëª¨ì´ì œì´ì…˜ ë° ê°€ìƒí™” êµ¬í˜„
- [ ] ì½”ë“œ ìŠ¤í”Œë¦¬íŒ… ë° ì§€ì—° ë¡œë”©
- [ ] ìºì‹± ì „ëµ êµ¬í˜„
- [ ] ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€
- [ ] ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ

### **ê¸°ìˆ  ìš”êµ¬ì‚¬í•­**
- [ ] React ìµœì í™” íŒ¨í„´ ì ìš©
- [ ] Webpack/Next.js ë¹Œë“œ ìµœì í™”
- [ ] HTTP ìºì‹± êµ¬í˜„
- [ ] ë²ˆë“¤ í¬ê¸° ìµœì í™”

### **ì„±ëŠ¥ ìš”êµ¬ì‚¬í•­**
- [ ] Lighthouse ì„±ëŠ¥ ì ìˆ˜ 90+
- [ ] Core Web Vitals ê¸°ì¤€ ì¶©ì¡±
- [ ] 60fps ìŠ¤í¬ë¡¤ ì„±ëŠ¥ ìœ ì§€
- [ ] ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ìµœì í™”

### **í…ŒìŠ¤íŠ¸ ìš”êµ¬ì‚¬í•­**
- [ ] ì„±ëŠ¥ íšŒê·€ í…ŒìŠ¤íŠ¸
- [ ] ë²ˆë“¤ í¬ê¸° ëª¨ë‹ˆí„°ë§
- [ ] ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ í…ŒìŠ¤íŠ¸
- [ ] ë‹¤ì–‘í•œ ë””ë°”ì´ìŠ¤ ì„±ëŠ¥ í…ŒìŠ¤íŠ¸

---

## ğŸ“š **ê´€ë ¨ ë¬¸ì„œ ì°¸ì¡°**

- [08. Runtime Performance](../ui-architecture/08-runtime-performance.md)
- [09. Build & Bundle Optimization](../ui-architecture/09-build-bundle-optimization.md)
- [21. Observability & Monitoring](../ui-architecture/21-observability-monitoring.md)

---

**ì´ ìŠ¤í† ë¦¬ëŠ” ë°”ë¡œìº˜ë¦°ë”ì˜ ì„±ëŠ¥ ìµœì í™” êµ¬í˜„ì„ ìœ„í•œ ì¢…í•©ì ì¸ ê¸°ìˆ  ê°€ì´ë“œì…ë‹ˆë‹¤. ì‚¬ìš©ìì—ê²Œ ë¹ ë¥´ê³  ë¶€ë“œëŸ¬ìš´ ê²½í—˜ì„ ì œê³µí•˜ê¸° ìœ„í•œ ëª¨ë“  ìµœì í™” ê¸°ë²•ì„ í¬í•¨í•©ë‹ˆë‹¤.**