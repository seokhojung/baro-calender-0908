# Story 1.9: 인증 및 보안 시스템

## Status
Ready for Development

## Priority & Dependencies
- **Priority**: P0 (Critical)
- **Story Points**: 8
- **Dependencies**: [1.1a]
- **Blocked By**: None

## Success Metrics
- **Business KPI**: 
  - 로그인 성공률 99% 이상
  - 로그인 시간 2초 이내
  - 2FA 채택률 30% 이상
- **Technical KPI**:
  - 토큰 검증 시간 10ms 이내
  - 자동 토큰 갱신 성공률 100%
  - 보안 취약점 0개
- **Definition of Success**: 안전한 인증 시스템, OWASP Top 10 대응

---

## 🎯 **스토리 목표**

**완전한 인증 및 보안 시스템**
- JWT 기반 액세스/리프레시 토큰 관리
- 다중 인증 방식 지원 (이메일, 소셜 로그인, 2FA)
- 역할 기반 권한 관리 (RBAC) 시스템
- XSS/CSRF 방지 및 보안 헤더 적용
- 민감 정보 보호 및 감사 로깅

---

## Story
**As a** 사용자,
**I want** 안전한 인증 시스템을 통해 로그인하고 권한에 따라 기능에 접근할 수 있는 시스템을 사용하여,
**so that** 내 데이터를 안전하게 보호하고 부여받은 권한 내에서 작업할 수 있다.

## Acceptance Criteria
1. 이메일/비밀번호 또는 소셜 로그인으로 안전하게 로그인하고 싶다
2. 2단계 인증으로 계정 보안을 강화하고 싶다
3. 토큰이 만료되어도 자동으로 갱신되어 끊김없이 사용하고 싶다
4. 권한에 따라 다른 기능에 접근하고 싶다
5. 내 개인정보와 일정이 안전하게 보호되길 바란다

---

## 🏗️ **기술적 구현 요구사항**

### **1. JWT 토큰 기반 인증 시스템**

**토큰 관리 및 자동 갱신**
```typescript
// src/lib/auth/tokenManager.ts
export interface AuthTokens {
  accessToken: string
  refreshToken: string
  expiresAt: number
  tokenType: 'Bearer'
  user: User
}

export interface User {
  id: string
  email: string
  name: string
  avatar?: string
  role: UserRole
  permissions: Permission[]
  preferences: UserPreferences
  lastLoginAt: string
  createdAt: string
}

export type UserRole = 'admin' | 'manager' | 'member' | 'viewer'

export type Permission = 
  | 'schedule:create' | 'schedule:read' | 'schedule:update' | 'schedule:delete'
  | 'project:create' | 'project:read' | 'project:update' | 'project:delete'
  | 'user:manage' | 'settings:manage'

export class TokenManager {
  private static readonly ACCESS_TOKEN_KEY = 'baro_access_token'
  private static readonly REFRESH_TOKEN_KEY = 'baro_refresh_token'
  private static readonly TOKEN_EXPIRY_KEY = 'baro_token_expiry'
  private static refreshPromise: Promise<AuthTokens> | null = null
  
  // 토큰 저장 (httpOnly 쿠키 + localStorage 하이브리드)
  static setTokens(tokens: AuthTokens): void {
    // 액세스 토큰은 메모리에만 (보안)
    sessionStorage.setItem(this.ACCESS_TOKEN_KEY, tokens.accessToken)
    
    // 리프레시 토큰은 httpOnly 쿠키로 서버에서 관리
    // 클라이언트에서는 만료 시간만 저장
    localStorage.setItem(this.TOKEN_EXPIRY_KEY, tokens.expiresAt.toString())
    
    // 사용자 정보는 localStorage
    localStorage.setItem('baro_user', JSON.stringify(tokens.user))
  }
  
  // 액세스 토큰 조회
  static getAccessToken(): string | null {
    return sessionStorage.getItem(this.ACCESS_TOKEN_KEY)
  }
  
  // 토큰 유효성 검사
  static isTokenValid(): boolean {
    const accessToken = this.getAccessToken()
    const expiryStr = localStorage.getItem(this.TOKEN_EXPIRY_KEY)
    
    if (!accessToken || !expiryStr) return false
    
    const expiry = parseInt(expiryStr)
    const now = Date.now()
    
    // 5분 여유를 두고 갱신
    return (expiry - now) > 5 * 60 * 1000
  }
  
  // 자동 토큰 갱신
  static async refreshToken(): Promise<AuthTokens> {
    // 중복 갱신 방지
    if (this.refreshPromise) {
      return this.refreshPromise
    }
    
    this.refreshPromise = this.performTokenRefresh()
    
    try {
      const tokens = await this.refreshPromise
      this.refreshPromise = null
      return tokens
    } catch (error) {
      this.refreshPromise = null
      throw error
    }
  }
  
  private static async performTokenRefresh(): Promise<AuthTokens> {
    try {
      const response = await fetch('/api/auth/refresh', {
        method: 'POST',
        credentials: 'include', // httpOnly 쿠키 포함
        headers: {
          'Content-Type': 'application/json',
        }
      })
      
      if (!response.ok) {
        throw new Error('Token refresh failed')
      }
      
      const tokens: AuthTokens = await response.json()
      this.setTokens(tokens)
      
      // 갱신 성공 이벤트 발생
      window.dispatchEvent(new CustomEvent('auth:token-refreshed', {
        detail: tokens
      }))
      
      return tokens
    } catch (error) {
      // 갱신 실패 시 로그아웃
      this.clearTokens()
      window.dispatchEvent(new CustomEvent('auth:refresh-failed'))
      throw error
    }
  }
  
  // 토큰 삭제
  static clearTokens(): void {
    sessionStorage.removeItem(this.ACCESS_TOKEN_KEY)
    localStorage.removeItem(this.TOKEN_EXPIRY_KEY)
    localStorage.removeItem('baro_user')
  }
  
  // 자동 갱신 스케줄러
  static startAutoRefresh(): void {
    const checkInterval = setInterval(() => {
      const expiryStr = localStorage.getItem(this.TOKEN_EXPIRY_KEY)
      if (!expiryStr) return
      
      const expiry = parseInt(expiryStr)
      const now = Date.now()
      const timeUntilExpiry = expiry - now
      
      // 10분 전에 갱신 시도
      if (timeUntilExpiry <= 10 * 60 * 1000 && timeUntilExpiry > 0) {
        this.refreshToken().catch(console.error)
      } else if (timeUntilExpiry <= 0) {
        // 토큰이 이미 만료된 경우
        clearInterval(checkInterval)
        this.clearTokens()
        window.location.href = '/login'
      }
    }, 60 * 1000) // 1분마다 체크
  }
}
```

### **2. 인증 상태 관리**

**Zustand 기반 인증 Store**
```typescript
// src/stores/authStore.ts
interface AuthState {
  // 인증 상태
  isAuthenticated: boolean
  user: User | null
  isLoading: boolean
  error: AuthError | null
  
  // 로그인 상태
  loginMethod: 'email' | 'google' | 'github' | null
  requiresTwoFactor: boolean
  twoFactorToken: string | null
  
  // 권한
  permissions: Set<Permission>
  
  // Actions
  login: (credentials: LoginCredentials) => Promise<void>
  loginWithProvider: (provider: 'google' | 'github') => Promise<void>
  verifyTwoFactor: (token: string, code: string) => Promise<void>
  logout: () => Promise<void>
  checkAuthStatus: () => Promise<void>
  updateUser: (updates: Partial<User>) => void
  
  // 권한 체크
  hasPermission: (permission: Permission) => boolean
  hasAnyPermission: (permissions: Permission[]) => boolean
  hasRole: (role: UserRole) => boolean
}

export const useAuthStore = create<AuthState>()(
  devtools(
    subscribeWithSelector(
      immer((set, get) => ({
        isAuthenticated: false,
        user: null,
        isLoading: false,
        error: null,
        loginMethod: null,
        requiresTwoFactor: false,
        twoFactorToken: null,
        permissions: new Set(),
        
        login: async (credentials) => {
          set(state => {
            state.isLoading = true
            state.error = null
          })
          
          try {
            const response = await fetch('/api/auth/login', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              credentials: 'include',
              body: JSON.stringify(credentials)
            })
            
            const data = await response.json()
            
            if (!response.ok) {
              throw new Error(data.message || 'Login failed')
            }
            
            // 2FA 필요한 경우
            if (data.requiresTwoFactor) {
              set(state => {
                state.requiresTwoFactor = true
                state.twoFactorToken = data.twoFactorToken
                state.isLoading = false
              })
              return
            }
            
            // 로그인 성공
            const tokens: AuthTokens = data
            TokenManager.setTokens(tokens)
            
            set(state => {
              state.isAuthenticated = true
              state.user = tokens.user
              state.permissions = new Set(tokens.user.permissions)
              state.loginMethod = 'email'
              state.isLoading = false
              state.requiresTwoFactor = false
              state.twoFactorToken = null
            })
            
            // 토큰 자동 갱신 시작
            TokenManager.startAutoRefresh()
            
          } catch (error) {
            set(state => {
              state.error = error as AuthError
              state.isLoading = false
            })
          }
        },
        
        loginWithProvider: async (provider) => {
          set(state => {
            state.isLoading = true
            state.error = null
          })
          
          try {
            // OAuth 리다이렉트
            const authUrl = `/api/auth/${provider}`
            window.location.href = authUrl
          } catch (error) {
            set(state => {
              state.error = error as AuthError
              state.isLoading = false
            })
          }
        },
        
        verifyTwoFactor: async (token, code) => {
          set(state => { state.isLoading = true })
          
          try {
            const response = await fetch('/api/auth/2fa/verify', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              credentials: 'include',
              body: JSON.stringify({ token, code })
            })
            
            const tokens: AuthTokens = await response.json()
            
            if (!response.ok) {
              throw new Error('Invalid 2FA code')
            }
            
            TokenManager.setTokens(tokens)
            
            set(state => {
              state.isAuthenticated = true
              state.user = tokens.user
              state.permissions = new Set(tokens.user.permissions)
              state.requiresTwoFactor = false
              state.twoFactorToken = null
              state.isLoading = false
            })
            
            TokenManager.startAutoRefresh()
            
          } catch (error) {
            set(state => {
              state.error = error as AuthError
              state.isLoading = false
            })
          }
        },
        
        logout: async () => {
          try {
            await fetch('/api/auth/logout', {
              method: 'POST',
              credentials: 'include'
            })
          } catch (error) {
            console.error('Logout error:', error)
          }
          
          TokenManager.clearTokens()
          
          set(state => {
            state.isAuthenticated = false
            state.user = null
            state.permissions = new Set()
            state.loginMethod = null
            state.error = null
          })
        },
        
        checkAuthStatus: async () => {
          // 저장된 사용자 정보 확인
          const userStr = localStorage.getItem('baro_user')
          if (userStr && TokenManager.isTokenValid()) {
            try {
              const user = JSON.parse(userStr)
              set(state => {
                state.isAuthenticated = true
                state.user = user
                state.permissions = new Set(user.permissions)
              })
              
              TokenManager.startAutoRefresh()
            } catch (error) {
              TokenManager.clearTokens()
            }
          }
        },
        
        hasPermission: (permission) => {
          return get().permissions.has(permission)
        },
        
        hasAnyPermission: (permissions) => {
          const userPermissions = get().permissions
          return permissions.some(permission => userPermissions.has(permission))
        },
        
        hasRole: (role) => {
          return get().user?.role === role
        }
      }))
    ),
    { name: 'Auth Store' }
  )
)
```

### **3. 로그인 UI 컴포넌트**

**다중 인증 방식 지원 로그인 폼**
```typescript
// src/components/auth/LoginForm.tsx
const LoginForm = () => {
  const { login, loginWithProvider, verifyTwoFactor, isLoading, error, requiresTwoFactor, twoFactorToken } = useAuthStore()
  const [loginMethod, setLoginMethod] = useState<'email' | 'social'>('email')
  const [showPassword, setShowPassword] = useState(false)
  
  const emailForm = useForm<LoginCredentials>({
    resolver: zodResolver(loginSchema),
    defaultValues: {
      email: '',
      password: '',
      rememberMe: false
    }
  })
  
  const twoFactorForm = useForm<{ code: string }>({
    resolver: zodResolver(z.object({
      code: z.string().min(6, '6자리 코드를 입력해주세요').max(6)
    }))
  })
  
  const handleEmailLogin = async (data: LoginCredentials) => {
    await login(data)
  }
  
  const handleTwoFactorVerify = async (data: { code: string }) => {
    if (!twoFactorToken) return
    await verifyTwoFactor(twoFactorToken, data.code)
  }
  
  // 2FA 필요한 경우
  if (requiresTwoFactor) {
    return (
      <Card className="w-full max-w-md mx-auto">
        <CardHeader className="text-center">
          <div className="flex justify-center mb-4">
            <Shield className="w-12 h-12 text-primary" />
          </div>
          <CardTitle>2단계 인증</CardTitle>
          <CardDescription>
            인증 앱에 표시된 6자리 코드를 입력해주세요
          </CardDescription>
        </CardHeader>
        
        <CardContent>
          <Form {...twoFactorForm}>
            <form onSubmit={twoFactorForm.handleSubmit(handleTwoFactorVerify)} className="space-y-4">
              <FormField
                control={twoFactorForm.control}
                name="code"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <InputOTP
                        maxLength={6}
                        value={field.value}
                        onChange={field.onChange}
                        className="justify-center"
                      >
                        {Array.from({ length: 6 }).map((_, index) => (
                          <InputOTPSlot key={index} index={index} />
                        ))}
                      </InputOTP>
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              
              {error && (
                <Alert variant="destructive">
                  <AlertCircle className="h-4 w-4" />
                  <AlertDescription>{error.message}</AlertDescription>
                </Alert>
              )}
              
              <Button type="submit" className="w-full" disabled={isLoading}>
                {isLoading ? (
                  <>
                    <Loader2 className="w-4 h-4 animate-spin mr-2" />
                    인증 중...
                  </>
                ) : (
                  '인증 확인'
                )}
              </Button>
            </form>
          </Form>
        </CardContent>
      </Card>
    )
  }
  
  return (
    <Card className="w-full max-w-md mx-auto">
      <CardHeader className="text-center">
        <div className="flex justify-center mb-4">
          <Calendar className="w-12 h-12 text-primary" />
        </div>
        <CardTitle>바로캘린더에 로그인</CardTitle>
        <CardDescription>
          계정에 로그인하여 일정을 관리하세요
        </CardDescription>
      </CardHeader>
      
      <CardContent className="space-y-6">
        {/* 로그인 방식 선택 */}
        <Tabs value={loginMethod} onValueChange={setLoginMethod}>
          <TabsList className="grid w-full grid-cols-2">
            <TabsTrigger value="email">이메일</TabsTrigger>
            <TabsTrigger value="social">소셜 로그인</TabsTrigger>
          </TabsList>
          
          <TabsContent value="email" className="space-y-4">
            <Form {...emailForm}>
              <form onSubmit={emailForm.handleSubmit(handleEmailLogin)} className="space-y-4">
                <FormField
                  control={emailForm.control}
                  name="email"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>이메일</FormLabel>
                      <FormControl>
                        <Input
                          type="email"
                          placeholder="name@example.com"
                          autoComplete="email"
                          className="text-base" // 모바일 줌 방지
                          {...field}
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
                
                <FormField
                  control={emailForm.control}
                  name="password"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>비밀번호</FormLabel>
                      <FormControl>
                        <div className="relative">
                          <Input
                            type={showPassword ? "text" : "password"}
                            placeholder="비밀번호를 입력하세요"
                            autoComplete="current-password"
                            className="text-base pr-10"
                            {...field}
                          />
                          <Button
                            type="button"
                            variant="ghost"
                            size="sm"
                            className="absolute right-0 top-0 h-full px-3 py-2 hover:bg-transparent"
                            onClick={() => setShowPassword(!showPassword)}
                          >
                            {showPassword ? (
                              <EyeOff className="h-4 w-4" />
                            ) : (
                              <Eye className="h-4 w-4" />
                            )}
                          </Button>
                        </div>
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
                
                <div className="flex items-center justify-between">
                  <FormField
                    control={emailForm.control}
                    name="rememberMe"
                    render={({ field }) => (
                      <FormItem className="flex flex-row items-center space-x-2 space-y-0">
                        <FormControl>
                          <Checkbox
                            checked={field.value}
                            onCheckedChange={field.onChange}
                          />
                        </FormControl>
                        <FormLabel className="text-sm font-normal">
                          로그인 상태 유지
                        </FormLabel>
                      </FormItem>
                    )}
                  />
                  
                  <Button variant="link" size="sm" asChild>
                    <Link href="/forgot-password">비밀번호 찾기</Link>
                  </Button>
                </div>
                
                {error && (
                  <Alert variant="destructive">
                    <AlertCircle className="h-4 w-4" />
                    <AlertDescription>{error.message}</AlertDescription>
                  </Alert>
                )}
                
                <Button type="submit" className="w-full" disabled={isLoading}>
                  {isLoading ? (
                    <>
                      <Loader2 className="w-4 h-4 animate-spin mr-2" />
                      로그인 중...
                    </>
                  ) : (
                    '로그인'
                  )}
                </Button>
              </form>
            </Form>
          </TabsContent>
          
          <TabsContent value="social" className="space-y-4">
            <div className="space-y-3">
              <Button
                variant="outline"
                className="w-full"
                onClick={() => loginWithProvider('google')}
                disabled={isLoading}
              >
                <svg className="w-4 h-4 mr-2" viewBox="0 0 24 24">
                  {/* Google 로고 SVG */}
                </svg>
                Google로 로그인
              </Button>
              
              <Button
                variant="outline"
                className="w-full"
                onClick={() => loginWithProvider('github')}
                disabled={isLoading}
              >
                <Github className="w-4 h-4 mr-2" />
                GitHub으로 로그인
              </Button>
            </div>
          </TabsContent>
        </Tabs>
        
        <Separator />
        
        <div className="text-center text-sm">
          <span className="text-muted-foreground">계정이 없으신가요? </span>
          <Button variant="link" size="sm" asChild className="p-0">
            <Link href="/signup">회원가입</Link>
          </Button>
        </div>
      </CardContent>
    </Card>
  )
}
```

### **4. 권한 기반 접근 제어**

**HOC 및 Hook 기반 권한 관리**
```typescript
// src/lib/auth/permissions.ts
// 권한 체크 HOC
export function withPermission<P extends object>(
  WrappedComponent: React.ComponentType<P>,
  requiredPermissions: Permission | Permission[],
  options?: {
    fallback?: React.ComponentType
    redirectTo?: string
    requireAll?: boolean
  }
) {
  return function PermissionWrapper(props: P) {
    const { hasPermission, hasAnyPermission, isAuthenticated } = useAuthStore()
    const router = useRouter()
    
    const permissions = Array.isArray(requiredPermissions) 
      ? requiredPermissions 
      : [requiredPermissions]
    
    const hasAccess = options?.requireAll 
      ? permissions.every(p => hasPermission(p))
      : hasAnyPermission(permissions)
    
    // 인증되지 않은 경우
    if (!isAuthenticated) {
      if (options?.redirectTo) {
        router.push(options.redirectTo)
        return null
      }
      return options?.fallback ? <options.fallback /> : <AccessDenied />
    }
    
    // 권한이 없는 경우
    if (!hasAccess) {
      return options?.fallback ? <options.fallback /> : <AccessDenied />
    }
    
    return <WrappedComponent {...props} />
  }
}

// 권한 체크 Hook
export function usePermissions() {
  const { hasPermission, hasAnyPermission, hasRole, user } = useAuthStore()
  
  return {
    hasPermission,
    hasAnyPermission,
    hasRole,
    user,
    
    // 편의 메소드들
    canCreateSchedule: () => hasPermission('schedule:create'),
    canEditProject: () => hasPermission('project:update'),
    canManageUsers: () => hasPermission('user:manage'),
    isAdmin: () => hasRole('admin'),
    isManager: () => hasRole('manager') || hasRole('admin'),
    
    // 조건부 렌더링을 위한 컴포넌트
    PermissionGate: ({ 
      permission, 
      role, 
      children, 
      fallback 
    }: PermissionGateProps) => {
      let hasAccess = true
      
      if (permission) {
        hasAccess = Array.isArray(permission)
          ? hasAnyPermission(permission)
          : hasPermission(permission)
      }
      
      if (role && hasAccess) {
        hasAccess = hasRole(role)
      }
      
      return hasAccess ? <>{children}</> : <>{fallback}</>
    }
  }
}

// 권한 기반 라우팅
export function ProtectedRoute({ 
  children, 
  permissions, 
  roles,
  redirectTo = '/login'
}: ProtectedRouteProps) {
  const { isAuthenticated, hasPermission, hasAnyPermission, hasRole } = useAuthStore()
  const router = useRouter()
  
  useEffect(() => {
    if (!isAuthenticated) {
      router.push(redirectTo)
      return
    }
    
    let hasAccess = true
    
    if (permissions) {
      hasAccess = Array.isArray(permissions)
        ? hasAnyPermission(permissions)
        : hasPermission(permissions)
    }
    
    if (roles && hasAccess) {
      hasAccess = Array.isArray(roles)
        ? roles.some(role => hasRole(role))
        : hasRole(roles)
    }
    
    if (!hasAccess) {
      router.push('/unauthorized')
    }
  }, [isAuthenticated, permissions, roles, redirectTo])
  
  if (!isAuthenticated) {
    return <LoginSkeleton />
  }
  
  return <>{children}</>
}
```

### **5. 보안 미들웨어 및 인터셉터**

**API 요청 보안 처리**
```typescript
// src/lib/auth/securityMiddleware.ts
export class SecurityInterceptor {
  // Apollo Link 보안 인터셉터
  static createAuthLink(): ApolloLink {
    const authLink = setContext(async (_, { headers }) => {
      let token = TokenManager.getAccessToken()
      
      // 토큰이 만료되었거나 곧 만료될 경우 갱신
      if (!TokenManager.isTokenValid()) {
        try {
          const refreshed = await TokenManager.refreshToken()
          token = refreshed.accessToken
        } catch (error) {
          // 갱신 실패 시 로그아웃
          useAuthStore.getState().logout()
          throw new Error('Authentication failed')
        }
      }
      
      return {
        headers: {
          ...headers,
          authorization: token ? `Bearer ${token}` : "",
          'X-Requested-With': 'XMLHttpRequest', // CSRF 방지
        }
      }
    })
    
    const errorLink = onError(({ graphQLErrors, networkError, operation, forward }) => {
      if (graphQLErrors) {
        graphQLErrors.forEach(({ message, locations, path, extensions }) => {
          if (extensions?.code === 'UNAUTHENTICATED') {
            // 인증 오류 시 로그아웃
            useAuthStore.getState().logout()
          } else if (extensions?.code === 'FORBIDDEN') {
            // 권한 오류 처리
            showToast('error', '접근 권한이 없습니다')
          }
        })
      }
      
      if (networkError) {
        if (networkError.statusCode === 401) {
          useAuthStore.getState().logout()
        }
      }
    })
    
    return ApolloLink.from([errorLink, authLink])
  }
  
  // XSS 방지 헬퍼
  static sanitizeInput(input: string): string {
    return DOMPurify.sanitize(input, {
      ALLOWED_TAGS: [], // 모든 HTML 태그 제거
      ALLOWED_ATTR: []
    })
  }
  
  // CSRF 토큰 관리
  static async getCSRFToken(): Promise<string> {
    try {
      const response = await fetch('/api/csrf-token', {
        credentials: 'include'
      })
      const { token } = await response.json()
      return token
    } catch (error) {
      throw new Error('Failed to get CSRF token')
    }
  }
  
  // 민감 정보 로깅 필터
  static filterSensitiveData(data: any): any {
    const sensitiveFields = ['password', 'token', 'secret', 'key', 'authorization']
    
    if (typeof data !== 'object' || data === null) {
      return data
    }
    
    const filtered = { ...data }
    
    Object.keys(filtered).forEach(key => {
      if (sensitiveFields.some(field => key.toLowerCase().includes(field))) {
        filtered[key] = '[REDACTED]'
      } else if (typeof filtered[key] === 'object') {
        filtered[key] = this.filterSensitiveData(filtered[key])
      }
    })
    
    return filtered
  }
}

// 보안 헤더 설정 (Next.js middleware)
// middleware.ts
export function middleware(request: NextRequest) {
  const response = NextResponse.next()
  
  // 보안 헤더 설정
  response.headers.set('X-DNS-Prefetch-Control', 'off')
  response.headers.set('X-Frame-Options', 'SAMEORIGIN')
  response.headers.set('X-Content-Type-Options', 'nosniff')
  response.headers.set('Referrer-Policy', 'strict-origin-when-cross-origin')
  response.headers.set('Permissions-Policy', 'camera=(), microphone=(), geolocation=()')
  
  // CSP 헤더
  const cspHeader = [
    "default-src 'self'",
    "script-src 'self' 'unsafe-eval' 'unsafe-inline'", // Next.js에 필요
    "style-src 'self' 'unsafe-inline'",
    "img-src 'self' blob: data:",
    "font-src 'self'",
    "object-src 'none'",
    "base-uri 'self'",
    "form-action 'self'",
    "frame-ancestors 'none'",
    "upgrade-insecure-requests"
  ].join('; ')
  
  response.headers.set('Content-Security-Policy', cspHeader)
  
  return response
}

export const config = {
  matcher: [
    '/((?!api|_next/static|_next/image|favicon.ico).*)',
  ],
}
```

---

## 🎨 **사용자 경험 (UX) 설계**

### **1. 2단계 인증 설정**

**사용자 친화적 2FA 설정 플로우**
```typescript
// src/components/auth/TwoFactorSetup.tsx
const TwoFactorSetup = () => {
  const [step, setStep] = useState<'intro' | 'scan' | 'verify' | 'backup' | 'complete'>('intro')
  const [qrCode, setQRCode] = useState<string>('')
  const [secret, setSecret] = useState<string>('')
  const [backupCodes, setBackupCodes] = useState<string[]>([])
  
  const form = useForm<{ verificationCode: string }>()
  
  const handleSetupStart = async () => {
    try {
      const response = await fetch('/api/auth/2fa/setup', {
        method: 'POST',
        credentials: 'include'
      })
      const data = await response.json()
      
      setQRCode(data.qrCode)
      setSecret(data.secret)
      setStep('scan')
    } catch (error) {
      showToast('error', '2FA 설정을 시작할 수 없습니다')
    }
  }
  
  const handleVerification = async (data: { verificationCode: string }) => {
    try {
      const response = await fetch('/api/auth/2fa/verify-setup', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ code: data.verificationCode })
      })
      
      if (!response.ok) {
        throw new Error('인증 코드가 올바르지 않습니다')
      }
      
      const result = await response.json()
      setBackupCodes(result.backupCodes)
      setStep('backup')
    } catch (error) {
      form.setError('verificationCode', { 
        message: error.message || '인증에 실패했습니다' 
      })
    }
  }
  
  return (
    <Card className="w-full max-w-lg mx-auto">
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <Shield className="w-5 h-5" />
          2단계 인증 설정
        </CardTitle>
      </CardHeader>
      
      <CardContent>
        {step === 'intro' && (
          <div className="space-y-4 text-center">
            <div className="bg-blue-50 p-4 rounded-lg">
              <Shield className="w-12 h-12 text-blue-600 mx-auto mb-3" />
              <h3 className="font-semibold mb-2">계정 보안 강화</h3>
              <p className="text-sm text-muted-foreground">
                2단계 인증으로 계정을 더욱 안전하게 보호하세요
              </p>
            </div>
            
            <div className="space-y-3 text-left">
              <div className="flex items-start gap-3">
                <Smartphone className="w-5 h-5 text-blue-600 mt-0.5" />
                <div>
                  <h4 className="font-medium text-sm">인증 앱 설치</h4>
                  <p className="text-xs text-muted-foreground">
                    Google Authenticator, Authy 등의 앱이 필요합니다
                  </p>
                </div>
              </div>
              
              <div className="flex items-start gap-3">
                <Key className="w-5 h-5 text-blue-600 mt-0.5" />
                <div>
                  <h4 className="font-medium text-sm">백업 코드 제공</h4>
                  <p className="text-xs text-muted-foreground">
                    휴대폰을 분실한 경우를 대비한 복구 코드를 제공합니다
                  </p>
                </div>
              </div>
            </div>
            
            <Button onClick={handleSetupStart} className="w-full">
              설정 시작하기
            </Button>
          </div>
        )}
        
        {step === 'scan' && (
          <div className="space-y-4">
            <div className="text-center">
              <h3 className="font-semibold mb-2">QR 코드 스캔</h3>
              <p className="text-sm text-muted-foreground mb-4">
                인증 앱으로 아래 QR 코드를 스캔하세요
              </p>
              
              <div className="bg-white p-4 rounded-lg border-2 border-dashed border-gray-300 inline-block">
                <QRCodeSVG value={qrCode} size={200} />
              </div>
            </div>
            
            <Collapsible>
              <CollapsibleTrigger className="flex items-center gap-2 text-sm text-muted-foreground">
                <Key className="w-4 h-4" />
                수동으로 키 입력하기
                <ChevronRight className="w-4 h-4" />
              </CollapsibleTrigger>
              <CollapsibleContent className="mt-2">
                <div className="bg-muted p-3 rounded font-mono text-sm break-all">
                  {secret}
                </div>
                <Button 
                  variant="outline" 
                  size="sm" 
                  onClick={() => navigator.clipboard.writeText(secret)}
                  className="mt-2"
                >
                  복사
                </Button>
              </CollapsibleContent>
            </Collapsible>
            
            <Button onClick={() => setStep('verify')} className="w-full">
              다음 단계
            </Button>
          </div>
        )}
        
        {step === 'verify' && (
          <Form {...form}>
            <form onSubmit={form.handleSubmit(handleVerification)} className="space-y-4">
              <div className="text-center">
                <h3 className="font-semibold mb-2">인증 코드 확인</h3>
                <p className="text-sm text-muted-foreground mb-4">
                  앱에서 생성된 6자리 코드를 입력하세요
                </p>
              </div>
              
              <FormField
                control={form.control}
                name="verificationCode"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <InputOTP
                        maxLength={6}
                        value={field.value}
                        onChange={field.onChange}
                        className="justify-center"
                      >
                        {Array.from({ length: 6 }).map((_, index) => (
                          <InputOTPSlot key={index} index={index} />
                        ))}
                      </InputOTP>
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              
              <Button type="submit" className="w-full">
                인증 확인
              </Button>
            </form>
          </Form>
        )}
        
        {step === 'backup' && (
          <div className="space-y-4">
            <div className="text-center">
              <h3 className="font-semibold mb-2">백업 코드 저장</h3>
              <p className="text-sm text-muted-foreground mb-4">
                이 코드들을 안전한 곳에 보관하세요. 휴대폰을 분실했을 때 사용할 수 있습니다.
              </p>
            </div>
            
            <Alert>
              <AlertTriangle className="h-4 w-4" />
              <AlertTitle>중요</AlertTitle>
              <AlertDescription>
                각 백업 코드는 한 번만 사용할 수 있습니다. 안전한 곳에 보관하세요.
              </AlertDescription>
            </Alert>
            
            <div className="bg-muted p-4 rounded-lg">
              <div className="grid grid-cols-2 gap-2 font-mono text-sm">
                {backupCodes.map((code, index) => (
                  <div key={index} className="p-2 bg-background rounded border">
                    {code}
                  </div>
                ))}
              </div>
            </div>
            
            <div className="flex gap-2">
              <Button
                variant="outline"
                onClick={() => {
                  const text = backupCodes.join('\n')
                  navigator.clipboard.writeText(text)
                  showToast('success', '백업 코드가 복사되었습니다')
                }}
                className="flex-1"
              >
                <Copy className="w-4 h-4 mr-2" />
                복사
              </Button>
              
              <Button
                variant="outline"
                onClick={() => {
                  const blob = new Blob([backupCodes.join('\n')], { type: 'text/plain' })
                  const url = URL.createObjectURL(blob)
                  const a = document.createElement('a')
                  a.href = url
                  a.download = 'baro-calendar-backup-codes.txt'
                  a.click()
                  URL.revokeObjectURL(url)
                }}
                className="flex-1"
              >
                <Download className="w-4 h-4 mr-2" />
                다운로드
              </Button>
            </div>
            
            <Button onClick={() => setStep('complete')} className="w-full">
              설정 완료
            </Button>
          </div>
        )}
        
        {step === 'complete' && (
          <div className="text-center space-y-4">
            <div className="bg-green-50 p-4 rounded-lg">
              <CheckCircle className="w-12 h-12 text-green-600 mx-auto mb-3" />
              <h3 className="font-semibold text-green-800 mb-2">설정 완료!</h3>
              <p className="text-sm text-green-700">
                2단계 인증이 성공적으로 활성화되었습니다
              </p>
            </div>
            
            <div className="text-left space-y-2 text-sm text-muted-foreground">
              <p>• 다음 로그인부터 인증 코드가 요구됩니다</p>
              <p>• 백업 코드는 안전한 곳에 보관해주세요</p>
              <p>• 언제든지 설정에서 비활성화할 수 있습니다</p>
            </div>
            
            <Button onClick={() => window.location.reload()} className="w-full">
              완료
            </Button>
          </div>
        )}
      </CardContent>
    </Card>
  )
}
```

---

## 📊 **보안 모니터링 및 감사**

```typescript
// src/lib/security/auditLogger.ts
export interface SecurityEvent {
  type: 'login' | 'logout' | 'failed_login' | 'permission_denied' | 'data_access' | '2fa_setup'
  userId?: string
  userEmail?: string
  ipAddress: string
  userAgent: string
  timestamp: string
  details: Record<string, any>
  severity: 'low' | 'medium' | 'high' | 'critical'
}

export class SecurityAuditLogger {
  static async logSecurityEvent(event: Omit<SecurityEvent, 'timestamp' | 'ipAddress' | 'userAgent'>) {
    try {
      // 클라이언트 정보 수집
      const clientInfo = {
        timestamp: new Date().toISOString(),
        ipAddress: await this.getClientIP(),
        userAgent: navigator.userAgent,
      }
      
      const securityEvent: SecurityEvent = {
        ...event,
        ...clientInfo
      }
      
      // 서버로 전송
      await fetch('/api/security/audit', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
        body: JSON.stringify(securityEvent)
      })
      
      // 중요 이벤트는 실시간 알림
      if (event.severity === 'high' || event.severity === 'critical') {
        this.sendRealTimeAlert(securityEvent)
      }
      
    } catch (error) {
      console.error('Failed to log security event:', error)
    }
  }
  
  private static async getClientIP(): Promise<string> {
    try {
      const response = await fetch('/api/client-info')
      const data = await response.json()
      return data.ip || 'unknown'
    } catch {
      return 'unknown'
    }
  }
  
  private static sendRealTimeAlert(event: SecurityEvent) {
    // WebSocket 또는 Server-Sent Events로 실시간 알림
    if (wsManager.isConnected()) {
      wsManager.send({
        type: 'SECURITY_ALERT',
        payload: event
      })
    }
  }
  
  // 편의 메소드들
  static logSuccessfulLogin(userId: string, userEmail: string) {
    this.logSecurityEvent({
      type: 'login',
      userId,
      userEmail,
      severity: 'low',
      details: { success: true }
    })
  }
  
  static logFailedLogin(email: string, reason: string) {
    this.logSecurityEvent({
      type: 'failed_login',
      userEmail: email,
      severity: 'medium',
      details: { reason, success: false }
    })
  }
  
  static logPermissionDenied(userId: string, resource: string, action: string) {
    this.logSecurityEvent({
      type: 'permission_denied',
      userId,
      severity: 'medium',
      details: { resource, action }
    })
  }
}
```

---

## ✅ **Definition of Done**

### **기능 요구사항**
- [ ] JWT 기반 액세스/리프레시 토큰 자동 관리
- [ ] 이메일/비밀번호 및 소셜 로그인 지원
- [ ] 2단계 인증 (TOTP) 설정 및 검증
- [ ] 역할 기반 권한 관리 (RBAC)
- [ ] 자동 토큰 갱신 및 세션 관리

### **기술 요구사항**
- [ ] Zustand 기반 인증 상태 관리
- [ ] Apollo Client 인증 인터셉터
- [ ] Next.js 보안 미들웨어 구현
- [ ] httpOnly 쿠키 + sessionStorage 하이브리드 토큰 저장
- [ ] 보안 헤더 (CSP, HSTS, X-Frame-Options) 적용

### **보안 요구사항**
- [ ] XSS 방지 (DOMPurify, CSP 헤더)
- [ ] CSRF 방지 (토큰 검증, SameSite 쿠키)
- [ ] 브루트 포스 공격 방지 (로그인 시도 제한)
- [ ] 민감 정보 로깅 필터링
- [ ] 보안 이벤트 감사 로깅

### **접근성 요구사항**
- [ ] 로그인 폼 키보드 네비게이션 완전 지원
- [ ] 2FA 설정 과정 스크린 리더 지원
- [ ] 에러 메시지 적절한 ARIA 레이블
- [ ] 고대비 모드 지원

### **성능 요구사항**
- [ ] 토큰 검증 응답시간 100ms 이하
- [ ] 자동 갱신 백그라운드 처리
- [ ] 보안 이벤트 로깅 비동기 처리
- [ ] 메모리 내 권한 캐싱 최적화

### **테스트 요구사항**
- [ ] 인증 플로우 단위 테스트
- [ ] 권한 체크 로직 테스트
- [ ] 토큰 갱신 시나리오 테스트
- [ ] 보안 공격 시나리오 E2E 테스트

---

## 📚 **관련 문서 참조**

- [10. 보안 모범 사례](../ui-architecture/10-security-best-practices.md)
- [11. 접근성 구현](../ui-architecture/11-accessibility-implementation.md)
- [20. 표준 에러 포맷 및 핸들링](../ui-architecture/20-error-handling.md)
- [21. Observability 및 모니터링](../ui-architecture/21-observability-monitoring.md)

---

**이 스토리는 바로캘린더의 완전한 인증 및 보안 시스템을 구현하기 위한 종합적인 기술 가이드입니다. JWT 기반의 현대적인 인증 방식과 다양한 보안 위협에 대한 방어 메커니즘을 통합하여 안전하고 사용자 친화적인 시스템을 구축합니다.**