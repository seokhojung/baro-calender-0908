# Story 1.9: ì¸ì¦ ë° ë³´ì•ˆ ì‹œìŠ¤í…œ

## Status
Ready for Development

## Priority & Dependencies
- **Priority**: P0 (Critical)
- **Story Points**: 8
- **Dependencies**: [1.1a]
- **Blocked By**: None

## Success Metrics
- **Business KPI**: 
  - ë¡œê·¸ì¸ ì„±ê³µë¥  99% ì´ìƒ
  - ë¡œê·¸ì¸ ì‹œê°„ 2ì´ˆ ì´ë‚´
  - 2FA ì±„íƒë¥  30% ì´ìƒ
- **Technical KPI**:
  - í† í° ê²€ì¦ ì‹œê°„ 10ms ì´ë‚´
  - ìë™ í† í° ê°±ì‹  ì„±ê³µë¥  100%
  - ë³´ì•ˆ ì·¨ì•½ì  0ê°œ
- **Definition of Success**: ì•ˆì „í•œ ì¸ì¦ ì‹œìŠ¤í…œ, OWASP Top 10 ëŒ€ì‘

---

## ğŸ¯ **ìŠ¤í† ë¦¬ ëª©í‘œ**

**ì™„ì „í•œ ì¸ì¦ ë° ë³´ì•ˆ ì‹œìŠ¤í…œ**
- JWT ê¸°ë°˜ ì•¡ì„¸ìŠ¤/ë¦¬í”„ë ˆì‹œ í† í° ê´€ë¦¬
- ë‹¤ì¤‘ ì¸ì¦ ë°©ì‹ ì§€ì› (ì´ë©”ì¼, ì†Œì…œ ë¡œê·¸ì¸, 2FA)
- ì—­í•  ê¸°ë°˜ ê¶Œí•œ ê´€ë¦¬ (RBAC) ì‹œìŠ¤í…œ
- XSS/CSRF ë°©ì§€ ë° ë³´ì•ˆ í—¤ë” ì ìš©
- ë¯¼ê° ì •ë³´ ë³´í˜¸ ë° ê°ì‚¬ ë¡œê¹…

---

## Story
**As a** ì‚¬ìš©ì,
**I want** ì•ˆì „í•œ ì¸ì¦ ì‹œìŠ¤í…œì„ í†µí•´ ë¡œê·¸ì¸í•˜ê³  ê¶Œí•œì— ë”°ë¼ ê¸°ëŠ¥ì— ì ‘ê·¼í•  ìˆ˜ ìˆëŠ” ì‹œìŠ¤í…œì„ ì‚¬ìš©í•˜ì—¬,
**so that** ë‚´ ë°ì´í„°ë¥¼ ì•ˆì „í•˜ê²Œ ë³´í˜¸í•˜ê³  ë¶€ì—¬ë°›ì€ ê¶Œí•œ ë‚´ì—ì„œ ì‘ì—…í•  ìˆ˜ ìˆë‹¤.

## Acceptance Criteria
1. ì´ë©”ì¼/ë¹„ë°€ë²ˆí˜¸ ë˜ëŠ” ì†Œì…œ ë¡œê·¸ì¸ìœ¼ë¡œ ì•ˆì „í•˜ê²Œ ë¡œê·¸ì¸í•˜ê³  ì‹¶ë‹¤
2. 2ë‹¨ê³„ ì¸ì¦ìœ¼ë¡œ ê³„ì • ë³´ì•ˆì„ ê°•í™”í•˜ê³  ì‹¶ë‹¤
3. í† í°ì´ ë§Œë£Œë˜ì–´ë„ ìë™ìœ¼ë¡œ ê°±ì‹ ë˜ì–´ ëŠê¹€ì—†ì´ ì‚¬ìš©í•˜ê³  ì‹¶ë‹¤
4. ê¶Œí•œì— ë”°ë¼ ë‹¤ë¥¸ ê¸°ëŠ¥ì— ì ‘ê·¼í•˜ê³  ì‹¶ë‹¤
5. ë‚´ ê°œì¸ì •ë³´ì™€ ì¼ì •ì´ ì•ˆì „í•˜ê²Œ ë³´í˜¸ë˜ê¸¸ ë°”ë€ë‹¤

---

## ğŸ—ï¸ **ê¸°ìˆ ì  êµ¬í˜„ ìš”êµ¬ì‚¬í•­**

### **1. JWT í† í° ê¸°ë°˜ ì¸ì¦ ì‹œìŠ¤í…œ**

**í† í° ê´€ë¦¬ ë° ìë™ ê°±ì‹ **
```typescript
// src/lib/auth/tokenManager.ts
export interface AuthTokens {
  accessToken: string
  refreshToken: string
  expiresAt: number
  tokenType: 'Bearer'
  user: User
}

export interface User {
  id: string
  email: string
  name: string
  avatar?: string
  role: UserRole
  permissions: Permission[]
  preferences: UserPreferences
  lastLoginAt: string
  createdAt: string
}

export type UserRole = 'admin' | 'manager' | 'member' | 'viewer'

export type Permission = 
  | 'schedule:create' | 'schedule:read' | 'schedule:update' | 'schedule:delete'
  | 'project:create' | 'project:read' | 'project:update' | 'project:delete'
  | 'user:manage' | 'settings:manage'

export class TokenManager {
  private static readonly ACCESS_TOKEN_KEY = 'baro_access_token'
  private static readonly REFRESH_TOKEN_KEY = 'baro_refresh_token'
  private static readonly TOKEN_EXPIRY_KEY = 'baro_token_expiry'
  private static refreshPromise: Promise<AuthTokens> | null = null
  
  // í† í° ì €ì¥ (httpOnly ì¿ í‚¤ + localStorage í•˜ì´ë¸Œë¦¬ë“œ)
  static setTokens(tokens: AuthTokens): void {
    // ì•¡ì„¸ìŠ¤ í† í°ì€ ë©”ëª¨ë¦¬ì—ë§Œ (ë³´ì•ˆ)
    sessionStorage.setItem(this.ACCESS_TOKEN_KEY, tokens.accessToken)
    
    // ë¦¬í”„ë ˆì‹œ í† í°ì€ httpOnly ì¿ í‚¤ë¡œ ì„œë²„ì—ì„œ ê´€ë¦¬
    // í´ë¼ì´ì–¸íŠ¸ì—ì„œëŠ” ë§Œë£Œ ì‹œê°„ë§Œ ì €ì¥
    localStorage.setItem(this.TOKEN_EXPIRY_KEY, tokens.expiresAt.toString())
    
    // ì‚¬ìš©ì ì •ë³´ëŠ” localStorage
    localStorage.setItem('baro_user', JSON.stringify(tokens.user))
  }
  
  // ì•¡ì„¸ìŠ¤ í† í° ì¡°íšŒ
  static getAccessToken(): string | null {
    return sessionStorage.getItem(this.ACCESS_TOKEN_KEY)
  }
  
  // í† í° ìœ íš¨ì„± ê²€ì‚¬
  static isTokenValid(): boolean {
    const accessToken = this.getAccessToken()
    const expiryStr = localStorage.getItem(this.TOKEN_EXPIRY_KEY)
    
    if (!accessToken || !expiryStr) return false
    
    const expiry = parseInt(expiryStr)
    const now = Date.now()
    
    // 5ë¶„ ì—¬ìœ ë¥¼ ë‘ê³  ê°±ì‹ 
    return (expiry - now) > 5 * 60 * 1000
  }
  
  // ìë™ í† í° ê°±ì‹ 
  static async refreshToken(): Promise<AuthTokens> {
    // ì¤‘ë³µ ê°±ì‹  ë°©ì§€
    if (this.refreshPromise) {
      return this.refreshPromise
    }
    
    this.refreshPromise = this.performTokenRefresh()
    
    try {
      const tokens = await this.refreshPromise
      this.refreshPromise = null
      return tokens
    } catch (error) {
      this.refreshPromise = null
      throw error
    }
  }
  
  private static async performTokenRefresh(): Promise<AuthTokens> {
    try {
      const response = await fetch('/api/auth/refresh', {
        method: 'POST',
        credentials: 'include', // httpOnly ì¿ í‚¤ í¬í•¨
        headers: {
          'Content-Type': 'application/json',
        }
      })
      
      if (!response.ok) {
        throw new Error('Token refresh failed')
      }
      
      const tokens: AuthTokens = await response.json()
      this.setTokens(tokens)
      
      // ê°±ì‹  ì„±ê³µ ì´ë²¤íŠ¸ ë°œìƒ
      window.dispatchEvent(new CustomEvent('auth:token-refreshed', {
        detail: tokens
      }))
      
      return tokens
    } catch (error) {
      // ê°±ì‹  ì‹¤íŒ¨ ì‹œ ë¡œê·¸ì•„ì›ƒ
      this.clearTokens()
      window.dispatchEvent(new CustomEvent('auth:refresh-failed'))
      throw error
    }
  }
  
  // í† í° ì‚­ì œ
  static clearTokens(): void {
    sessionStorage.removeItem(this.ACCESS_TOKEN_KEY)
    localStorage.removeItem(this.TOKEN_EXPIRY_KEY)
    localStorage.removeItem('baro_user')
  }
  
  // ìë™ ê°±ì‹  ìŠ¤ì¼€ì¤„ëŸ¬
  static startAutoRefresh(): void {
    const checkInterval = setInterval(() => {
      const expiryStr = localStorage.getItem(this.TOKEN_EXPIRY_KEY)
      if (!expiryStr) return
      
      const expiry = parseInt(expiryStr)
      const now = Date.now()
      const timeUntilExpiry = expiry - now
      
      // 10ë¶„ ì „ì— ê°±ì‹  ì‹œë„
      if (timeUntilExpiry <= 10 * 60 * 1000 && timeUntilExpiry > 0) {
        this.refreshToken().catch(console.error)
      } else if (timeUntilExpiry <= 0) {
        // í† í°ì´ ì´ë¯¸ ë§Œë£Œëœ ê²½ìš°
        clearInterval(checkInterval)
        this.clearTokens()
        window.location.href = '/login'
      }
    }, 60 * 1000) // 1ë¶„ë§ˆë‹¤ ì²´í¬
  }
}
```

### **2. ì¸ì¦ ìƒíƒœ ê´€ë¦¬**

**Zustand ê¸°ë°˜ ì¸ì¦ Store**
```typescript
// src/stores/authStore.ts
interface AuthState {
  // ì¸ì¦ ìƒíƒœ
  isAuthenticated: boolean
  user: User | null
  isLoading: boolean
  error: AuthError | null
  
  // ë¡œê·¸ì¸ ìƒíƒœ
  loginMethod: 'email' | 'google' | 'github' | null
  requiresTwoFactor: boolean
  twoFactorToken: string | null
  
  // ê¶Œí•œ
  permissions: Set<Permission>
  
  // Actions
  login: (credentials: LoginCredentials) => Promise<void>
  loginWithProvider: (provider: 'google' | 'github') => Promise<void>
  verifyTwoFactor: (token: string, code: string) => Promise<void>
  logout: () => Promise<void>
  checkAuthStatus: () => Promise<void>
  updateUser: (updates: Partial<User>) => void
  
  // ê¶Œí•œ ì²´í¬
  hasPermission: (permission: Permission) => boolean
  hasAnyPermission: (permissions: Permission[]) => boolean
  hasRole: (role: UserRole) => boolean
}

export const useAuthStore = create<AuthState>()(
  devtools(
    subscribeWithSelector(
      immer((set, get) => ({
        isAuthenticated: false,
        user: null,
        isLoading: false,
        error: null,
        loginMethod: null,
        requiresTwoFactor: false,
        twoFactorToken: null,
        permissions: new Set(),
        
        login: async (credentials) => {
          set(state => {
            state.isLoading = true
            state.error = null
          })
          
          try {
            const response = await fetch('/api/auth/login', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              credentials: 'include',
              body: JSON.stringify(credentials)
            })
            
            const data = await response.json()
            
            if (!response.ok) {
              throw new Error(data.message || 'Login failed')
            }
            
            // 2FA í•„ìš”í•œ ê²½ìš°
            if (data.requiresTwoFactor) {
              set(state => {
                state.requiresTwoFactor = true
                state.twoFactorToken = data.twoFactorToken
                state.isLoading = false
              })
              return
            }
            
            // ë¡œê·¸ì¸ ì„±ê³µ
            const tokens: AuthTokens = data
            TokenManager.setTokens(tokens)
            
            set(state => {
              state.isAuthenticated = true
              state.user = tokens.user
              state.permissions = new Set(tokens.user.permissions)
              state.loginMethod = 'email'
              state.isLoading = false
              state.requiresTwoFactor = false
              state.twoFactorToken = null
            })
            
            // í† í° ìë™ ê°±ì‹  ì‹œì‘
            TokenManager.startAutoRefresh()
            
          } catch (error) {
            set(state => {
              state.error = error as AuthError
              state.isLoading = false
            })
          }
        },
        
        loginWithProvider: async (provider) => {
          set(state => {
            state.isLoading = true
            state.error = null
          })
          
          try {
            // OAuth ë¦¬ë‹¤ì´ë ‰íŠ¸
            const authUrl = `/api/auth/${provider}`
            window.location.href = authUrl
          } catch (error) {
            set(state => {
              state.error = error as AuthError
              state.isLoading = false
            })
          }
        },
        
        verifyTwoFactor: async (token, code) => {
          set(state => { state.isLoading = true })
          
          try {
            const response = await fetch('/api/auth/2fa/verify', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              credentials: 'include',
              body: JSON.stringify({ token, code })
            })
            
            const tokens: AuthTokens = await response.json()
            
            if (!response.ok) {
              throw new Error('Invalid 2FA code')
            }
            
            TokenManager.setTokens(tokens)
            
            set(state => {
              state.isAuthenticated = true
              state.user = tokens.user
              state.permissions = new Set(tokens.user.permissions)
              state.requiresTwoFactor = false
              state.twoFactorToken = null
              state.isLoading = false
            })
            
            TokenManager.startAutoRefresh()
            
          } catch (error) {
            set(state => {
              state.error = error as AuthError
              state.isLoading = false
            })
          }
        },
        
        logout: async () => {
          try {
            await fetch('/api/auth/logout', {
              method: 'POST',
              credentials: 'include'
            })
          } catch (error) {
            console.error('Logout error:', error)
          }
          
          TokenManager.clearTokens()
          
          set(state => {
            state.isAuthenticated = false
            state.user = null
            state.permissions = new Set()
            state.loginMethod = null
            state.error = null
          })
        },
        
        checkAuthStatus: async () => {
          // ì €ì¥ëœ ì‚¬ìš©ì ì •ë³´ í™•ì¸
          const userStr = localStorage.getItem('baro_user')
          if (userStr && TokenManager.isTokenValid()) {
            try {
              const user = JSON.parse(userStr)
              set(state => {
                state.isAuthenticated = true
                state.user = user
                state.permissions = new Set(user.permissions)
              })
              
              TokenManager.startAutoRefresh()
            } catch (error) {
              TokenManager.clearTokens()
            }
          }
        },
        
        hasPermission: (permission) => {
          return get().permissions.has(permission)
        },
        
        hasAnyPermission: (permissions) => {
          const userPermissions = get().permissions
          return permissions.some(permission => userPermissions.has(permission))
        },
        
        hasRole: (role) => {
          return get().user?.role === role
        }
      }))
    ),
    { name: 'Auth Store' }
  )
)
```

### **3. ë¡œê·¸ì¸ UI ì»´í¬ë„ŒíŠ¸**

**ë‹¤ì¤‘ ì¸ì¦ ë°©ì‹ ì§€ì› ë¡œê·¸ì¸ í¼**
```typescript
// src/components/auth/LoginForm.tsx
const LoginForm = () => {
  const { login, loginWithProvider, verifyTwoFactor, isLoading, error, requiresTwoFactor, twoFactorToken } = useAuthStore()
  const [loginMethod, setLoginMethod] = useState<'email' | 'social'>('email')
  const [showPassword, setShowPassword] = useState(false)
  
  const emailForm = useForm<LoginCredentials>({
    resolver: zodResolver(loginSchema),
    defaultValues: {
      email: '',
      password: '',
      rememberMe: false
    }
  })
  
  const twoFactorForm = useForm<{ code: string }>({
    resolver: zodResolver(z.object({
      code: z.string().min(6, '6ìë¦¬ ì½”ë“œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”').max(6)
    }))
  })
  
  const handleEmailLogin = async (data: LoginCredentials) => {
    await login(data)
  }
  
  const handleTwoFactorVerify = async (data: { code: string }) => {
    if (!twoFactorToken) return
    await verifyTwoFactor(twoFactorToken, data.code)
  }
  
  // 2FA í•„ìš”í•œ ê²½ìš°
  if (requiresTwoFactor) {
    return (
      <Card className="w-full max-w-md mx-auto">
        <CardHeader className="text-center">
          <div className="flex justify-center mb-4">
            <Shield className="w-12 h-12 text-primary" />
          </div>
          <CardTitle>2ë‹¨ê³„ ì¸ì¦</CardTitle>
          <CardDescription>
            ì¸ì¦ ì•±ì— í‘œì‹œëœ 6ìë¦¬ ì½”ë“œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”
          </CardDescription>
        </CardHeader>
        
        <CardContent>
          <Form {...twoFactorForm}>
            <form onSubmit={twoFactorForm.handleSubmit(handleTwoFactorVerify)} className="space-y-4">
              <FormField
                control={twoFactorForm.control}
                name="code"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <InputOTP
                        maxLength={6}
                        value={field.value}
                        onChange={field.onChange}
                        className="justify-center"
                      >
                        {Array.from({ length: 6 }).map((_, index) => (
                          <InputOTPSlot key={index} index={index} />
                        ))}
                      </InputOTP>
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              
              {error && (
                <Alert variant="destructive">
                  <AlertCircle className="h-4 w-4" />
                  <AlertDescription>{error.message}</AlertDescription>
                </Alert>
              )}
              
              <Button type="submit" className="w-full" disabled={isLoading}>
                {isLoading ? (
                  <>
                    <Loader2 className="w-4 h-4 animate-spin mr-2" />
                    ì¸ì¦ ì¤‘...
                  </>
                ) : (
                  'ì¸ì¦ í™•ì¸'
                )}
              </Button>
            </form>
          </Form>
        </CardContent>
      </Card>
    )
  }
  
  return (
    <Card className="w-full max-w-md mx-auto">
      <CardHeader className="text-center">
        <div className="flex justify-center mb-4">
          <Calendar className="w-12 h-12 text-primary" />
        </div>
        <CardTitle>ë°”ë¡œìº˜ë¦°ë”ì— ë¡œê·¸ì¸</CardTitle>
        <CardDescription>
          ê³„ì •ì— ë¡œê·¸ì¸í•˜ì—¬ ì¼ì •ì„ ê´€ë¦¬í•˜ì„¸ìš”
        </CardDescription>
      </CardHeader>
      
      <CardContent className="space-y-6">
        {/* ë¡œê·¸ì¸ ë°©ì‹ ì„ íƒ */}
        <Tabs value={loginMethod} onValueChange={setLoginMethod}>
          <TabsList className="grid w-full grid-cols-2">
            <TabsTrigger value="email">ì´ë©”ì¼</TabsTrigger>
            <TabsTrigger value="social">ì†Œì…œ ë¡œê·¸ì¸</TabsTrigger>
          </TabsList>
          
          <TabsContent value="email" className="space-y-4">
            <Form {...emailForm}>
              <form onSubmit={emailForm.handleSubmit(handleEmailLogin)} className="space-y-4">
                <FormField
                  control={emailForm.control}
                  name="email"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>ì´ë©”ì¼</FormLabel>
                      <FormControl>
                        <Input
                          type="email"
                          placeholder="name@example.com"
                          autoComplete="email"
                          className="text-base" // ëª¨ë°”ì¼ ì¤Œ ë°©ì§€
                          {...field}
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
                
                <FormField
                  control={emailForm.control}
                  name="password"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>ë¹„ë°€ë²ˆí˜¸</FormLabel>
                      <FormControl>
                        <div className="relative">
                          <Input
                            type={showPassword ? "text" : "password"}
                            placeholder="ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”"
                            autoComplete="current-password"
                            className="text-base pr-10"
                            {...field}
                          />
                          <Button
                            type="button"
                            variant="ghost"
                            size="sm"
                            className="absolute right-0 top-0 h-full px-3 py-2 hover:bg-transparent"
                            onClick={() => setShowPassword(!showPassword)}
                          >
                            {showPassword ? (
                              <EyeOff className="h-4 w-4" />
                            ) : (
                              <Eye className="h-4 w-4" />
                            )}
                          </Button>
                        </div>
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
                
                <div className="flex items-center justify-between">
                  <FormField
                    control={emailForm.control}
                    name="rememberMe"
                    render={({ field }) => (
                      <FormItem className="flex flex-row items-center space-x-2 space-y-0">
                        <FormControl>
                          <Checkbox
                            checked={field.value}
                            onCheckedChange={field.onChange}
                          />
                        </FormControl>
                        <FormLabel className="text-sm font-normal">
                          ë¡œê·¸ì¸ ìƒíƒœ ìœ ì§€
                        </FormLabel>
                      </FormItem>
                    )}
                  />
                  
                  <Button variant="link" size="sm" asChild>
                    <Link href="/forgot-password">ë¹„ë°€ë²ˆí˜¸ ì°¾ê¸°</Link>
                  </Button>
                </div>
                
                {error && (
                  <Alert variant="destructive">
                    <AlertCircle className="h-4 w-4" />
                    <AlertDescription>{error.message}</AlertDescription>
                  </Alert>
                )}
                
                <Button type="submit" className="w-full" disabled={isLoading}>
                  {isLoading ? (
                    <>
                      <Loader2 className="w-4 h-4 animate-spin mr-2" />
                      ë¡œê·¸ì¸ ì¤‘...
                    </>
                  ) : (
                    'ë¡œê·¸ì¸'
                  )}
                </Button>
              </form>
            </Form>
          </TabsContent>
          
          <TabsContent value="social" className="space-y-4">
            <div className="space-y-3">
              <Button
                variant="outline"
                className="w-full"
                onClick={() => loginWithProvider('google')}
                disabled={isLoading}
              >
                <svg className="w-4 h-4 mr-2" viewBox="0 0 24 24">
                  {/* Google ë¡œê³  SVG */}
                </svg>
                Googleë¡œ ë¡œê·¸ì¸
              </Button>
              
              <Button
                variant="outline"
                className="w-full"
                onClick={() => loginWithProvider('github')}
                disabled={isLoading}
              >
                <Github className="w-4 h-4 mr-2" />
                GitHubìœ¼ë¡œ ë¡œê·¸ì¸
              </Button>
            </div>
          </TabsContent>
        </Tabs>
        
        <Separator />
        
        <div className="text-center text-sm">
          <span className="text-muted-foreground">ê³„ì •ì´ ì—†ìœ¼ì‹ ê°€ìš”? </span>
          <Button variant="link" size="sm" asChild className="p-0">
            <Link href="/signup">íšŒì›ê°€ì…</Link>
          </Button>
        </div>
      </CardContent>
    </Card>
  )
}
```

### **4. ê¶Œí•œ ê¸°ë°˜ ì ‘ê·¼ ì œì–´**

**HOC ë° Hook ê¸°ë°˜ ê¶Œí•œ ê´€ë¦¬**
```typescript
// src/lib/auth/permissions.ts
// ê¶Œí•œ ì²´í¬ HOC
export function withPermission<P extends object>(
  WrappedComponent: React.ComponentType<P>,
  requiredPermissions: Permission | Permission[],
  options?: {
    fallback?: React.ComponentType
    redirectTo?: string
    requireAll?: boolean
  }
) {
  return function PermissionWrapper(props: P) {
    const { hasPermission, hasAnyPermission, isAuthenticated } = useAuthStore()
    const router = useRouter()
    
    const permissions = Array.isArray(requiredPermissions) 
      ? requiredPermissions 
      : [requiredPermissions]
    
    const hasAccess = options?.requireAll 
      ? permissions.every(p => hasPermission(p))
      : hasAnyPermission(permissions)
    
    // ì¸ì¦ë˜ì§€ ì•Šì€ ê²½ìš°
    if (!isAuthenticated) {
      if (options?.redirectTo) {
        router.push(options.redirectTo)
        return null
      }
      return options?.fallback ? <options.fallback /> : <AccessDenied />
    }
    
    // ê¶Œí•œì´ ì—†ëŠ” ê²½ìš°
    if (!hasAccess) {
      return options?.fallback ? <options.fallback /> : <AccessDenied />
    }
    
    return <WrappedComponent {...props} />
  }
}

// ê¶Œí•œ ì²´í¬ Hook
export function usePermissions() {
  const { hasPermission, hasAnyPermission, hasRole, user } = useAuthStore()
  
  return {
    hasPermission,
    hasAnyPermission,
    hasRole,
    user,
    
    // í¸ì˜ ë©”ì†Œë“œë“¤
    canCreateSchedule: () => hasPermission('schedule:create'),
    canEditProject: () => hasPermission('project:update'),
    canManageUsers: () => hasPermission('user:manage'),
    isAdmin: () => hasRole('admin'),
    isManager: () => hasRole('manager') || hasRole('admin'),
    
    // ì¡°ê±´ë¶€ ë Œë”ë§ì„ ìœ„í•œ ì»´í¬ë„ŒíŠ¸
    PermissionGate: ({ 
      permission, 
      role, 
      children, 
      fallback 
    }: PermissionGateProps) => {
      let hasAccess = true
      
      if (permission) {
        hasAccess = Array.isArray(permission)
          ? hasAnyPermission(permission)
          : hasPermission(permission)
      }
      
      if (role && hasAccess) {
        hasAccess = hasRole(role)
      }
      
      return hasAccess ? <>{children}</> : <>{fallback}</>
    }
  }
}

// ê¶Œí•œ ê¸°ë°˜ ë¼ìš°íŒ…
export function ProtectedRoute({ 
  children, 
  permissions, 
  roles,
  redirectTo = '/login'
}: ProtectedRouteProps) {
  const { isAuthenticated, hasPermission, hasAnyPermission, hasRole } = useAuthStore()
  const router = useRouter()
  
  useEffect(() => {
    if (!isAuthenticated) {
      router.push(redirectTo)
      return
    }
    
    let hasAccess = true
    
    if (permissions) {
      hasAccess = Array.isArray(permissions)
        ? hasAnyPermission(permissions)
        : hasPermission(permissions)
    }
    
    if (roles && hasAccess) {
      hasAccess = Array.isArray(roles)
        ? roles.some(role => hasRole(role))
        : hasRole(roles)
    }
    
    if (!hasAccess) {
      router.push('/unauthorized')
    }
  }, [isAuthenticated, permissions, roles, redirectTo])
  
  if (!isAuthenticated) {
    return <LoginSkeleton />
  }
  
  return <>{children}</>
}
```

### **5. ë³´ì•ˆ ë¯¸ë“¤ì›¨ì–´ ë° ì¸í„°ì…‰í„°**

**API ìš”ì²­ ë³´ì•ˆ ì²˜ë¦¬**
```typescript
// src/lib/auth/securityMiddleware.ts
export class SecurityInterceptor {
  // Apollo Link ë³´ì•ˆ ì¸í„°ì…‰í„°
  static createAuthLink(): ApolloLink {
    const authLink = setContext(async (_, { headers }) => {
      let token = TokenManager.getAccessToken()
      
      // í† í°ì´ ë§Œë£Œë˜ì—ˆê±°ë‚˜ ê³§ ë§Œë£Œë  ê²½ìš° ê°±ì‹ 
      if (!TokenManager.isTokenValid()) {
        try {
          const refreshed = await TokenManager.refreshToken()
          token = refreshed.accessToken
        } catch (error) {
          // ê°±ì‹  ì‹¤íŒ¨ ì‹œ ë¡œê·¸ì•„ì›ƒ
          useAuthStore.getState().logout()
          throw new Error('Authentication failed')
        }
      }
      
      return {
        headers: {
          ...headers,
          authorization: token ? `Bearer ${token}` : "",
          'X-Requested-With': 'XMLHttpRequest', // CSRF ë°©ì§€
        }
      }
    })
    
    const errorLink = onError(({ graphQLErrors, networkError, operation, forward }) => {
      if (graphQLErrors) {
        graphQLErrors.forEach(({ message, locations, path, extensions }) => {
          if (extensions?.code === 'UNAUTHENTICATED') {
            // ì¸ì¦ ì˜¤ë¥˜ ì‹œ ë¡œê·¸ì•„ì›ƒ
            useAuthStore.getState().logout()
          } else if (extensions?.code === 'FORBIDDEN') {
            // ê¶Œí•œ ì˜¤ë¥˜ ì²˜ë¦¬
            showToast('error', 'ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤')
          }
        })
      }
      
      if (networkError) {
        if (networkError.statusCode === 401) {
          useAuthStore.getState().logout()
        }
      }
    })
    
    return ApolloLink.from([errorLink, authLink])
  }
  
  // XSS ë°©ì§€ í—¬í¼
  static sanitizeInput(input: string): string {
    return DOMPurify.sanitize(input, {
      ALLOWED_TAGS: [], // ëª¨ë“  HTML íƒœê·¸ ì œê±°
      ALLOWED_ATTR: []
    })
  }
  
  // CSRF í† í° ê´€ë¦¬
  static async getCSRFToken(): Promise<string> {
    try {
      const response = await fetch('/api/csrf-token', {
        credentials: 'include'
      })
      const { token } = await response.json()
      return token
    } catch (error) {
      throw new Error('Failed to get CSRF token')
    }
  }
  
  // ë¯¼ê° ì •ë³´ ë¡œê¹… í•„í„°
  static filterSensitiveData(data: any): any {
    const sensitiveFields = ['password', 'token', 'secret', 'key', 'authorization']
    
    if (typeof data !== 'object' || data === null) {
      return data
    }
    
    const filtered = { ...data }
    
    Object.keys(filtered).forEach(key => {
      if (sensitiveFields.some(field => key.toLowerCase().includes(field))) {
        filtered[key] = '[REDACTED]'
      } else if (typeof filtered[key] === 'object') {
        filtered[key] = this.filterSensitiveData(filtered[key])
      }
    })
    
    return filtered
  }
}

// ë³´ì•ˆ í—¤ë” ì„¤ì • (Next.js middleware)
// middleware.ts
export function middleware(request: NextRequest) {
  const response = NextResponse.next()
  
  // ë³´ì•ˆ í—¤ë” ì„¤ì •
  response.headers.set('X-DNS-Prefetch-Control', 'off')
  response.headers.set('X-Frame-Options', 'SAMEORIGIN')
  response.headers.set('X-Content-Type-Options', 'nosniff')
  response.headers.set('Referrer-Policy', 'strict-origin-when-cross-origin')
  response.headers.set('Permissions-Policy', 'camera=(), microphone=(), geolocation=()')
  
  // CSP í—¤ë”
  const cspHeader = [
    "default-src 'self'",
    "script-src 'self' 'unsafe-eval' 'unsafe-inline'", // Next.jsì— í•„ìš”
    "style-src 'self' 'unsafe-inline'",
    "img-src 'self' blob: data:",
    "font-src 'self'",
    "object-src 'none'",
    "base-uri 'self'",
    "form-action 'self'",
    "frame-ancestors 'none'",
    "upgrade-insecure-requests"
  ].join('; ')
  
  response.headers.set('Content-Security-Policy', cspHeader)
  
  return response
}

export const config = {
  matcher: [
    '/((?!api|_next/static|_next/image|favicon.ico).*)',
  ],
}
```

---

## ğŸ¨ **ì‚¬ìš©ì ê²½í—˜ (UX) ì„¤ê³„**

### **1. 2ë‹¨ê³„ ì¸ì¦ ì„¤ì •**

**ì‚¬ìš©ì ì¹œí™”ì  2FA ì„¤ì • í”Œë¡œìš°**
```typescript
// src/components/auth/TwoFactorSetup.tsx
const TwoFactorSetup = () => {
  const [step, setStep] = useState<'intro' | 'scan' | 'verify' | 'backup' | 'complete'>('intro')
  const [qrCode, setQRCode] = useState<string>('')
  const [secret, setSecret] = useState<string>('')
  const [backupCodes, setBackupCodes] = useState<string[]>([])
  
  const form = useForm<{ verificationCode: string }>()
  
  const handleSetupStart = async () => {
    try {
      const response = await fetch('/api/auth/2fa/setup', {
        method: 'POST',
        credentials: 'include'
      })
      const data = await response.json()
      
      setQRCode(data.qrCode)
      setSecret(data.secret)
      setStep('scan')
    } catch (error) {
      showToast('error', '2FA ì„¤ì •ì„ ì‹œì‘í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤')
    }
  }
  
  const handleVerification = async (data: { verificationCode: string }) => {
    try {
      const response = await fetch('/api/auth/2fa/verify-setup', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ code: data.verificationCode })
      })
      
      if (!response.ok) {
        throw new Error('ì¸ì¦ ì½”ë“œê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤')
      }
      
      const result = await response.json()
      setBackupCodes(result.backupCodes)
      setStep('backup')
    } catch (error) {
      form.setError('verificationCode', { 
        message: error.message || 'ì¸ì¦ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤' 
      })
    }
  }
  
  return (
    <Card className="w-full max-w-lg mx-auto">
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <Shield className="w-5 h-5" />
          2ë‹¨ê³„ ì¸ì¦ ì„¤ì •
        </CardTitle>
      </CardHeader>
      
      <CardContent>
        {step === 'intro' && (
          <div className="space-y-4 text-center">
            <div className="bg-blue-50 p-4 rounded-lg">
              <Shield className="w-12 h-12 text-blue-600 mx-auto mb-3" />
              <h3 className="font-semibold mb-2">ê³„ì • ë³´ì•ˆ ê°•í™”</h3>
              <p className="text-sm text-muted-foreground">
                2ë‹¨ê³„ ì¸ì¦ìœ¼ë¡œ ê³„ì •ì„ ë”ìš± ì•ˆì „í•˜ê²Œ ë³´í˜¸í•˜ì„¸ìš”
              </p>
            </div>
            
            <div className="space-y-3 text-left">
              <div className="flex items-start gap-3">
                <Smartphone className="w-5 h-5 text-blue-600 mt-0.5" />
                <div>
                  <h4 className="font-medium text-sm">ì¸ì¦ ì•± ì„¤ì¹˜</h4>
                  <p className="text-xs text-muted-foreground">
                    Google Authenticator, Authy ë“±ì˜ ì•±ì´ í•„ìš”í•©ë‹ˆë‹¤
                  </p>
                </div>
              </div>
              
              <div className="flex items-start gap-3">
                <Key className="w-5 h-5 text-blue-600 mt-0.5" />
                <div>
                  <h4 className="font-medium text-sm">ë°±ì—… ì½”ë“œ ì œê³µ</h4>
                  <p className="text-xs text-muted-foreground">
                    íœ´ëŒ€í°ì„ ë¶„ì‹¤í•œ ê²½ìš°ë¥¼ ëŒ€ë¹„í•œ ë³µêµ¬ ì½”ë“œë¥¼ ì œê³µí•©ë‹ˆë‹¤
                  </p>
                </div>
              </div>
            </div>
            
            <Button onClick={handleSetupStart} className="w-full">
              ì„¤ì • ì‹œì‘í•˜ê¸°
            </Button>
          </div>
        )}
        
        {step === 'scan' && (
          <div className="space-y-4">
            <div className="text-center">
              <h3 className="font-semibold mb-2">QR ì½”ë“œ ìŠ¤ìº”</h3>
              <p className="text-sm text-muted-foreground mb-4">
                ì¸ì¦ ì•±ìœ¼ë¡œ ì•„ë˜ QR ì½”ë“œë¥¼ ìŠ¤ìº”í•˜ì„¸ìš”
              </p>
              
              <div className="bg-white p-4 rounded-lg border-2 border-dashed border-gray-300 inline-block">
                <QRCodeSVG value={qrCode} size={200} />
              </div>
            </div>
            
            <Collapsible>
              <CollapsibleTrigger className="flex items-center gap-2 text-sm text-muted-foreground">
                <Key className="w-4 h-4" />
                ìˆ˜ë™ìœ¼ë¡œ í‚¤ ì…ë ¥í•˜ê¸°
                <ChevronRight className="w-4 h-4" />
              </CollapsibleTrigger>
              <CollapsibleContent className="mt-2">
                <div className="bg-muted p-3 rounded font-mono text-sm break-all">
                  {secret}
                </div>
                <Button 
                  variant="outline" 
                  size="sm" 
                  onClick={() => navigator.clipboard.writeText(secret)}
                  className="mt-2"
                >
                  ë³µì‚¬
                </Button>
              </CollapsibleContent>
            </Collapsible>
            
            <Button onClick={() => setStep('verify')} className="w-full">
              ë‹¤ìŒ ë‹¨ê³„
            </Button>
          </div>
        )}
        
        {step === 'verify' && (
          <Form {...form}>
            <form onSubmit={form.handleSubmit(handleVerification)} className="space-y-4">
              <div className="text-center">
                <h3 className="font-semibold mb-2">ì¸ì¦ ì½”ë“œ í™•ì¸</h3>
                <p className="text-sm text-muted-foreground mb-4">
                  ì•±ì—ì„œ ìƒì„±ëœ 6ìë¦¬ ì½”ë“œë¥¼ ì…ë ¥í•˜ì„¸ìš”
                </p>
              </div>
              
              <FormField
                control={form.control}
                name="verificationCode"
                render={({ field }) => (
                  <FormItem>
                    <FormControl>
                      <InputOTP
                        maxLength={6}
                        value={field.value}
                        onChange={field.onChange}
                        className="justify-center"
                      >
                        {Array.from({ length: 6 }).map((_, index) => (
                          <InputOTPSlot key={index} index={index} />
                        ))}
                      </InputOTP>
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              
              <Button type="submit" className="w-full">
                ì¸ì¦ í™•ì¸
              </Button>
            </form>
          </Form>
        )}
        
        {step === 'backup' && (
          <div className="space-y-4">
            <div className="text-center">
              <h3 className="font-semibold mb-2">ë°±ì—… ì½”ë“œ ì €ì¥</h3>
              <p className="text-sm text-muted-foreground mb-4">
                ì´ ì½”ë“œë“¤ì„ ì•ˆì „í•œ ê³³ì— ë³´ê´€í•˜ì„¸ìš”. íœ´ëŒ€í°ì„ ë¶„ì‹¤í–ˆì„ ë•Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
              </p>
            </div>
            
            <Alert>
              <AlertTriangle className="h-4 w-4" />
              <AlertTitle>ì¤‘ìš”</AlertTitle>
              <AlertDescription>
                ê° ë°±ì—… ì½”ë“œëŠ” í•œ ë²ˆë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì•ˆì „í•œ ê³³ì— ë³´ê´€í•˜ì„¸ìš”.
              </AlertDescription>
            </Alert>
            
            <div className="bg-muted p-4 rounded-lg">
              <div className="grid grid-cols-2 gap-2 font-mono text-sm">
                {backupCodes.map((code, index) => (
                  <div key={index} className="p-2 bg-background rounded border">
                    {code}
                  </div>
                ))}
              </div>
            </div>
            
            <div className="flex gap-2">
              <Button
                variant="outline"
                onClick={() => {
                  const text = backupCodes.join('\n')
                  navigator.clipboard.writeText(text)
                  showToast('success', 'ë°±ì—… ì½”ë“œê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤')
                }}
                className="flex-1"
              >
                <Copy className="w-4 h-4 mr-2" />
                ë³µì‚¬
              </Button>
              
              <Button
                variant="outline"
                onClick={() => {
                  const blob = new Blob([backupCodes.join('\n')], { type: 'text/plain' })
                  const url = URL.createObjectURL(blob)
                  const a = document.createElement('a')
                  a.href = url
                  a.download = 'baro-calendar-backup-codes.txt'
                  a.click()
                  URL.revokeObjectURL(url)
                }}
                className="flex-1"
              >
                <Download className="w-4 h-4 mr-2" />
                ë‹¤ìš´ë¡œë“œ
              </Button>
            </div>
            
            <Button onClick={() => setStep('complete')} className="w-full">
              ì„¤ì • ì™„ë£Œ
            </Button>
          </div>
        )}
        
        {step === 'complete' && (
          <div className="text-center space-y-4">
            <div className="bg-green-50 p-4 rounded-lg">
              <CheckCircle className="w-12 h-12 text-green-600 mx-auto mb-3" />
              <h3 className="font-semibold text-green-800 mb-2">ì„¤ì • ì™„ë£Œ!</h3>
              <p className="text-sm text-green-700">
                2ë‹¨ê³„ ì¸ì¦ì´ ì„±ê³µì ìœ¼ë¡œ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤
              </p>
            </div>
            
            <div className="text-left space-y-2 text-sm text-muted-foreground">
              <p>â€¢ ë‹¤ìŒ ë¡œê·¸ì¸ë¶€í„° ì¸ì¦ ì½”ë“œê°€ ìš”êµ¬ë©ë‹ˆë‹¤</p>
              <p>â€¢ ë°±ì—… ì½”ë“œëŠ” ì•ˆì „í•œ ê³³ì— ë³´ê´€í•´ì£¼ì„¸ìš”</p>
              <p>â€¢ ì–¸ì œë“ ì§€ ì„¤ì •ì—ì„œ ë¹„í™œì„±í™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤</p>
            </div>
            
            <Button onClick={() => window.location.reload()} className="w-full">
              ì™„ë£Œ
            </Button>
          </div>
        )}
      </CardContent>
    </Card>
  )
}
```

---

## ğŸ“Š **ë³´ì•ˆ ëª¨ë‹ˆí„°ë§ ë° ê°ì‚¬**

```typescript
// src/lib/security/auditLogger.ts
export interface SecurityEvent {
  type: 'login' | 'logout' | 'failed_login' | 'permission_denied' | 'data_access' | '2fa_setup'
  userId?: string
  userEmail?: string
  ipAddress: string
  userAgent: string
  timestamp: string
  details: Record<string, any>
  severity: 'low' | 'medium' | 'high' | 'critical'
}

export class SecurityAuditLogger {
  static async logSecurityEvent(event: Omit<SecurityEvent, 'timestamp' | 'ipAddress' | 'userAgent'>) {
    try {
      // í´ë¼ì´ì–¸íŠ¸ ì •ë³´ ìˆ˜ì§‘
      const clientInfo = {
        timestamp: new Date().toISOString(),
        ipAddress: await this.getClientIP(),
        userAgent: navigator.userAgent,
      }
      
      const securityEvent: SecurityEvent = {
        ...event,
        ...clientInfo
      }
      
      // ì„œë²„ë¡œ ì „ì†¡
      await fetch('/api/security/audit', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
        body: JSON.stringify(securityEvent)
      })
      
      // ì¤‘ìš” ì´ë²¤íŠ¸ëŠ” ì‹¤ì‹œê°„ ì•Œë¦¼
      if (event.severity === 'high' || event.severity === 'critical') {
        this.sendRealTimeAlert(securityEvent)
      }
      
    } catch (error) {
      console.error('Failed to log security event:', error)
    }
  }
  
  private static async getClientIP(): Promise<string> {
    try {
      const response = await fetch('/api/client-info')
      const data = await response.json()
      return data.ip || 'unknown'
    } catch {
      return 'unknown'
    }
  }
  
  private static sendRealTimeAlert(event: SecurityEvent) {
    // WebSocket ë˜ëŠ” Server-Sent Eventsë¡œ ì‹¤ì‹œê°„ ì•Œë¦¼
    if (wsManager.isConnected()) {
      wsManager.send({
        type: 'SECURITY_ALERT',
        payload: event
      })
    }
  }
  
  // í¸ì˜ ë©”ì†Œë“œë“¤
  static logSuccessfulLogin(userId: string, userEmail: string) {
    this.logSecurityEvent({
      type: 'login',
      userId,
      userEmail,
      severity: 'low',
      details: { success: true }
    })
  }
  
  static logFailedLogin(email: string, reason: string) {
    this.logSecurityEvent({
      type: 'failed_login',
      userEmail: email,
      severity: 'medium',
      details: { reason, success: false }
    })
  }
  
  static logPermissionDenied(userId: string, resource: string, action: string) {
    this.logSecurityEvent({
      type: 'permission_denied',
      userId,
      severity: 'medium',
      details: { resource, action }
    })
  }
}
```

---

## âœ… **Definition of Done**

### **ê¸°ëŠ¥ ìš”êµ¬ì‚¬í•­**
- [ ] JWT ê¸°ë°˜ ì•¡ì„¸ìŠ¤/ë¦¬í”„ë ˆì‹œ í† í° ìë™ ê´€ë¦¬
- [ ] ì´ë©”ì¼/ë¹„ë°€ë²ˆí˜¸ ë° ì†Œì…œ ë¡œê·¸ì¸ ì§€ì›
- [ ] 2ë‹¨ê³„ ì¸ì¦ (TOTP) ì„¤ì • ë° ê²€ì¦
- [ ] ì—­í•  ê¸°ë°˜ ê¶Œí•œ ê´€ë¦¬ (RBAC)
- [ ] ìë™ í† í° ê°±ì‹  ë° ì„¸ì…˜ ê´€ë¦¬

### **ê¸°ìˆ  ìš”êµ¬ì‚¬í•­**
- [ ] Zustand ê¸°ë°˜ ì¸ì¦ ìƒíƒœ ê´€ë¦¬
- [ ] Apollo Client ì¸ì¦ ì¸í„°ì…‰í„°
- [ ] Next.js ë³´ì•ˆ ë¯¸ë“¤ì›¨ì–´ êµ¬í˜„
- [ ] httpOnly ì¿ í‚¤ + sessionStorage í•˜ì´ë¸Œë¦¬ë“œ í† í° ì €ì¥
- [ ] ë³´ì•ˆ í—¤ë” (CSP, HSTS, X-Frame-Options) ì ìš©

### **ë³´ì•ˆ ìš”êµ¬ì‚¬í•­**
- [ ] XSS ë°©ì§€ (DOMPurify, CSP í—¤ë”)
- [ ] CSRF ë°©ì§€ (í† í° ê²€ì¦, SameSite ì¿ í‚¤)
- [ ] ë¸Œë£¨íŠ¸ í¬ìŠ¤ ê³µê²© ë°©ì§€ (ë¡œê·¸ì¸ ì‹œë„ ì œí•œ)
- [ ] ë¯¼ê° ì •ë³´ ë¡œê¹… í•„í„°ë§
- [ ] ë³´ì•ˆ ì´ë²¤íŠ¸ ê°ì‚¬ ë¡œê¹…

### **ì ‘ê·¼ì„± ìš”êµ¬ì‚¬í•­**
- [ ] ë¡œê·¸ì¸ í¼ í‚¤ë³´ë“œ ë„¤ë¹„ê²Œì´ì…˜ ì™„ì „ ì§€ì›
- [ ] 2FA ì„¤ì • ê³¼ì • ìŠ¤í¬ë¦° ë¦¬ë” ì§€ì›
- [ ] ì—ëŸ¬ ë©”ì‹œì§€ ì ì ˆí•œ ARIA ë ˆì´ë¸”
- [ ] ê³ ëŒ€ë¹„ ëª¨ë“œ ì§€ì›

### **ì„±ëŠ¥ ìš”êµ¬ì‚¬í•­**
- [ ] í† í° ê²€ì¦ ì‘ë‹µì‹œê°„ 100ms ì´í•˜
- [ ] ìë™ ê°±ì‹  ë°±ê·¸ë¼ìš´ë“œ ì²˜ë¦¬
- [ ] ë³´ì•ˆ ì´ë²¤íŠ¸ ë¡œê¹… ë¹„ë™ê¸° ì²˜ë¦¬
- [ ] ë©”ëª¨ë¦¬ ë‚´ ê¶Œí•œ ìºì‹± ìµœì í™”

### **í…ŒìŠ¤íŠ¸ ìš”êµ¬ì‚¬í•­**
- [ ] ì¸ì¦ í”Œë¡œìš° ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
- [ ] ê¶Œí•œ ì²´í¬ ë¡œì§ í…ŒìŠ¤íŠ¸
- [ ] í† í° ê°±ì‹  ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸
- [ ] ë³´ì•ˆ ê³µê²© ì‹œë‚˜ë¦¬ì˜¤ E2E í…ŒìŠ¤íŠ¸

---

## ğŸ“š **ê´€ë ¨ ë¬¸ì„œ ì°¸ì¡°**

- [10. ë³´ì•ˆ ëª¨ë²” ì‚¬ë¡€](../ui-architecture/10-security-best-practices.md)
- [11. ì ‘ê·¼ì„± êµ¬í˜„](../ui-architecture/11-accessibility-implementation.md)
- [20. í‘œì¤€ ì—ëŸ¬ í¬ë§· ë° í•¸ë“¤ë§](../ui-architecture/20-error-handling.md)
- [21. Observability ë° ëª¨ë‹ˆí„°ë§](../ui-architecture/21-observability-monitoring.md)

---

**ì´ ìŠ¤í† ë¦¬ëŠ” ë°”ë¡œìº˜ë¦°ë”ì˜ ì™„ì „í•œ ì¸ì¦ ë° ë³´ì•ˆ ì‹œìŠ¤í…œì„ êµ¬í˜„í•˜ê¸° ìœ„í•œ ì¢…í•©ì ì¸ ê¸°ìˆ  ê°€ì´ë“œì…ë‹ˆë‹¤. JWT ê¸°ë°˜ì˜ í˜„ëŒ€ì ì¸ ì¸ì¦ ë°©ì‹ê³¼ ë‹¤ì–‘í•œ ë³´ì•ˆ ìœ„í˜‘ì— ëŒ€í•œ ë°©ì–´ ë©”ì»¤ë‹ˆì¦˜ì„ í†µí•©í•˜ì—¬ ì•ˆì „í•˜ê³  ì‚¬ìš©ì ì¹œí™”ì ì¸ ì‹œìŠ¤í…œì„ êµ¬ì¶•í•©ë‹ˆë‹¤.**