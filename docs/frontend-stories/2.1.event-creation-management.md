# Story 2.2: ì´ë²¤íŠ¸ ìƒì„± ë° ê´€ë¦¬ ì‹œìŠ¤í…œ

## Status
Ready for Development

## Priority & Dependencies
- **Priority**: P0 (Critical)
- **Story Points**: 5
- **Dependencies**: [1.2, 1.4]
- **Blocked By**: None

## Success Metrics
- **Business KPI**: 
  - ì´ë²¤íŠ¸ ìƒì„± ì‹œê°„ 30ì´ˆ ì´ë‚´
  - ì‚¬ìš©ì ë§Œì¡±ë„ 4.2/5.0 ì´ìƒ
  - ì´ë²¤íŠ¸ ìƒì„± ì™„ë£Œìœ¨ 95% ì´ìƒ
- **Technical KPI**:
  - ì–‘ì‹ ì‘ë‹µ ì‹œê°„ 100ms ì´ë‚´
  - ìœ íš¨ì„± ê²€ì‚¬ ì§€ì—° 50ms ì´ë‚´
  - ì¶©ëŒ ê°ì§€ ì„±ê³µë¥  100%
- **Definition of Success**: ì§ê´€ì  ì´ë²¤íŠ¸ ìƒì„±, ì‹¤ì‹œê°„ ì¶©ëŒ ë°©ì§€

## Risks & Mitigations
- **Technical Risks**: 
  - Risk: ë³µì¡í•œ ë°˜ë³µ ì„¤ì • UI ì‚¬ìš©ì„±
  - Impact: Medium
  - Mitigation: ì‚¬ìš©ì í…ŒìŠ¤íŠ¸, ë‹¨ê³„ë³„ ìœ„ìë“œ
- **Schedule Risks**:
  - Risk: ì°¸ì„ì ê´€ë¦¬ ë¡œì§ ë³µì¡ë„
  - Impact: Low
  - Mitigation: MVP ë²„ì „ ë¨¼ì € êµ¬í˜„

---

## ğŸ¯ **ìŠ¤í† ë¦¬ ëª©í‘œ**

**ì™„ì „í•œ ì´ë²¤íŠ¸ ìƒì„± ë° ê´€ë¦¬ ì‹œìŠ¤í…œ êµ¬í˜„**
- ì§ê´€ì ì¸ ì´ë²¤íŠ¸ ìƒì„± UI/UX
- ë°˜ë³µ ì¼ì • ë° ì•Œë¦¼ ì„¤ì •
- ì°¸ì„ì ê´€ë¦¬ ë° ê³µìœ  ê¸°ëŠ¥
- ì²¨ë¶€íŒŒì¼ ë° ìœ„ì¹˜ ì •ë³´ ì§€ì›
- ì‹¤ì‹œê°„ ìœ íš¨ì„± ê²€ì‚¬ ë° ì¶©ëŒ ê°ì§€

---

## Story
**As a** ì‚¬ìš©ì,
**I want** ì§ê´€ì ì¸ ì¸í„°í˜ì´ìŠ¤ë¡œ ì´ë²¤íŠ¸ë¥¼ ìƒì„±í•˜ê³  ë°˜ë³µ, ì•Œë¦¼, ì°¸ì„ìë¥¼ ê´€ë¦¬í•  ìˆ˜ ìˆëŠ” ì‹œìŠ¤í…œì„ ì‚¬ìš©í•˜ì—¬,
**so that** íš¨ìœ¨ì ìœ¼ë¡œ ì¼ì •ì„ ìƒì„±í•˜ê³  íŒ€ì›ë“¤ê³¼ í˜‘ì—…í•  ìˆ˜ ìˆë‹¤.

## Acceptance Criteria
1. í´ë¦­ í•œ ë²ˆìœ¼ë¡œ ë¹ ë¥´ê²Œ ì´ë²¤íŠ¸ë¥¼ ìƒì„±í•˜ê³  ì‹¶ë‹¤
2. ë°˜ë³µ ì¼ì •ì„ ìœ ì—°í•˜ê²Œ ì„¤ì •í•˜ê³  ê´€ë¦¬í•˜ê³  ì‹¶ë‹¤
3. ì°¸ì„ìë¥¼ ì´ˆëŒ€í•˜ê³  ì‘ë‹µ ìƒíƒœë¥¼ í™•ì¸í•˜ê³  ì‹¶ë‹¤
4. ì¼ì • ì¶©ëŒì„ ë¯¸ë¦¬ í™•ì¸í•˜ê³  ìµœì ì˜ ì‹œê°„ì„ ì°¾ê³  ì‹¶ë‹¤
5. ì²¨ë¶€íŒŒì¼ê³¼ ìœ„ì¹˜ ì •ë³´ë¥¼ í¬í•¨í•˜ì—¬ ìƒì„¸í•œ ì¼ì •ì„ ë§Œë“¤ê³  ì‹¶ë‹¤

---

## ğŸ—ï¸ **ê¸°ìˆ ì  êµ¬í˜„ ìš”êµ¬ì‚¬í•­**

### **1. ì´ë²¤íŠ¸ ìƒì„± ëª¨ë‹¬ ì»´í¬ë„ŒíŠ¸**

**Event Creation Modal**
```typescript
// src/components/event/EventCreationModal.tsx
import React, { useState, useCallback, useMemo } from 'react'
import { useForm, Controller } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'
import { format, addHours, startOfDay } from 'date-fns'
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from '@/components/ui/dialog'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Textarea } from '@/components/ui/textarea'
import { Label } from '@/components/ui/label'
import { Switch } from '@/components/ui/switch'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import { CalendarIcon, Clock, MapPin, Paperclip, Users, Bell, Repeat } from 'lucide-react'
import { useProjectStore } from '@/stores/projectStore'
import { useCalendarStore } from '@/stores/calendarStore'
import { DateTimePicker } from './DateTimePicker'
import { RecurrenceSettings } from './RecurrenceSettings'
import { AttendeeSelector } from './AttendeeSelector'
import { LocationPicker } from './LocationPicker'
import { FileUploader } from './FileUploader'

// Event validation schema
const eventSchema = z.object({
  title: z.string().min(1, 'Title is required').max(100),
  description: z.string().optional(),
  startDate: z.date(),
  endDate: z.date(),
  allDay: z.boolean(),
  projectId: z.string().min(1, 'Project is required'),
  location: z.string().optional(),
  attendees: z.array(z.string()).optional(),
  reminder: z.number().optional(),
  recurrence: z.object({
    enabled: z.boolean(),
    pattern: z.enum(['daily', 'weekly', 'monthly', 'yearly']).optional(),
    interval: z.number().optional(),
    endDate: z.date().optional(),
    daysOfWeek: z.array(z.number()).optional(),
    dayOfMonth: z.number().optional(),
  }).optional(),
  attachments: z.array(z.object({
    id: z.string(),
    name: z.string(),
    url: z.string(),
    size: z.number(),
    type: z.string(),
  })).optional(),
}).refine((data) => data.endDate >= data.startDate, {
  message: "End date must be after start date",
  path: ["endDate"],
})

interface EventCreationModalProps {
  isOpen: boolean
  onClose: () => void
  initialDate?: Date
  initialProject?: string
  onSubmit: (data: EventFormData) => Promise<void>
}

export type EventFormData = z.infer<typeof eventSchema>

export const EventCreationModal: React.FC<EventCreationModalProps> = ({
  isOpen,
  onClose,
  initialDate,
  initialProject,
  onSubmit
}) => {
  const [isSubmitting, setIsSubmitting] = useState(false)
  const [showAdvanced, setShowAdvanced] = useState(false)
  const projects = useProjectStore((state) => state.projects)
  const { checkConflicts } = useCalendarStore()
  
  const {
    register,
    control,
    handleSubmit,
    watch,
    setValue,
    formState: { errors },
    reset
  } = useForm<EventFormData>({
    resolver: zodResolver(eventSchema),
    defaultValues: {
      title: '',
      description: '',
      startDate: initialDate || new Date(),
      endDate: initialDate ? addHours(initialDate, 1) : addHours(new Date(), 1),
      allDay: false,
      projectId: initialProject || '',
      location: '',
      attendees: [],
      reminder: 15,
      recurrence: {
        enabled: false,
        pattern: 'weekly',
        interval: 1,
      },
      attachments: []
    }
  })
  
  const watchAllDay = watch('allDay')
  const watchStartDate = watch('startDate')
  const watchEndDate = watch('endDate')
  const watchRecurrence = watch('recurrence')
  
  // Check for conflicts
  const conflicts = useMemo(() => {
    if (!watchStartDate || !watchEndDate) return []
    return checkConflicts(watchStartDate, watchEndDate)
  }, [watchStartDate, watchEndDate, checkConflicts])
  
  // Handle all-day toggle
  React.useEffect(() => {
    if (watchAllDay) {
      setValue('startDate', startOfDay(watchStartDate))
      setValue('endDate', startOfDay(watchEndDate))
    }
  }, [watchAllDay, watchStartDate, watchEndDate, setValue])
  
  const handleFormSubmit = async (data: EventFormData) => {
    setIsSubmitting(true)
    try {
      await onSubmit(data)
      reset()
      onClose()
    } catch (error) {
      console.error('Failed to create event:', error)
    } finally {
      setIsSubmitting(false)
    }
  }
  
  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-2xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>Create New Event</DialogTitle>
        </DialogHeader>
        
        <form onSubmit={handleSubmit(handleFormSubmit)} className="space-y-4">
          {/* Title */}
          <div className="space-y-2">
            <Label htmlFor="title">Title *</Label>
            <Input
              id="title"
              {...register('title')}
              placeholder="Enter event title"
              className={errors.title ? 'border-destructive' : ''}
            />
            {errors.title && (
              <p className="text-sm text-destructive">{errors.title.message}</p>
            )}
          </div>
          
          {/* Project Selection */}
          <div className="space-y-2">
            <Label htmlFor="project">Project *</Label>
            <Controller
              name="projectId"
              control={control}
              render={({ field }) => (
                <Select value={field.value} onValueChange={field.onChange}>
                  <SelectTrigger className={errors.projectId ? 'border-destructive' : ''}>
                    <SelectValue placeholder="Select a project" />
                  </SelectTrigger>
                  <SelectContent>
                    {projects.map((project) => (
                      <SelectItem key={project.id} value={project.id}>
                        <div className="flex items-center gap-2">
                          <div
                            className="w-3 h-3 rounded-full"
                            style={{ backgroundColor: project.color }}
                          />
                          {project.name}
                        </div>
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              )}
            />
            {errors.projectId && (
              <p className="text-sm text-destructive">{errors.projectId.message}</p>
            )}
          </div>
          
          {/* Date and Time */}
          <div className="grid grid-cols-2 gap-4">
            <div className="space-y-2">
              <Label>Start Date & Time</Label>
              <Controller
                name="startDate"
                control={control}
                render={({ field }) => (
                  <DateTimePicker
                    date={field.value}
                    onDateChange={field.onChange}
                    showTime={!watchAllDay}
                  />
                )}
              />
            </div>
            
            <div className="space-y-2">
              <Label>End Date & Time</Label>
              <Controller
                name="endDate"
                control={control}
                render={({ field }) => (
                  <DateTimePicker
                    date={field.value}
                    onDateChange={field.onChange}
                    showTime={!watchAllDay}
                    minDate={watchStartDate}
                  />
                )}
              />
              {errors.endDate && (
                <p className="text-sm text-destructive">{errors.endDate.message}</p>
              )}
            </div>
          </div>
          
          {/* All Day Toggle */}
          <div className="flex items-center justify-between">
            <Label htmlFor="allDay">All Day Event</Label>
            <Controller
              name="allDay"
              control={control}
              render={({ field }) => (
                <Switch
                  id="allDay"
                  checked={field.value}
                  onCheckedChange={field.onChange}
                />
              )}
            />
          </div>
          
          {/* Conflict Warning */}
          {conflicts.length > 0 && (
            <div className="bg-warning/10 border border-warning rounded-md p-3">
              <p className="text-sm font-medium text-warning">
                Schedule Conflict Detected
              </p>
              <ul className="text-sm text-muted-foreground mt-1">
                {conflicts.map((conflict) => (
                  <li key={conflict.id}>
                    â€¢ {conflict.title} ({format(conflict.startDate, 'h:mm a')})
                  </li>
                ))}
              </ul>
            </div>
          )}
          
          {/* Description */}
          <div className="space-y-2">
            <Label htmlFor="description">Description</Label>
            <Textarea
              id="description"
              {...register('description')}
              placeholder="Add event description..."
              rows={3}
            />
          </div>
          
          {/* Advanced Options Toggle */}
          <Button
            type="button"
            variant="ghost"
            onClick={() => setShowAdvanced(!showAdvanced)}
            className="w-full justify-between"
          >
            <span>Advanced Options</span>
            <ChevronDown className={cn(
              "h-4 w-4 transition-transform",
              showAdvanced && "rotate-180"
            )} />
          </Button>
          
          {/* Advanced Options */}
          {showAdvanced && (
            <div className="space-y-4 border-t pt-4">
              {/* Location */}
              <div className="space-y-2">
                <Label htmlFor="location">
                  <MapPin className="w-4 h-4 inline mr-1" />
                  Location
                </Label>
                <Controller
                  name="location"
                  control={control}
                  render={({ field }) => (
                    <LocationPicker
                      value={field.value}
                      onChange={field.onChange}
                    />
                  )}
                />
              </div>
              
              {/* Attendees */}
              <div className="space-y-2">
                <Label>
                  <Users className="w-4 h-4 inline mr-1" />
                  Attendees
                </Label>
                <Controller
                  name="attendees"
                  control={control}
                  render={({ field }) => (
                    <AttendeeSelector
                      value={field.value || []}
                      onChange={field.onChange}
                    />
                  )}
                />
              </div>
              
              {/* Reminder */}
              <div className="space-y-2">
                <Label htmlFor="reminder">
                  <Bell className="w-4 h-4 inline mr-1" />
                  Reminder
                </Label>
                <Controller
                  name="reminder"
                  control={control}
                  render={({ field }) => (
                    <Select value={field.value?.toString()} onValueChange={(v) => field.onChange(parseInt(v))}>
                      <SelectTrigger>
                        <SelectValue />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="0">No reminder</SelectItem>
                        <SelectItem value="5">5 minutes before</SelectItem>
                        <SelectItem value="15">15 minutes before</SelectItem>
                        <SelectItem value="30">30 minutes before</SelectItem>
                        <SelectItem value="60">1 hour before</SelectItem>
                        <SelectItem value="1440">1 day before</SelectItem>
                      </SelectContent>
                    </Select>
                  )}
                />
              </div>
              
              {/* Recurrence */}
              <div className="space-y-2">
                <Label>
                  <Repeat className="w-4 h-4 inline mr-1" />
                  Recurrence
                </Label>
                <Controller
                  name="recurrence"
                  control={control}
                  render={({ field }) => (
                    <RecurrenceSettings
                      value={field.value}
                      onChange={field.onChange}
                    />
                  )}
                />
              </div>
              
              {/* Attachments */}
              <div className="space-y-2">
                <Label>
                  <Paperclip className="w-4 h-4 inline mr-1" />
                  Attachments
                </Label>
                <Controller
                  name="attachments"
                  control={control}
                  render={({ field }) => (
                    <FileUploader
                      value={field.value || []}
                      onChange={field.onChange}
                      maxFiles={5}
                      maxSize={10 * 1024 * 1024} // 10MB
                    />
                  )}
                />
              </div>
            </div>
          )}
        </form>
        
        <DialogFooter>
          <Button variant="outline" onClick={onClose} disabled={isSubmitting}>
            Cancel
          </Button>
          <Button
            onClick={handleSubmit(handleFormSubmit)}
            disabled={isSubmitting}
          >
            {isSubmitting ? 'Creating...' : 'Create Event'}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  )
}
```

### **2. ë°˜ë³µ ì¼ì • ì„¤ì • ì»´í¬ë„ŒíŠ¸**

**Recurrence Settings Component**
```typescript
// src/components/event/RecurrenceSettings.tsx
import React from 'react'
import { Switch } from '@/components/ui/switch'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { ToggleGroup, ToggleGroupItem } from '@/components/ui/toggle-group'
import { DatePicker } from '@/components/ui/date-picker'

interface RecurrenceSettingsProps {
  value: {
    enabled: boolean
    pattern?: 'daily' | 'weekly' | 'monthly' | 'yearly'
    interval?: number
    endDate?: Date
    daysOfWeek?: number[]
    dayOfMonth?: number
  }
  onChange: (value: any) => void
}

export const RecurrenceSettings: React.FC<RecurrenceSettingsProps> = ({
  value,
  onChange
}) => {
  const handleChange = (key: string, val: any) => {
    onChange({ ...value, [key]: val })
  }
  
  const weekDays = ['S', 'M', 'T', 'W', 'T', 'F', 'S']
  
  return (
    <div className="space-y-4">
      {/* Enable Recurrence */}
      <div className="flex items-center justify-between">
        <Label>Enable Recurrence</Label>
        <Switch
          checked={value.enabled}
          onCheckedChange={(checked) => handleChange('enabled', checked)}
        />
      </div>
      
      {value.enabled && (
        <>
          {/* Pattern */}
          <div className="grid grid-cols-2 gap-4">
            <div className="space-y-2">
              <Label>Repeat</Label>
              <Select
                value={value.pattern}
                onValueChange={(v) => handleChange('pattern', v)}
              >
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="daily">Daily</SelectItem>
                  <SelectItem value="weekly">Weekly</SelectItem>
                  <SelectItem value="monthly">Monthly</SelectItem>
                  <SelectItem value="yearly">Yearly</SelectItem>
                </SelectContent>
              </Select>
            </div>
            
            <div className="space-y-2">
              <Label>Every</Label>
              <div className="flex items-center gap-2">
                <Input
                  type="number"
                  min="1"
                  max="100"
                  value={value.interval || 1}
                  onChange={(e) => handleChange('interval', parseInt(e.target.value))}
                  className="w-20"
                />
                <span className="text-sm text-muted-foreground">
                  {value.pattern === 'daily' && 'day(s)'}
                  {value.pattern === 'weekly' && 'week(s)'}
                  {value.pattern === 'monthly' && 'month(s)'}
                  {value.pattern === 'yearly' && 'year(s)'}
                </span>
              </div>
            </div>
          </div>
          
          {/* Weekly Options */}
          {value.pattern === 'weekly' && (
            <div className="space-y-2">
              <Label>Repeat on</Label>
              <ToggleGroup
                type="multiple"
                value={value.daysOfWeek?.map(String) || []}
                onValueChange={(days) => 
                  handleChange('daysOfWeek', days.map(Number))
                }
                className="justify-start"
              >
                {weekDays.map((day, index) => (
                  <ToggleGroupItem
                    key={index}
                    value={String(index)}
                    className="w-10 h-10"
                  >
                    {day}
                  </ToggleGroupItem>
                ))}
              </ToggleGroup>
            </div>
          )}
          
          {/* Monthly Options */}
          {value.pattern === 'monthly' && (
            <div className="space-y-2">
              <Label>Repeat on day</Label>
              <Input
                type="number"
                min="1"
                max="31"
                value={value.dayOfMonth || 1}
                onChange={(e) => handleChange('dayOfMonth', parseInt(e.target.value))}
                className="w-20"
              />
            </div>
          )}
          
          {/* End Date */}
          <div className="space-y-2">
            <Label>End Date (Optional)</Label>
            <DatePicker
              date={value.endDate}
              onDateChange={(date) => handleChange('endDate', date)}
            />
          </div>
        </>
      )}
    </div>
  )
}
```

### **3. ë¹ ë¥¸ ì´ë²¤íŠ¸ ìƒì„± (Quick Add)**

**Quick Event Creation**
```typescript
// src/components/event/QuickEventAdd.tsx
import React, { useState } from 'react'
import { useForm } from 'react-hook-form'
import { Input } from '@/components/ui/input'
import { Button } from '@/components/ui/button'
import { Plus } from 'lucide-react'
import { useCalendarStore } from '@/stores/calendarStore'
import { parseEventString } from '@/lib/event-parser'

interface QuickEventAddProps {
  defaultDate?: Date
  defaultProject?: string
}

export const QuickEventAdd: React.FC<QuickEventAddProps> = ({
  defaultDate,
  defaultProject
}) => {
  const [isExpanded, setIsExpanded] = useState(false)
  const { addEvent } = useCalendarStore()
  const { register, handleSubmit, reset } = useForm()
  
  const handleQuickAdd = (data: { quickInput: string }) => {
    // Parse natural language input
    // Examples:
    // "Meeting tomorrow at 2pm"
    // "Lunch with John next Friday 12:30"
    // "Project deadline on Dec 15"
    const parsedEvent = parseEventString(data.quickInput, {
      defaultDate,
      defaultProject
    })
    
    if (parsedEvent) {
      addEvent(parsedEvent)
      reset()
      setIsExpanded(false)
    }
  }
  
  if (!isExpanded) {
    return (
      <Button
        onClick={() => setIsExpanded(true)}
        size="sm"
        className="w-full"
      >
        <Plus className="w-4 h-4 mr-1" />
        Quick Add Event
      </Button>
    )
  }
  
  return (
    <form onSubmit={handleSubmit(handleQuickAdd)} className="flex gap-2">
      <Input
        {...register('quickInput')}
        placeholder="e.g., Meeting tomorrow at 2pm"
        autoFocus
        onBlur={() => {
          setTimeout(() => setIsExpanded(false), 200)
        }}
      />
      <Button type="submit" size="sm">
        Add
      </Button>
    </form>
  )
}

// Natural language parser utility
// src/lib/event-parser.ts
import { parse, isValid } from 'date-fns'
import { CalendarEvent } from '@/types/calendar'

export const parseEventString = (
  input: string,
  options: {
    defaultDate?: Date
    defaultProject?: string
  }
): Partial<CalendarEvent> | null => {
  // Time patterns
  const timePatterns = [
    /(\d{1,2}):(\d{2})\s*(am|pm)?/i,
    /(\d{1,2})\s*(am|pm)/i,
  ]
  
  // Date keywords
  const dateKeywords = {
    today: new Date(),
    tomorrow: new Date(Date.now() + 24 * 60 * 60 * 1000),
    'next week': new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
  }
  
  // Extract title (everything before time/date indicators)
  let title = input
  let startDate = options.defaultDate || new Date()
  let endDate = new Date(startDate.getTime() + 60 * 60 * 1000) // 1 hour default
  
  // Parse time
  for (const pattern of timePatterns) {
    const match = input.match(pattern)
    if (match) {
      const [fullMatch, hours, minutes, period] = match
      let hour = parseInt(hours)
      const min = parseInt(minutes || '0')
      
      if (period) {
        if (period.toLowerCase() === 'pm' && hour < 12) hour += 12
        if (period.toLowerCase() === 'am' && hour === 12) hour = 0
      }
      
      startDate.setHours(hour, min, 0, 0)
      endDate = new Date(startDate.getTime() + 60 * 60 * 1000)
      title = title.replace(fullMatch, '').trim()
    }
  }
  
  // Parse date keywords
  for (const [keyword, date] of Object.entries(dateKeywords)) {
    if (input.toLowerCase().includes(keyword)) {
      startDate = new Date(date)
      startDate.setHours(
        options.defaultDate?.getHours() || 9,
        options.defaultDate?.getMinutes() || 0
      )
      endDate = new Date(startDate.getTime() + 60 * 60 * 1000)
      title = title.replace(new RegExp(keyword, 'gi'), '').trim()
    }
  }
  
  // Clean up title
  title = title
    .replace(/\s+at\s+/gi, ' ')
    .replace(/\s+on\s+/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim()
  
  if (!title) return null
  
  return {
    id: crypto.randomUUID(),
    title,
    startDate,
    endDate,
    allDay: false,
    projectId: options.defaultProject || '',
    status: 'confirmed'
  }
}
```

### **4. ì´ë²¤íŠ¸ í¸ì§‘ ë° ì‚­ì œ**

**Event Edit/Delete Component**
```typescript
// src/components/event/EventEditModal.tsx
import React, { useState } from 'react'
import { CalendarEvent } from '@/types/calendar'
import { EventCreationModal } from './EventCreationModal'
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog'
import { useCalendarStore } from '@/stores/calendarStore'

interface EventEditModalProps {
  event: CalendarEvent
  isOpen: boolean
  onClose: () => void
}

export const EventEditModal: React.FC<EventEditModalProps> = ({
  event,
  isOpen,
  onClose
}) => {
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false)
  const { updateEvent, deleteEvent } = useCalendarStore()
  
  const handleUpdate = async (data: EventFormData) => {
    await updateEvent(event.id, data)
    onClose()
  }
  
  const handleDelete = () => {
    deleteEvent(event.id)
    setShowDeleteConfirm(false)
    onClose()
  }
  
  const handleDeleteSeries = () => {
    // Delete all events in the recurring series
    if (event.recurrenceId) {
      deleteRecurringSeries(event.recurrenceId)
    }
    setShowDeleteConfirm(false)
    onClose()
  }
  
  return (
    <>
      <EventCreationModal
        isOpen={isOpen && !showDeleteConfirm}
        onClose={onClose}
        initialData={event}
        onSubmit={handleUpdate}
        mode="edit"
        onDelete={() => setShowDeleteConfirm(true)}
      />
      
      {/* Delete Confirmation */}
      <AlertDialog open={showDeleteConfirm} onOpenChange={setShowDeleteConfirm}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Delete Event</AlertDialogTitle>
            <AlertDialogDescription>
              {event.recurrenceRule ? (
                <>
                  This is a recurring event. What would you like to delete?
                  <div className="mt-4 space-y-2">
                    <Button
                      variant="outline"
                      className="w-full justify-start"
                      onClick={handleDelete}
                    >
                      Only this event
                    </Button>
                    <Button
                      variant="outline"
                      className="w-full justify-start"
                      onClick={handleDeleteSeries}
                    >
                      All events in the series
                    </Button>
                  </div>
                </>
              ) : (
                'Are you sure you want to delete this event? This action cannot be undone.'
              )}
            </AlertDialogDescription>
          </AlertDialogHeader>
          {!event.recurrenceRule && (
            <AlertDialogFooter>
              <AlertDialogCancel>Cancel</AlertDialogCancel>
              <AlertDialogAction onClick={handleDelete}>
                Delete
              </AlertDialogAction>
            </AlertDialogFooter>
          )}
        </AlertDialogContent>
      </AlertDialog>
    </>
  )
}
```

### **5. ì´ë²¤íŠ¸ ì¶©ëŒ ê°ì§€ ë° ì œì•ˆ**

**Conflict Detection and Suggestions**
```typescript
// src/lib/conflict-detection.ts
import { CalendarEvent } from '@/types/calendar'
import { areIntervalsOverlapping, addMinutes } from 'date-fns'

export interface ConflictInfo {
  event: CalendarEvent
  overlapDuration: number
  severity: 'low' | 'medium' | 'high'
}

export interface TimeSlotSuggestion {
  startDate: Date
  endDate: Date
  score: number
  reason: string
}

export class ConflictDetector {
  private events: CalendarEvent[]
  
  constructor(events: CalendarEvent[]) {
    this.events = events
  }
  
  // Check for conflicts with a time range
  checkConflicts(
    startDate: Date,
    endDate: Date,
    excludeEventId?: string
  ): ConflictInfo[] {
    const conflicts: ConflictInfo[] = []
    
    for (const event of this.events) {
      if (excludeEventId && event.id === excludeEventId) continue
      
      const hasOverlap = areIntervalsOverlapping(
        { start: startDate, end: endDate },
        { start: event.startDate, end: event.endDate }
      )
      
      if (hasOverlap) {
        const overlapStart = Math.max(
          startDate.getTime(),
          event.startDate.getTime()
        )
        const overlapEnd = Math.min(
          endDate.getTime(),
          event.endDate.getTime()
        )
        const overlapDuration = (overlapEnd - overlapStart) / (1000 * 60) // minutes
        
        conflicts.push({
          event,
          overlapDuration,
          severity: this.calculateSeverity(event, overlapDuration)
        })
      }
    }
    
    return conflicts
  }
  
  // Calculate conflict severity
  private calculateSeverity(
    event: CalendarEvent,
    overlapMinutes: number
  ): 'low' | 'medium' | 'high' {
    // High severity: Important events or full overlap
    if (event.attendees && event.attendees.length > 5) return 'high'
    if (overlapMinutes > 30) return 'high'
    
    // Medium severity: Partial overlap with regular events
    if (overlapMinutes > 15) return 'medium'
    if (event.attendees && event.attendees.length > 0) return 'medium'
    
    // Low severity: Minor overlaps
    return 'low'
  }
  
  // Suggest alternative time slots
  suggestAlternativeSlots(
    duration: number, // in minutes
    preferredStart: Date,
    constraints: {
      workingHours?: { start: number; end: number }
      maxDaysAhead?: number
      preferMorning?: boolean
      avoidWeekends?: boolean
    } = {}
  ): TimeSlotSuggestion[] {
    const suggestions: TimeSlotSuggestion[] = []
    const {
      workingHours = { start: 9, end: 17 },
      maxDaysAhead = 7,
      preferMorning = false,
      avoidWeekends = true
    } = constraints
    
    const endDate = new Date(preferredStart)
    endDate.setDate(endDate.getDate() + maxDaysAhead)
    
    let currentDate = new Date(preferredStart)
    currentDate.setHours(workingHours.start, 0, 0, 0)
    
    while (currentDate < endDate && suggestions.length < 5) {
      // Skip weekends if needed
      if (avoidWeekends && (currentDate.getDay() === 0 || currentDate.getDay() === 6)) {
        currentDate.setDate(currentDate.getDate() + 1)
        currentDate.setHours(workingHours.start, 0, 0, 0)
        continue
      }
      
      const slotEnd = addMinutes(currentDate, duration)
      
      // Check if within working hours
      if (slotEnd.getHours() <= workingHours.end) {
        const conflicts = this.checkConflicts(currentDate, slotEnd)
        
        if (conflicts.length === 0) {
          const score = this.calculateSlotScore(
            currentDate,
            preferredStart,
            preferMorning
          )
          
          suggestions.push({
            startDate: new Date(currentDate),
            endDate: slotEnd,
            score,
            reason: this.getSlotReason(currentDate, preferredStart)
          })
        }
      }
      
      // Move to next slot
      currentDate = addMinutes(currentDate, 30)
      
      // Move to next day if past working hours
      if (currentDate.getHours() >= workingHours.end) {
        currentDate.setDate(currentDate.getDate() + 1)
        currentDate.setHours(workingHours.start, 0, 0, 0)
      }
    }
    
    // Sort by score (higher is better)
    return suggestions.sort((a, b) => b.score - a.score)
  }
  
  private calculateSlotScore(
    slotDate: Date,
    preferredDate: Date,
    preferMorning: boolean
  ): number {
    let score = 100
    
    // Prefer slots closer to the preferred time
    const hoursDiff = Math.abs(
      (slotDate.getTime() - preferredDate.getTime()) / (1000 * 60 * 60)
    )
    score -= hoursDiff * 2
    
    // Morning preference
    if (preferMorning && slotDate.getHours() < 12) {
      score += 10
    }
    
    // Avoid early morning and late afternoon
    if (slotDate.getHours() < 8 || slotDate.getHours() > 16) {
      score -= 20
    }
    
    return Math.max(0, score)
  }
  
  private getSlotReason(slotDate: Date, preferredDate: Date): string {
    const daysDiff = Math.floor(
      (slotDate.getTime() - preferredDate.getTime()) / (1000 * 60 * 60 * 24)
    )
    
    if (daysDiff === 0) {
      return 'Available later today'
    } else if (daysDiff === 1) {
      return 'Available tomorrow'
    } else {
      return `Available in ${daysDiff} days`
    }
  }
}
```

---

## ğŸ¨ **ì‚¬ìš©ì ê²½í—˜ (UX) ì„¤ê³„**

### **1. ë“œë˜ê·¸ ìƒì„± ì¸í„°ë™ì…˜**

```typescript
// src/hooks/useDragToCreate.ts
import { useState, useRef } from 'react'
import { useCalendarStore } from '@/stores/calendarStore'

export const useDragToCreate = () => {
  const [isDragging, setIsDragging] = useState(false)
  const [dragStart, setDragStart] = useState<Date | null>(null)
  const [dragEnd, setDragEnd] = useState<Date | null>(null)
  const dragRef = useRef<HTMLDivElement>(null)
  
  const handleMouseDown = (date: Date) => {
    setIsDragging(true)
    setDragStart(date)
    setDragEnd(date)
  }
  
  const handleMouseMove = (date: Date) => {
    if (isDragging && dragStart) {
      setDragEnd(date)
    }
  }
  
  const handleMouseUp = () => {
    if (isDragging && dragStart && dragEnd) {
      // Open event creation modal with pre-filled dates
      const startDate = dragStart < dragEnd ? dragStart : dragEnd
      const endDate = dragStart < dragEnd ? dragEnd : dragStart
      
      // Trigger event creation
      useCalendarStore.getState().setCreatingEvent({
        startDate,
        endDate
      })
    }
    
    setIsDragging(false)
    setDragStart(null)
    setDragEnd(null)
  }
  
  return {
    isDragging,
    dragStart,
    dragEnd,
    handleMouseDown,
    handleMouseMove,
    handleMouseUp
  }
}
```

### **2. ì¸ë¼ì¸ í¸ì§‘**

```typescript
// src/components/event/InlineEventEdit.tsx
import React, { useState } from 'react'
import { Input } from '@/components/ui/input'
import { CalendarEvent } from '@/types/calendar'
import { useCalendarStore } from '@/stores/calendarStore'

interface InlineEventEditProps {
  event: CalendarEvent
  onComplete: () => void
}

export const InlineEventEdit: React.FC<InlineEventEditProps> = ({
  event,
  onComplete
}) => {
  const [title, setTitle] = useState(event.title)
  const { updateEvent } = useCalendarStore()
  
  const handleSave = () => {
    if (title.trim() && title !== event.title) {
      updateEvent(event.id, { title: title.trim() })
    }
    onComplete()
  }
  
  return (
    <Input
      value={title}
      onChange={(e) => setTitle(e.target.value)}
      onBlur={handleSave}
      onKeyDown={(e) => {
        if (e.key === 'Enter') handleSave()
        if (e.key === 'Escape') onComplete()
      }}
      className="h-auto py-0.5 px-1 text-xs"
      autoFocus
    />
  )
}
```

---

## ğŸ“Š **ì„±ëŠ¥ ìµœì í™”**

### **1. ì´ë²¤íŠ¸ ë°ì´í„° ì •ê·œí™”**

```typescript
// src/lib/event-normalizer.ts
export interface NormalizedEventData {
  events: Record<string, CalendarEvent>
  eventsByDate: Record<string, string[]>
  eventsByProject: Record<string, string[]>
  recurringEvents: Record<string, string[]>
}

export class EventNormalizer {
  static normalize(events: CalendarEvent[]): NormalizedEventData {
    const normalized: NormalizedEventData = {
      events: {},
      eventsByDate: {},
      eventsByProject: {},
      recurringEvents: {}
    }
    
    for (const event of events) {
      // Store event by ID
      normalized.events[event.id] = event
      
      // Index by date
      const dateKey = format(event.startDate, 'yyyy-MM-dd')
      if (!normalized.eventsByDate[dateKey]) {
        normalized.eventsByDate[dateKey] = []
      }
      normalized.eventsByDate[dateKey].push(event.id)
      
      // Index by project
      if (!normalized.eventsByProject[event.projectId]) {
        normalized.eventsByProject[event.projectId] = []
      }
      normalized.eventsByProject[event.projectId].push(event.id)
      
      // Index recurring events
      if (event.recurrenceRule) {
        const seriesId = event.recurrenceId || event.id
        if (!normalized.recurringEvents[seriesId]) {
          normalized.recurringEvents[seriesId] = []
        }
        normalized.recurringEvents[seriesId].push(event.id)
      }
    }
    
    return normalized
  }
  
  static denormalize(normalized: NormalizedEventData): CalendarEvent[] {
    return Object.values(normalized.events)
  }
}
```

---

## âœ… **Definition of Done**

### **ê¸°ëŠ¥ ìš”êµ¬ì‚¬í•­**
- [ ] ëª¨ë‹¬ ë° ì¸ë¼ì¸ ì´ë²¤íŠ¸ ìƒì„±
- [ ] ìì—°ì–´ ì…ë ¥ ì§€ì› (Quick Add)
- [ ] ë°˜ë³µ ì¼ì • ì„¤ì • ë° ê´€ë¦¬
- [ ] ì²¨ë¶€íŒŒì¼ ë° ìœ„ì¹˜ ì •ë³´ ì§€ì›
- [ ] ì¶©ëŒ ê°ì§€ ë° ëŒ€ì•ˆ ì œì‹œ

### **ê¸°ìˆ  ìš”êµ¬ì‚¬í•­**
- [ ] React Hook Form ê¸°ë°˜ í¼ ê´€ë¦¬
- [ ] Zod ìŠ¤í‚¤ë§ˆ ìœ íš¨ì„± ê²€ì‚¬
- [ ] ì´ë²¤íŠ¸ ë°ì´í„° ì •ê·œí™”
- [ ] ë‚™ê´€ì  ì—…ë°ì´íŠ¸ êµ¬í˜„

### **UX ìš”êµ¬ì‚¬í•­**
- [ ] ë“œë˜ê·¸ë¡œ ì´ë²¤íŠ¸ ìƒì„±
- [ ] ì¸ë¼ì¸ í¸ì§‘ ì§€ì›
- [ ] ì‹¤ì‹œê°„ ìœ íš¨ì„± ê²€ì‚¬
- [ ] ì§ê´€ì ì¸ ë°˜ë³µ ì„¤ì • UI

### **í…ŒìŠ¤íŠ¸ ìš”êµ¬ì‚¬í•­**
- [ ] í¼ ìœ íš¨ì„± ê²€ì‚¬ í…ŒìŠ¤íŠ¸
- [ ] ì¶©ëŒ ê°ì§€ ì•Œê³ ë¦¬ì¦˜ í…ŒìŠ¤íŠ¸
- [ ] ìì—°ì–´ íŒŒì‹± í…ŒìŠ¤íŠ¸
- [ ] E2E ì´ë²¤íŠ¸ ìƒì„± í”Œë¡œìš°

---

## ğŸ“š **ê´€ë ¨ ë¬¸ì„œ ì°¸ì¡°**

- [04. State Management](../ui-architecture/04-state-management.md)
- [20. Error Handling](../ui-architecture/20-error-handling.md)
- [Story 2.1 Basic Calendar View](./2.1.basic-calendar-view.md)

---

**ì´ ìŠ¤í† ë¦¬ëŠ” ë°”ë¡œìº˜ë¦°ë”ì˜ ì´ë²¤íŠ¸ ìƒì„± ë° ê´€ë¦¬ ì‹œìŠ¤í…œ êµ¬í˜„ì„ ìœ„í•œ ì¢…í•©ì ì¸ ê¸°ìˆ  ê°€ì´ë“œì…ë‹ˆë‹¤. ì§ê´€ì ì¸ UIì™€ ê°•ë ¥í•œ ê¸°ëŠ¥ì„ í†µí•´ ì‚¬ìš©ìê°€ íš¨ìœ¨ì ìœ¼ë¡œ ì¼ì •ì„ ê´€ë¦¬í•  ìˆ˜ ìˆë„ë¡ ì§€ì›í•©ë‹ˆë‹¤.**