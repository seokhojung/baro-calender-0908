# Story 2.1: 이벤트 생성 및 관리 시스템

## Status
Ready for Development

## Priority & Dependencies
- **Priority**: P0 (Critical)
- **Story Points**: 5
- **Dependencies**: [1.2, 1.4]
- **Blocked By**: None
- **Backend Dependencies**: 
  - Events Creation API (`POST /v1/events`) - ✅ Implemented
  - Events Update API (`PATCH /v1/events/:id`) - ✅ Implemented
  - Events Delete API (`DELETE /v1/events/:id`) - ✅ Implemented
  - Projects API for dropdown (`GET /v1/projects`) - ✅ Available

## Success Metrics
- **Business KPI**: 
  - 이벤트 생성 시간 30초 이내
  - 사용자 만족도 4.2/5.0 이상
  - 이벤트 생성 완료율 95% 이상
- **Technical KPI**:
  - 양식 응답 시간 100ms 이내
  - 유효성 검사 지연 50ms 이내
  - 충돌 감지 성공률 100%
- **Definition of Success**: 직관적 이벤트 생성, 실시간 충돌 방지

## Risks & Mitigations
- **Technical Risks**: 
  - Risk: 복잡한 반복 설정 UI 사용성
  - Impact: Medium
  - Mitigation: 사용자 테스트, 단계별 위자드
- **Schedule Risks**:
  - Risk: 참석자 관리 로직 복잡도
  - Impact: Low
  - Mitigation: MVP 버전 먼저 구현

---

## 🎯 **스토리 목표**

**완전한 이벤트 생성 및 관리 시스템 구현**
- 직관적인 이벤트 생성 UI/UX
- 반복 일정 및 알림 설정
- 참석자 관리 및 공유 기능
- 첨부파일 및 위치 정보 지원
- 실시간 유효성 검사 및 충돌 감지

---

## Story
**As a** 사용자,
**I want** 직관적인 인터페이스로 이벤트를 생성하고 반복, 알림, 참석자를 관리할 수 있는 시스템을 사용하여,
**so that** 효율적으로 일정을 생성하고 팀원들과 협업할 수 있다.

## Acceptance Criteria
1. 클릭 한 번으로 빠르게 이벤트를 생성하고 싶다
2. 반복 일정을 유연하게 설정하고 관리하고 싶다
3. 참석자를 초대하고 응답 상태를 확인하고 싶다
4. 일정 충돌을 미리 확인하고 최적의 시간을 찾고 싶다
5. 첨부파일과 위치 정보를 포함하여 상세한 일정을 만들고 싶다

---

## 🏗️ **기술적 구현 요구사항**

### **1. 이벤트 생성 모달 컴포넌트**

**Event Creation Modal**
```typescript
// src/components/event/EventCreationModal.tsx
import React, { useState, useCallback, useMemo } from 'react'
import { useForm, Controller } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'
import { format, addHours, startOfDay } from 'date-fns'
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from '@/components/ui/dialog'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Textarea } from '@/components/ui/textarea'
import { Label } from '@/components/ui/label'
import { Switch } from '@/components/ui/switch'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import { CalendarIcon, Clock, MapPin, Paperclip, Users, Bell, Repeat } from 'lucide-react'
import { useProjectStore } from '@/stores/projectStore'
import { useCalendarStore } from '@/stores/calendarStore'
import { DateTimePicker } from './DateTimePicker'
import { RecurrenceSettings } from './RecurrenceSettings'
import { AttendeeSelector } from './AttendeeSelector'
import { LocationPicker } from './LocationPicker'
import { FileUploader } from './FileUploader'

// Event validation schema
const eventSchema = z.object({
  title: z.string().min(1, 'Title is required').max(100),
  description: z.string().optional(),
  startDate: z.date(),
  endDate: z.date(),
  allDay: z.boolean(),
  projectId: z.string().min(1, 'Project is required'),
  location: z.string().optional(),
  attendees: z.array(z.string()).optional(),
  reminder: z.number().optional(),
  recurrence: z.object({
    enabled: z.boolean(),
    pattern: z.enum(['daily', 'weekly', 'monthly', 'yearly']).optional(),
    interval: z.number().optional(),
    endDate: z.date().optional(),
    daysOfWeek: z.array(z.number()).optional(),
    dayOfMonth: z.number().optional(),
  }).optional(),
  attachments: z.array(z.object({
    id: z.string(),
    name: z.string(),
    url: z.string(),
    size: z.number(),
    type: z.string(),
  })).optional(),
}).refine((data) => data.endDate >= data.startDate, {
  message: "End date must be after start date",
  path: ["endDate"],
})

interface EventCreationModalProps {
  isOpen: boolean
  onClose: () => void
  initialDate?: Date
  initialProject?: string
  onSubmit: (data: EventFormData) => Promise<void>
}

export type EventFormData = z.infer<typeof eventSchema>

export const EventCreationModal: React.FC<EventCreationModalProps> = ({
  isOpen,
  onClose,
  initialDate,
  initialProject,
  onSubmit
}) => {
  const [isSubmitting, setIsSubmitting] = useState(false)
  const [showAdvanced, setShowAdvanced] = useState(false)
  const projects = useProjectStore((state) => state.projects)
  const { checkConflicts } = useCalendarStore()
  
  const {
    register,
    control,
    handleSubmit,
    watch,
    setValue,
    formState: { errors },
    reset
  } = useForm<EventFormData>({
    resolver: zodResolver(eventSchema),
    defaultValues: {
      title: '',
      description: '',
      startDate: initialDate || new Date(),
      endDate: initialDate ? addHours(initialDate, 1) : addHours(new Date(), 1),
      allDay: false,
      projectId: initialProject || '',
      location: '',
      attendees: [],
      reminder: 15,
      recurrence: {
        enabled: false,
        pattern: 'weekly',
        interval: 1,
      },
      attachments: []
    }
  })
  
  const watchAllDay = watch('allDay')
  const watchStartDate = watch('startDate')
  const watchEndDate = watch('endDate')
  const watchRecurrence = watch('recurrence')
  
  // Check for conflicts
  const conflicts = useMemo(() => {
    if (!watchStartDate || !watchEndDate) return []
    return checkConflicts(watchStartDate, watchEndDate)
  }, [watchStartDate, watchEndDate, checkConflicts])
  
  // Handle all-day toggle
  React.useEffect(() => {
    if (watchAllDay) {
      setValue('startDate', startOfDay(watchStartDate))
      setValue('endDate', startOfDay(watchEndDate))
    }
  }, [watchAllDay, watchStartDate, watchEndDate, setValue])
  
  const handleFormSubmit = async (data: EventFormData) => {
    setIsSubmitting(true)
    try {
      await onSubmit(data)
      reset()
      onClose()
    } catch (error) {
      console.error('Failed to create event:', error)
    } finally {
      setIsSubmitting(false)
    }
  }
  
  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-2xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>Create New Event</DialogTitle>
        </DialogHeader>
        
        <form onSubmit={handleSubmit(handleFormSubmit)} className="space-y-4">
          {/* Title */}
          <div className="space-y-2">
            <Label htmlFor="title">Title *</Label>
            <Input
              id="title"
              {...register('title')}
              placeholder="Enter event title"
              className={errors.title ? 'border-destructive' : ''}
            />
            {errors.title && (
              <p className="text-sm text-destructive">{errors.title.message}</p>
            )}
          </div>
          
          {/* Project Selection */}
          <div className="space-y-2">
            <Label htmlFor="project">Project *</Label>
            <Controller
              name="projectId"
              control={control}
              render={({ field }) => (
                <Select value={field.value} onValueChange={field.onChange}>
                  <SelectTrigger className={errors.projectId ? 'border-destructive' : ''}>
                    <SelectValue placeholder="Select a project" />
                  </SelectTrigger>
                  <SelectContent>
                    {projects.map((project) => (
                      <SelectItem key={project.id} value={project.id}>
                        <div className="flex items-center gap-2">
                          <div
                            className="w-3 h-3 rounded-full"
                            style={{ backgroundColor: project.color }}
                          />
                          {project.name}
                        </div>
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              )}
            />
            {errors.projectId && (
              <p className="text-sm text-destructive">{errors.projectId.message}</p>
            )}
          </div>
          
          {/* Date and Time */}
          <div className="grid grid-cols-2 gap-4">
            <div className="space-y-2">
              <Label>Start Date & Time</Label>
              <Controller
                name="startDate"
                control={control}
                render={({ field }) => (
                  <DateTimePicker
                    date={field.value}
                    onDateChange={field.onChange}
                    showTime={!watchAllDay}
                  />
                )}
              />
            </div>
            
            <div className="space-y-2">
              <Label>End Date & Time</Label>
              <Controller
                name="endDate"
                control={control}
                render={({ field }) => (
                  <DateTimePicker
                    date={field.value}
                    onDateChange={field.onChange}
                    showTime={!watchAllDay}
                    minDate={watchStartDate}
                  />
                )}
              />
              {errors.endDate && (
                <p className="text-sm text-destructive">{errors.endDate.message}</p>
              )}
            </div>
          </div>
          
          {/* All Day Toggle */}
          <div className="flex items-center justify-between">
            <Label htmlFor="allDay">All Day Event</Label>
            <Controller
              name="allDay"
              control={control}
              render={({ field }) => (
                <Switch
                  id="allDay"
                  checked={field.value}
                  onCheckedChange={field.onChange}
                />
              )}
            />
          </div>
          
          {/* Conflict Warning */}
          {conflicts.length > 0 && (
            <div className="bg-warning/10 border border-warning rounded-md p-3">
              <p className="text-sm font-medium text-warning">
                Schedule Conflict Detected
              </p>
              <ul className="text-sm text-muted-foreground mt-1">
                {conflicts.map((conflict) => (
                  <li key={conflict.id}>
                    • {conflict.title} ({format(conflict.startDate, 'h:mm a')})
                  </li>
                ))}
              </ul>
            </div>
          )}
          
          {/* Description */}
          <div className="space-y-2">
            <Label htmlFor="description">Description</Label>
            <Textarea
              id="description"
              {...register('description')}
              placeholder="Add event description..."
              rows={3}
            />
          </div>
          
          {/* Advanced Options Toggle */}
          <Button
            type="button"
            variant="ghost"
            onClick={() => setShowAdvanced(!showAdvanced)}
            className="w-full justify-between"
          >
            <span>Advanced Options</span>
            <ChevronDown className={cn(
              "h-4 w-4 transition-transform",
              showAdvanced && "rotate-180"
            )} />
          </Button>
          
          {/* Advanced Options */}
          {showAdvanced && (
            <div className="space-y-4 border-t pt-4">
              {/* Location */}
              <div className="space-y-2">
                <Label htmlFor="location">
                  <MapPin className="w-4 h-4 inline mr-1" />
                  Location
                </Label>
                <Controller
                  name="location"
                  control={control}
                  render={({ field }) => (
                    <LocationPicker
                      value={field.value}
                      onChange={field.onChange}
                    />
                  )}
                />
              </div>
              
              {/* Attendees */}
              <div className="space-y-2">
                <Label>
                  <Users className="w-4 h-4 inline mr-1" />
                  Attendees
                </Label>
                <Controller
                  name="attendees"
                  control={control}
                  render={({ field }) => (
                    <AttendeeSelector
                      value={field.value || []}
                      onChange={field.onChange}
                    />
                  )}
                />
              </div>
              
              {/* Reminder */}
              <div className="space-y-2">
                <Label htmlFor="reminder">
                  <Bell className="w-4 h-4 inline mr-1" />
                  Reminder
                </Label>
                <Controller
                  name="reminder"
                  control={control}
                  render={({ field }) => (
                    <Select value={field.value?.toString()} onValueChange={(v) => field.onChange(parseInt(v))}>
                      <SelectTrigger>
                        <SelectValue />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="0">No reminder</SelectItem>
                        <SelectItem value="5">5 minutes before</SelectItem>
                        <SelectItem value="15">15 minutes before</SelectItem>
                        <SelectItem value="30">30 minutes before</SelectItem>
                        <SelectItem value="60">1 hour before</SelectItem>
                        <SelectItem value="1440">1 day before</SelectItem>
                      </SelectContent>
                    </Select>
                  )}
                />
              </div>
              
              {/* Recurrence */}
              <div className="space-y-2">
                <Label>
                  <Repeat className="w-4 h-4 inline mr-1" />
                  Recurrence
                </Label>
                <Controller
                  name="recurrence"
                  control={control}
                  render={({ field }) => (
                    <RecurrenceSettings
                      value={field.value}
                      onChange={field.onChange}
                    />
                  )}
                />
              </div>
              
              {/* Attachments */}
              <div className="space-y-2">
                <Label>
                  <Paperclip className="w-4 h-4 inline mr-1" />
                  Attachments
                </Label>
                <Controller
                  name="attachments"
                  control={control}
                  render={({ field }) => (
                    <FileUploader
                      value={field.value || []}
                      onChange={field.onChange}
                      maxFiles={5}
                      maxSize={10 * 1024 * 1024} // 10MB
                    />
                  )}
                />
              </div>
            </div>
          )}
        </form>
        
        <DialogFooter>
          <Button variant="outline" onClick={onClose} disabled={isSubmitting}>
            Cancel
          </Button>
          <Button
            onClick={handleSubmit(handleFormSubmit)}
            disabled={isSubmitting}
          >
            {isSubmitting ? 'Creating...' : 'Create Event'}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  )
}
```

### **2. 반복 일정 설정 컴포넌트**

**Recurrence Settings Component**
```typescript
// src/components/event/RecurrenceSettings.tsx
import React from 'react'
import { Switch } from '@/components/ui/switch'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { ToggleGroup, ToggleGroupItem } from '@/components/ui/toggle-group'
import { DatePicker } from '@/components/ui/date-picker'

interface RecurrenceSettingsProps {
  value: {
    enabled: boolean
    pattern?: 'daily' | 'weekly' | 'monthly' | 'yearly'
    interval?: number
    endDate?: Date
    daysOfWeek?: number[]
    dayOfMonth?: number
  }
  onChange: (value: any) => void
}

export const RecurrenceSettings: React.FC<RecurrenceSettingsProps> = ({
  value,
  onChange
}) => {
  const handleChange = (key: string, val: any) => {
    onChange({ ...value, [key]: val })
  }
  
  const weekDays = ['S', 'M', 'T', 'W', 'T', 'F', 'S']
  
  return (
    <div className="space-y-4">
      {/* Enable Recurrence */}
      <div className="flex items-center justify-between">
        <Label>Enable Recurrence</Label>
        <Switch
          checked={value.enabled}
          onCheckedChange={(checked) => handleChange('enabled', checked)}
        />
      </div>
      
      {value.enabled && (
        <>
          {/* Pattern */}
          <div className="grid grid-cols-2 gap-4">
            <div className="space-y-2">
              <Label>Repeat</Label>
              <Select
                value={value.pattern}
                onValueChange={(v) => handleChange('pattern', v)}
              >
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="daily">Daily</SelectItem>
                  <SelectItem value="weekly">Weekly</SelectItem>
                  <SelectItem value="monthly">Monthly</SelectItem>
                  <SelectItem value="yearly">Yearly</SelectItem>
                </SelectContent>
              </Select>
            </div>
            
            <div className="space-y-2">
              <Label>Every</Label>
              <div className="flex items-center gap-2">
                <Input
                  type="number"
                  min="1"
                  max="100"
                  value={value.interval || 1}
                  onChange={(e) => handleChange('interval', parseInt(e.target.value))}
                  className="w-20"
                />
                <span className="text-sm text-muted-foreground">
                  {value.pattern === 'daily' && 'day(s)'}
                  {value.pattern === 'weekly' && 'week(s)'}
                  {value.pattern === 'monthly' && 'month(s)'}
                  {value.pattern === 'yearly' && 'year(s)'}
                </span>
              </div>
            </div>
          </div>
          
          {/* Weekly Options */}
          {value.pattern === 'weekly' && (
            <div className="space-y-2">
              <Label>Repeat on</Label>
              <ToggleGroup
                type="multiple"
                value={value.daysOfWeek?.map(String) || []}
                onValueChange={(days) => 
                  handleChange('daysOfWeek', days.map(Number))
                }
                className="justify-start"
              >
                {weekDays.map((day, index) => (
                  <ToggleGroupItem
                    key={index}
                    value={String(index)}
                    className="w-10 h-10"
                  >
                    {day}
                  </ToggleGroupItem>
                ))}
              </ToggleGroup>
            </div>
          )}
          
          {/* Monthly Options */}
          {value.pattern === 'monthly' && (
            <div className="space-y-2">
              <Label>Repeat on day</Label>
              <Input
                type="number"
                min="1"
                max="31"
                value={value.dayOfMonth || 1}
                onChange={(e) => handleChange('dayOfMonth', parseInt(e.target.value))}
                className="w-20"
              />
            </div>
          )}
          
          {/* End Date */}
          <div className="space-y-2">
            <Label>End Date (Optional)</Label>
            <DatePicker
              date={value.endDate}
              onDateChange={(date) => handleChange('endDate', date)}
            />
          </div>
        </>
      )}
    </div>
  )
}
```

### **3. 빠른 이벤트 생성 (Quick Add)**

**Quick Event Creation**
```typescript
// src/components/event/QuickEventAdd.tsx
import React, { useState } from 'react'
import { useForm } from 'react-hook-form'
import { Input } from '@/components/ui/input'
import { Button } from '@/components/ui/button'
import { Plus } from 'lucide-react'
import { useCalendarStore } from '@/stores/calendarStore'
import { parseEventString } from '@/lib/event-parser'

interface QuickEventAddProps {
  defaultDate?: Date
  defaultProject?: string
}

export const QuickEventAdd: React.FC<QuickEventAddProps> = ({
  defaultDate,
  defaultProject
}) => {
  const [isExpanded, setIsExpanded] = useState(false)
  const { addEvent } = useCalendarStore()
  const { register, handleSubmit, reset } = useForm()
  
  const handleQuickAdd = (data: { quickInput: string }) => {
    // Parse natural language input
    // Examples:
    // "Meeting tomorrow at 2pm"
    // "Lunch with John next Friday 12:30"
    // "Project deadline on Dec 15"
    const parsedEvent = parseEventString(data.quickInput, {
      defaultDate,
      defaultProject
    })
    
    if (parsedEvent) {
      addEvent(parsedEvent)
      reset()
      setIsExpanded(false)
    }
  }
  
  if (!isExpanded) {
    return (
      <Button
        onClick={() => setIsExpanded(true)}
        size="sm"
        className="w-full"
      >
        <Plus className="w-4 h-4 mr-1" />
        Quick Add Event
      </Button>
    )
  }
  
  return (
    <form onSubmit={handleSubmit(handleQuickAdd)} className="flex gap-2">
      <Input
        {...register('quickInput')}
        placeholder="e.g., Meeting tomorrow at 2pm"
        autoFocus
        onBlur={() => {
          setTimeout(() => setIsExpanded(false), 200)
        }}
      />
      <Button type="submit" size="sm">
        Add
      </Button>
    </form>
  )
}

// Natural language parser utility
// src/lib/event-parser.ts
import { parse, isValid } from 'date-fns'
import { CalendarEvent } from '@/types/calendar'

export const parseEventString = (
  input: string,
  options: {
    defaultDate?: Date
    defaultProject?: string
  }
): Partial<CalendarEvent> | null => {
  // Time patterns
  const timePatterns = [
    /(\d{1,2}):(\d{2})\s*(am|pm)?/i,
    /(\d{1,2})\s*(am|pm)/i,
  ]
  
  // Date keywords
  const dateKeywords = {
    today: new Date(),
    tomorrow: new Date(Date.now() + 24 * 60 * 60 * 1000),
    'next week': new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
  }
  
  // Extract title (everything before time/date indicators)
  let title = input
  let startDate = options.defaultDate || new Date()
  let endDate = new Date(startDate.getTime() + 60 * 60 * 1000) // 1 hour default
  
  // Parse time
  for (const pattern of timePatterns) {
    const match = input.match(pattern)
    if (match) {
      const [fullMatch, hours, minutes, period] = match
      let hour = parseInt(hours)
      const min = parseInt(minutes || '0')
      
      if (period) {
        if (period.toLowerCase() === 'pm' && hour < 12) hour += 12
        if (period.toLowerCase() === 'am' && hour === 12) hour = 0
      }
      
      startDate.setHours(hour, min, 0, 0)
      endDate = new Date(startDate.getTime() + 60 * 60 * 1000)
      title = title.replace(fullMatch, '').trim()
    }
  }
  
  // Parse date keywords
  for (const [keyword, date] of Object.entries(dateKeywords)) {
    if (input.toLowerCase().includes(keyword)) {
      startDate = new Date(date)
      startDate.setHours(
        options.defaultDate?.getHours() || 9,
        options.defaultDate?.getMinutes() || 0
      )
      endDate = new Date(startDate.getTime() + 60 * 60 * 1000)
      title = title.replace(new RegExp(keyword, 'gi'), '').trim()
    }
  }
  
  // Clean up title
  title = title
    .replace(/\s+at\s+/gi, ' ')
    .replace(/\s+on\s+/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim()
  
  if (!title) return null
  
  return {
    id: crypto.randomUUID(),
    title,
    startDate,
    endDate,
    allDay: false,
    projectId: options.defaultProject || '',
    status: 'confirmed'
  }
}
```

### **4. 이벤트 편집 및 삭제**

**Event Edit/Delete Component**
```typescript
// src/components/event/EventEditModal.tsx
import React, { useState } from 'react'
import { CalendarEvent } from '@/types/calendar'
import { EventCreationModal } from './EventCreationModal'
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog'
import { useCalendarStore } from '@/stores/calendarStore'

interface EventEditModalProps {
  event: CalendarEvent
  isOpen: boolean
  onClose: () => void
}

export const EventEditModal: React.FC<EventEditModalProps> = ({
  event,
  isOpen,
  onClose
}) => {
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false)
  const { updateEvent, deleteEvent } = useCalendarStore()
  
  const handleUpdate = async (data: EventFormData) => {
    await updateEvent(event.id, data)
    onClose()
  }
  
  const handleDelete = () => {
    deleteEvent(event.id)
    setShowDeleteConfirm(false)
    onClose()
  }
  
  const handleDeleteSeries = () => {
    // Delete all events in the recurring series
    if (event.recurrenceId) {
      deleteRecurringSeries(event.recurrenceId)
    }
    setShowDeleteConfirm(false)
    onClose()
  }
  
  return (
    <>
      <EventCreationModal
        isOpen={isOpen && !showDeleteConfirm}
        onClose={onClose}
        initialData={event}
        onSubmit={handleUpdate}
        mode="edit"
        onDelete={() => setShowDeleteConfirm(true)}
      />
      
      {/* Delete Confirmation */}
      <AlertDialog open={showDeleteConfirm} onOpenChange={setShowDeleteConfirm}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Delete Event</AlertDialogTitle>
            <AlertDialogDescription>
              {event.recurrenceRule ? (
                <>
                  This is a recurring event. What would you like to delete?
                  <div className="mt-4 space-y-2">
                    <Button
                      variant="outline"
                      className="w-full justify-start"
                      onClick={handleDelete}
                    >
                      Only this event
                    </Button>
                    <Button
                      variant="outline"
                      className="w-full justify-start"
                      onClick={handleDeleteSeries}
                    >
                      All events in the series
                    </Button>
                  </div>
                </>
              ) : (
                'Are you sure you want to delete this event? This action cannot be undone.'
              )}
            </AlertDialogDescription>
          </AlertDialogHeader>
          {!event.recurrenceRule && (
            <AlertDialogFooter>
              <AlertDialogCancel>Cancel</AlertDialogCancel>
              <AlertDialogAction onClick={handleDelete}>
                Delete
              </AlertDialogAction>
            </AlertDialogFooter>
          )}
        </AlertDialogContent>
      </AlertDialog>
    </>
  )
}
```

### **5. 이벤트 충돌 감지 및 제안**

**Conflict Detection and Suggestions**
```typescript
// src/lib/conflict-detection.ts
import { CalendarEvent } from '@/types/calendar'
import { areIntervalsOverlapping, addMinutes } from 'date-fns'

export interface ConflictInfo {
  event: CalendarEvent
  overlapDuration: number
  severity: 'low' | 'medium' | 'high'
}

export interface TimeSlotSuggestion {
  startDate: Date
  endDate: Date
  score: number
  reason: string
}

export class ConflictDetector {
  private events: CalendarEvent[]
  
  constructor(events: CalendarEvent[]) {
    this.events = events
  }
  
  // Check for conflicts with a time range
  checkConflicts(
    startDate: Date,
    endDate: Date,
    excludeEventId?: string
  ): ConflictInfo[] {
    const conflicts: ConflictInfo[] = []
    
    for (const event of this.events) {
      if (excludeEventId && event.id === excludeEventId) continue
      
      const hasOverlap = areIntervalsOverlapping(
        { start: startDate, end: endDate },
        { start: event.startDate, end: event.endDate }
      )
      
      if (hasOverlap) {
        const overlapStart = Math.max(
          startDate.getTime(),
          event.startDate.getTime()
        )
        const overlapEnd = Math.min(
          endDate.getTime(),
          event.endDate.getTime()
        )
        const overlapDuration = (overlapEnd - overlapStart) / (1000 * 60) // minutes
        
        conflicts.push({
          event,
          overlapDuration,
          severity: this.calculateSeverity(event, overlapDuration)
        })
      }
    }
    
    return conflicts
  }
  
  // Calculate conflict severity
  private calculateSeverity(
    event: CalendarEvent,
    overlapMinutes: number
  ): 'low' | 'medium' | 'high' {
    // High severity: Important events or full overlap
    if (event.attendees && event.attendees.length > 5) return 'high'
    if (overlapMinutes > 30) return 'high'
    
    // Medium severity: Partial overlap with regular events
    if (overlapMinutes > 15) return 'medium'
    if (event.attendees && event.attendees.length > 0) return 'medium'
    
    // Low severity: Minor overlaps
    return 'low'
  }
  
  // Suggest alternative time slots
  suggestAlternativeSlots(
    duration: number, // in minutes
    preferredStart: Date,
    constraints: {
      workingHours?: { start: number; end: number }
      maxDaysAhead?: number
      preferMorning?: boolean
      avoidWeekends?: boolean
    } = {}
  ): TimeSlotSuggestion[] {
    const suggestions: TimeSlotSuggestion[] = []
    const {
      workingHours = { start: 9, end: 17 },
      maxDaysAhead = 7,
      preferMorning = false,
      avoidWeekends = true
    } = constraints
    
    const endDate = new Date(preferredStart)
    endDate.setDate(endDate.getDate() + maxDaysAhead)
    
    let currentDate = new Date(preferredStart)
    currentDate.setHours(workingHours.start, 0, 0, 0)
    
    while (currentDate < endDate && suggestions.length < 5) {
      // Skip weekends if needed
      if (avoidWeekends && (currentDate.getDay() === 0 || currentDate.getDay() === 6)) {
        currentDate.setDate(currentDate.getDate() + 1)
        currentDate.setHours(workingHours.start, 0, 0, 0)
        continue
      }
      
      const slotEnd = addMinutes(currentDate, duration)
      
      // Check if within working hours
      if (slotEnd.getHours() <= workingHours.end) {
        const conflicts = this.checkConflicts(currentDate, slotEnd)
        
        if (conflicts.length === 0) {
          const score = this.calculateSlotScore(
            currentDate,
            preferredStart,
            preferMorning
          )
          
          suggestions.push({
            startDate: new Date(currentDate),
            endDate: slotEnd,
            score,
            reason: this.getSlotReason(currentDate, preferredStart)
          })
        }
      }
      
      // Move to next slot
      currentDate = addMinutes(currentDate, 30)
      
      // Move to next day if past working hours
      if (currentDate.getHours() >= workingHours.end) {
        currentDate.setDate(currentDate.getDate() + 1)
        currentDate.setHours(workingHours.start, 0, 0, 0)
      }
    }
    
    // Sort by score (higher is better)
    return suggestions.sort((a, b) => b.score - a.score)
  }
  
  private calculateSlotScore(
    slotDate: Date,
    preferredDate: Date,
    preferMorning: boolean
  ): number {
    let score = 100
    
    // Prefer slots closer to the preferred time
    const hoursDiff = Math.abs(
      (slotDate.getTime() - preferredDate.getTime()) / (1000 * 60 * 60)
    )
    score -= hoursDiff * 2
    
    // Morning preference
    if (preferMorning && slotDate.getHours() < 12) {
      score += 10
    }
    
    // Avoid early morning and late afternoon
    if (slotDate.getHours() < 8 || slotDate.getHours() > 16) {
      score -= 20
    }
    
    return Math.max(0, score)
  }
  
  private getSlotReason(slotDate: Date, preferredDate: Date): string {
    const daysDiff = Math.floor(
      (slotDate.getTime() - preferredDate.getTime()) / (1000 * 60 * 60 * 24)
    )
    
    if (daysDiff === 0) {
      return 'Available later today'
    } else if (daysDiff === 1) {
      return 'Available tomorrow'
    } else {
      return `Available in ${daysDiff} days`
    }
  }
}
```

---

## 🎨 **사용자 경험 (UX) 설계**

### **1. 드래그 생성 인터랙션**

```typescript
// src/hooks/useDragToCreate.ts
import { useState, useRef } from 'react'
import { useCalendarStore } from '@/stores/calendarStore'

export const useDragToCreate = () => {
  const [isDragging, setIsDragging] = useState(false)
  const [dragStart, setDragStart] = useState<Date | null>(null)
  const [dragEnd, setDragEnd] = useState<Date | null>(null)
  const dragRef = useRef<HTMLDivElement>(null)
  
  const handleMouseDown = (date: Date) => {
    setIsDragging(true)
    setDragStart(date)
    setDragEnd(date)
  }
  
  const handleMouseMove = (date: Date) => {
    if (isDragging && dragStart) {
      setDragEnd(date)
    }
  }
  
  const handleMouseUp = () => {
    if (isDragging && dragStart && dragEnd) {
      // Open event creation modal with pre-filled dates
      const startDate = dragStart < dragEnd ? dragStart : dragEnd
      const endDate = dragStart < dragEnd ? dragEnd : dragStart
      
      // Trigger event creation
      useCalendarStore.getState().setCreatingEvent({
        startDate,
        endDate
      })
    }
    
    setIsDragging(false)
    setDragStart(null)
    setDragEnd(null)
  }
  
  return {
    isDragging,
    dragStart,
    dragEnd,
    handleMouseDown,
    handleMouseMove,
    handleMouseUp
  }
}
```

### **2. 인라인 편집**

```typescript
// src/components/event/InlineEventEdit.tsx
import React, { useState } from 'react'
import { Input } from '@/components/ui/input'
import { CalendarEvent } from '@/types/calendar'
import { useCalendarStore } from '@/stores/calendarStore'

interface InlineEventEditProps {
  event: CalendarEvent
  onComplete: () => void
}

export const InlineEventEdit: React.FC<InlineEventEditProps> = ({
  event,
  onComplete
}) => {
  const [title, setTitle] = useState(event.title)
  const { updateEvent } = useCalendarStore()
  
  const handleSave = () => {
    if (title.trim() && title !== event.title) {
      updateEvent(event.id, { title: title.trim() })
    }
    onComplete()
  }
  
  return (
    <Input
      value={title}
      onChange={(e) => setTitle(e.target.value)}
      onBlur={handleSave}
      onKeyDown={(e) => {
        if (e.key === 'Enter') handleSave()
        if (e.key === 'Escape') onComplete()
      }}
      className="h-auto py-0.5 px-1 text-xs"
      autoFocus
    />
  )
}
```

---

## 📊 **성능 최적화**

### **1. 이벤트 데이터 정규화**

```typescript
// src/lib/event-normalizer.ts
export interface NormalizedEventData {
  events: Record<string, CalendarEvent>
  eventsByDate: Record<string, string[]>
  eventsByProject: Record<string, string[]>
  recurringEvents: Record<string, string[]>
}

export class EventNormalizer {
  static normalize(events: CalendarEvent[]): NormalizedEventData {
    const normalized: NormalizedEventData = {
      events: {},
      eventsByDate: {},
      eventsByProject: {},
      recurringEvents: {}
    }
    
    for (const event of events) {
      // Store event by ID
      normalized.events[event.id] = event
      
      // Index by date
      const dateKey = format(event.startDate, 'yyyy-MM-dd')
      if (!normalized.eventsByDate[dateKey]) {
        normalized.eventsByDate[dateKey] = []
      }
      normalized.eventsByDate[dateKey].push(event.id)
      
      // Index by project
      if (!normalized.eventsByProject[event.projectId]) {
        normalized.eventsByProject[event.projectId] = []
      }
      normalized.eventsByProject[event.projectId].push(event.id)
      
      // Index recurring events
      if (event.recurrenceRule) {
        const seriesId = event.recurrenceId || event.id
        if (!normalized.recurringEvents[seriesId]) {
          normalized.recurringEvents[seriesId] = []
        }
        normalized.recurringEvents[seriesId].push(event.id)
      }
    }
    
    return normalized
  }
  
  static denormalize(normalized: NormalizedEventData): CalendarEvent[] {
    return Object.values(normalized.events)
  }
}
```

---

## ✅ **Definition of Done**

### **기능 요구사항**
- [ ] 모달 및 인라인 이벤트 생성
- [ ] 자연어 입력 지원 (Quick Add)
- [ ] 반복 일정 설정 및 관리
- [ ] 첨부파일 및 위치 정보 지원
- [ ] 충돌 감지 및 대안 제시

### **기술 요구사항**
- [ ] React Hook Form 기반 폼 관리
- [ ] Zod 스키마 유효성 검사
- [ ] 이벤트 데이터 정규화
- [ ] 낙관적 업데이트 구현

### **UX 요구사항**
- [ ] 드래그로 이벤트 생성
- [ ] 인라인 편집 지원
- [ ] 실시간 유효성 검사
- [ ] 직관적인 반복 설정 UI

### **테스트 요구사항**
- [ ] 폼 유효성 검사 테스트
- [ ] 충돌 감지 알고리즘 테스트
- [ ] 자연어 파싱 테스트
- [ ] E2E 이벤트 생성 플로우

---

## 📚 **관련 문서 참조**

- [04. State Management](../ui-architecture/04-state-management.md)
- [20. Error Handling](../ui-architecture/20-error-handling.md)
- [Story 2.1 Basic Calendar View](./2.1.basic-calendar-view.md)

---

**이 스토리는 바로캘린더의 이벤트 생성 및 관리 시스템 구현을 위한 종합적인 기술 가이드입니다. 직관적인 UI와 강력한 기능을 통해 사용자가 효율적으로 일정을 관리할 수 있도록 지원합니다.**