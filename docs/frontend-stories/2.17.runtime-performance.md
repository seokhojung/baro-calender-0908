# Story 2.17: Runtime Performance Optimization Implementation

## ğŸ“‹ ë¬¸ì„œ ì •ë³´
- **ë¬¸ì„œ ë²„ì „**: 1.0
- **ì‘ì„±ì¼**: 2025-08-28
- **ì‘ì„±ì**: Frontend Team
- **í”„ë¡œì íŠ¸ëª…**: ë°”ë¡œìº˜ë¦°ë” (Baro Calendar)
- **ìƒíƒœ**: Active
- **ê´€ë ¨ ì•„í‚¤í…ì²˜ ë¬¸ì„œ**: [08-runtime-performance.md](../ui-architecture/08-runtime-performance.md)

---

## ğŸ¯ ìŠ¤í† ë¦¬ ëª©í‘œ

ë°”ë¡œìº˜ë¦°ë” ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ **ëŸ°íƒ€ì„ ì„±ëŠ¥ì„ ìµœì í™”**í•˜ì—¬ ì‚¬ìš©ìê°€ ë¹ ë¥´ê³  ë°˜ì‘ì ì¸ ì¸í„°í˜ì´ìŠ¤ë¥¼ ê²½í—˜í•  ìˆ˜ ìˆë„ë¡ í•˜ë©°, Core Web Vitals ê¸°ì¤€ì„ ì¶©ì¡±í•˜ëŠ” ê³ ì„±ëŠ¥ ì›¹ ì• í”Œë¦¬ì¼€ì´ì…˜ì„ êµ¬ì¶•í•œë‹¤.

### ì£¼ìš” êµ¬í˜„ ì‚¬í•­
- **Core Web Vitals ëª©í‘œ ë‹¬ì„±** (LCP < 2.5s, FID < 100ms, CLS < 0.1)
- **ì§€ëŠ¥ì  ì½”ë“œ ìŠ¤í”Œë¦¬íŒ…** ë° ë ˆì´ì§€ ë¡œë”© êµ¬í˜„
- **ê°€ìƒ ìŠ¤í¬ë¡¤ë§** ë° ë©”ëª¨ë¦¬ ìµœì í™”
- **ì‹¤ì‹œê°„ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§** ë° ë¶„ì„ ì‹œìŠ¤í…œ

---

## ğŸ‘¤ ì‚¬ìš©ì ìŠ¤í† ë¦¬

### US 2.17.1: ë¹ ë¥¸ ì´ˆê¸° ë¡œë”©
**As a** ì‚¬ìš©ì  
**I want** ë°”ë¡œìº˜ë¦°ë”ê°€ ë¹ ë¥´ê²Œ ë¡œë“œë˜ê³  ê³§ë°”ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆê¸°ë¥¼  
**So that** ê¸°ë‹¤ë¦¼ ì—†ì´ ì¦‰ì‹œ ì¼ì •ì„ í™•ì¸í•˜ê³  ê´€ë¦¬í•  ìˆ˜ ìˆë‹¤.

**ì¸ìˆ˜ ì¡°ê±´:**
- [ ] LCP (Largest Contentful Paint) < 2.5ì´ˆ
- [ ] FCP (First Contentful Paint) < 1.8ì´ˆ
- [ ] TTI (Time to Interactive) < 3.8ì´ˆ
- [ ] ìº˜ë¦°ë” ë·° ì „í™˜ ì‹œê°„ < 150ms

### US 2.17.2: ë¶€ë“œëŸ¬ìš´ ì¸í„°ë™ì…˜
**As a** ì‚¬ìš©ì  
**I want** ìº˜ë¦°ë”ì—ì„œ ë‚ ì§œë¥¼ ì„ íƒí•˜ê±°ë‚˜ ì´ë²¤íŠ¸ë¥¼ ì¡°ì‘í•  ë•Œ ì¦‰ê°ì ìœ¼ë¡œ ë°˜ì‘í•˜ê¸°ë¥¼  
**So that** ìì—°ìŠ¤ëŸ½ê³  ë§¤ë„ëŸ¬ìš´ ì‚¬ìš© ê²½í—˜ì„ ì–»ì„ ìˆ˜ ìˆë‹¤.

**ì¸ìˆ˜ ì¡°ê±´:**
- [ ] FID (First Input Delay) < 100ms
- [ ] ëª¨ë“  ì• ë‹ˆë©”ì´ì…˜ 60fps ìœ ì§€
- [ ] ì‚¬ìš©ì ì¸í„°ë™ì…˜ ì‘ë‹µ ì‹œê°„ < 100ms
- [ ] ìŠ¤í¬ë¡¤ ì„±ëŠ¥ ìµœì í™” (no jank)

### US 2.17.3: ì•ˆì •ì ì¸ ë ˆì´ì•„ì›ƒ
**As a** ì‚¬ìš©ì  
**I want** í˜ì´ì§€ ë¡œë”© ì¤‘ì´ë‚˜ ì½˜í…ì¸  ë³€ê²½ ì‹œ ë ˆì´ì•„ì›ƒì´ ê°‘ìê¸° ë³€ê²½ë˜ì§€ ì•Šê¸°ë¥¼  
**So that** ì˜ë„í•˜ì§€ ì•Šì€ í´ë¦­ì´ë‚˜ í˜¼ë€ì„ ê²ªì§€ ì•Šì„ ìˆ˜ ìˆë‹¤.

**ì¸ìˆ˜ ì¡°ê±´:**
- [ ] CLS (Cumulative Layout Shift) < 0.1
- [ ] ì´ë¯¸ì§€ ë¡œë”© ì‹œ ë ˆì´ì•„ì›ƒ ì‹œí”„íŠ¸ ë°©ì§€
- [ ] ë™ì  ì½˜í…ì¸  ë¡œë”© ì‹œ ê³µê°„ ë¯¸ë¦¬ í™•ë³´
- [ ] ì›¹í°íŠ¸ ë¡œë”©ìœ¼ë¡œ ì¸í•œ FOIT/FOUT ìµœì†Œí™”

### US 2.17.4: ëŒ€ìš©ëŸ‰ ë°ì´í„° ì²˜ë¦¬
**As a** ëŒ€ëŸ‰ì˜ ì¼ì •ì„ ê´€ë¦¬í•˜ëŠ” ì‚¬ìš©ì  
**I want** ìˆ˜ë°± ê°œì˜ ì´ë²¤íŠ¸ê°€ ìˆì–´ë„ ìº˜ë¦°ë”ê°€ ë¹ ë¥´ê²Œ ë™ì‘í•˜ê¸°ë¥¼  
**So that** ë§ì€ ì¼ì •ì´ ìˆì–´ë„ ì›í™œí•˜ê²Œ ê´€ë¦¬í•  ìˆ˜ ìˆë‹¤.

**ì¸ìˆ˜ ì¡°ê±´:**
- [ ] 1000+ ì´ë²¤íŠ¸ ì²˜ë¦¬ ì‹œ ì„±ëŠ¥ ì €í•˜ < 10%
- [ ] ê°€ìƒ ìŠ¤í¬ë¡¤ë§ìœ¼ë¡œ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ìµœì í™”
- [ ] ë©”ëª¨ì´ì œì´ì…˜ìœ¼ë¡œ ë¶ˆí•„ìš”í•œ ì¬ë Œë”ë§ ë°©ì§€
- [ ] ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€ ë° ìë™ ì •ë¦¬

---

## ğŸ”§ ê¸°ìˆ ì  êµ¬í˜„ ìš”êµ¬ì‚¬í•­

### 1. Core Web Vitals ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ

**ì£¼ìš” íŒŒì¼**: `src/lib/performance/web-vitals.ts`

```typescript
// src/lib/performance/web-vitals.ts
import { getCLS, getFID, getFCP, getLCP, getTTI } from 'web-vitals'

interface WebVitalsMetrics {
  lcp: number
  fid: number
  cls: number
  fcp: number
  tti: number
}

interface PerformanceTarget {
  lcp: number    // 2.5ì´ˆ
  fid: number    // 100ms
  cls: number    // 0.1
  fcp: number    // 1.8ì´ˆ
  tti: number    // 3.8ì´ˆ
}

export const PERFORMANCE_TARGETS: PerformanceTarget = {
  lcp: 2500,
  fid: 100,
  cls: 0.1,
  fcp: 1800,
  tti: 3800,
}

export class WebVitalsMonitor {
  private static metrics: Partial<WebVitalsMetrics> = {}
  private static callbacks: ((metric: string, value: number) => void)[] = []
  
  static initialize() {
    // LCP ì¸¡ì •
    getLCP((metric) => {
      this.recordMetric('lcp', metric.value)
    })
    
    // FID ì¸¡ì •
    getFID((metric) => {
      this.recordMetric('fid', metric.value)
    })
    
    // CLS ì¸¡ì •
    getCLS((metric) => {
      this.recordMetric('cls', metric.value)
    })
    
    // FCP ì¸¡ì •
    getFCP((metric) => {
      this.recordMetric('fcp', metric.value)
    })
    
    // TTI ì¸¡ì •
    getTTI((metric) => {
      this.recordMetric('tti', metric.value)
    })
  }
  
  private static recordMetric(name: keyof WebVitalsMetrics, value: number) {
    this.metrics[name] = value
    
    // ëª©í‘œì¹˜ í™•ì¸
    const target = PERFORMANCE_TARGETS[name]
    const isGood = value <= target
    
    console.log(`${name.toUpperCase()}: ${value}ms ${isGood ? 'âœ…' : 'âš ï¸'}`)
    
    // ì½œë°± ì‹¤í–‰
    this.callbacks.forEach(callback => callback(name, value))
    
    // ì„±ëŠ¥ ì´ë²¤íŠ¸ ë°œì†¡
    this.sendToAnalytics(name, value, isGood)
    
    // ëª©í‘œì¹˜ ì´ˆê³¼ ì‹œ ì•Œë¦¼
    if (!isGood) {
      this.emitPerformanceWarning(name, value, target)
    }
  }
  
  static onMetric(callback: (metric: string, value: number) => void) {
    this.callbacks.push(callback)
  }
  
  static getMetrics(): Partial<WebVitalsMetrics> {
    return { ...this.metrics }
  }
  
  static getScore(): { score: number; grade: 'A' | 'B' | 'C' | 'D' | 'F' } {
    const scores = Object.entries(this.metrics).map(([key, value]) => {
      const target = PERFORMANCE_TARGETS[key as keyof PerformanceTarget]
      return Math.min(100, (target / value) * 100)
    })
    
    const averageScore = scores.reduce((sum, score) => sum + score, 0) / scores.length
    
    let grade: 'A' | 'B' | 'C' | 'D' | 'F'
    if (averageScore >= 90) grade = 'A'
    else if (averageScore >= 80) grade = 'B'
    else if (averageScore >= 70) grade = 'C'
    else if (averageScore >= 60) grade = 'D'
    else grade = 'F'
    
    return { score: Math.round(averageScore), grade }
  }
  
  private static sendToAnalytics(metric: string, value: number, isGood: boolean) {
    // Google Analytics 4 ì „ì†¡
    if (typeof gtag !== 'undefined') {
      gtag('event', 'web_vitals', {
        event_category: 'Performance',
        event_label: metric.toUpperCase(),
        value: Math.round(value),
        custom_metric_good: isGood,
      })
    }
    
    // ë‚´ë¶€ ë¶„ì„ ì„œë²„ ì „ì†¡
    fetch('/api/analytics/web-vitals', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        metric,
        value,
        isGood,
        url: window.location.href,
        timestamp: Date.now(),
      }),
    }).catch(console.error)
  }
  
  private static emitPerformanceWarning(metric: string, value: number, target: number) {
    const event = new CustomEvent('performance-warning', {
      detail: { metric, value, target },
    })
    window.dispatchEvent(event)
    
    // ê°œë°œ í™˜ê²½ì—ì„œë§Œ ì½˜ì†” ê²½ê³ 
    if (process.env.NODE_ENV === 'development') {
      console.warn(
        `ğŸš¨ ì„±ëŠ¥ ëª©í‘œ ë¯¸ë‹¬ì„±: ${metric.toUpperCase()} = ${value}ms (ëª©í‘œ: ${target}ms)`
      )
    }
  }
}

// React Hook
export const useWebVitals = () => {
  const [metrics, setMetrics] = useState<Partial<WebVitalsMetrics>>({})
  const [score, setScore] = useState<{ score: number; grade: string }>({ score: 0, grade: 'F' })
  
  useEffect(() => {
    WebVitalsMonitor.initialize()
    
    const updateMetrics = () => {
      setMetrics(WebVitalsMonitor.getMetrics())
      setScore(WebVitalsMonitor.getScore())
    }
    
    WebVitalsMonitor.onMetric(updateMetrics)
    
    // ì„±ëŠ¥ ê²½ê³  ë¦¬ìŠ¤ë„ˆ
    const handlePerformanceWarning = (event: CustomEvent) => {
      const { metric, value, target } = event.detail
      // ì‚¬ìš©ìì—ê²Œ ì•Œë¦¼ (ê°œë°œ í™˜ê²½ì—ì„œë§Œ)
      if (process.env.NODE_ENV === 'development') {
        console.warn(`Performance issue: ${metric} = ${value}ms > ${target}ms`)
      }
    }
    
    window.addEventListener('performance-warning', handlePerformanceWarning as EventListener)
    
    return () => {
      window.removeEventListener('performance-warning', handlePerformanceWarning as EventListener)
    }
  }, [])
  
  return { metrics, score }
}
```

### 2. ì§€ëŠ¥ì  ì½”ë“œ ìŠ¤í”Œë¦¬íŒ… ì‹œìŠ¤í…œ

**ì£¼ìš” íŒŒì¼**: `src/lib/performance/code-splitting.ts`

```typescript
// src/lib/performance/code-splitting.ts
import { lazy, Suspense, ComponentType } from 'react'
import dynamic from 'next/dynamic'

interface LazyLoadConfig {
  loading?: ComponentType
  delay?: number
  timeout?: number
  retries?: number
}

// ì§€ì—° ë¡œë”© ì»´í¬ë„ŒíŠ¸ íŒ©í† ë¦¬
export const createLazyComponent = <T extends ComponentType<any>>(
  importFn: () => Promise<{ default: T }>,
  config: LazyLoadConfig = {}
) => {
  const { loading: LoadingComponent, delay = 200, timeout = 10000, retries = 3 } = config
  
  const LazyComponent = lazy(() => {
    let retryCount = 0
    
    const loadWithRetry = (): Promise<{ default: T }> => {
      return importFn().catch((error) => {
        if (retryCount < retries) {
          retryCount++
          console.warn(`Component load failed, retrying... (${retryCount}/${retries})`)
          return new Promise(resolve => {
            setTimeout(() => resolve(loadWithRetry()), 1000 * retryCount)
          })
        }
        throw error
      })
    }
    
    return Promise.race([
      loadWithRetry(),
      new Promise<never>((_, reject) => {
        setTimeout(() => reject(new Error('Component load timeout')), timeout)
      })
    ])
  })
  
  const WrappedComponent = (props: any) => (
    <Suspense fallback={LoadingComponent ? <LoadingComponent /> : null}>
      <LazyComponent {...props} />
    </Suspense>
  )
  
  return WrappedComponent
}

// ìº˜ë¦°ë” ë·° ì»´í¬ë„ŒíŠ¸ë“¤ì˜ ì§€ì—° ë¡œë”©
export const LazyCalendarViews = {
  MonthView: createLazyComponent(
    () => import('@/components/calendar/MonthView'),
    { loading: () => <CalendarSkeleton type="month" /> }
  ),
  
  WeekView: createLazyComponent(
    () => import('@/components/calendar/WeekView'),
    { loading: () => <CalendarSkeleton type="week" /> }
  ),
  
  DayView: createLazyComponent(
    () => import('@/components/calendar/DayView'),
    { loading: () => <CalendarSkeleton type="day" /> }
  ),
  
  ListView: createLazyComponent(
    () => import('@/components/calendar/ListView'),
    { loading: () => <CalendarSkeleton type="list" /> }
  ),
}

// ìŠ¤ì¼ˆë ˆí†¤ ë¡œë”© ì»´í¬ë„ŒíŠ¸
const CalendarSkeleton: React.FC<{ type: 'month' | 'week' | 'day' | 'list' }> = ({ type }) => {
  const skeletonClasses = "animate-pulse bg-muted rounded-md"
  
  switch (type) {
    case 'month':
      return (
        <div className="grid grid-cols-7 gap-2 p-4">
          {Array.from({ length: 35 }, (_, i) => (
            <div key={i} className={`${skeletonClasses} aspect-square`} />
          ))}
        </div>
      )
    
    case 'week':
      return (
        <div className="space-y-2 p-4">
          {Array.from({ length: 7 }, (_, i) => (
            <div key={i} className={`${skeletonClasses} h-20`} />
          ))}
        </div>
      )
    
    case 'day':
      return (
        <div className="space-y-1 p-4">
          {Array.from({ length: 24 }, (_, i) => (
            <div key={i} className={`${skeletonClasses} h-12`} />
          ))}
        </div>
      )
    
    case 'list':
      return (
        <div className="space-y-2 p-4">
          {Array.from({ length: 10 }, (_, i) => (
            <div key={i} className={`${skeletonClasses} h-16`} />
          ))}
        </div>
      )
    
    default:
      return <div className={`${skeletonClasses} h-64`} />
  }
}

// í”„ë¦¬ë¡œë”© ë§¤ë‹ˆì €
export class PreloadManager {
  private static preloadedComponents = new Set<string>()
  private static preloadQueue = new Map<string, () => Promise<any>>()
  
  static register(name: string, importFn: () => Promise<any>) {
    this.preloadQueue.set(name, importFn)
  }
  
  static async preload(name: string): Promise<boolean> {
    if (this.preloadedComponents.has(name)) {
      return true
    }
    
    const importFn = this.preloadQueue.get(name)
    if (!importFn) {
      console.warn(`No preload function registered for: ${name}`)
      return false
    }
    
    try {
      await importFn()
      this.preloadedComponents.add(name)
      console.log(`âœ… Preloaded: ${name}`)
      return true
    } catch (error) {
      console.error(`âŒ Failed to preload ${name}:`, error)
      return false
    }
  }
  
  static async preloadBatch(names: string[], concurrent = 2): Promise<boolean[]> {
    const batches = []
    for (let i = 0; i < names.length; i += concurrent) {
      batches.push(names.slice(i, i + concurrent))
    }
    
    const results: boolean[] = []
    for (const batch of batches) {
      const batchResults = await Promise.all(batch.map(name => this.preload(name)))
      results.push(...batchResults)
    }
    
    return results
  }
  
  static getPreloadedComponents(): string[] {
    return Array.from(this.preloadedComponents)
  }
}

// ì»´í¬ë„ŒíŠ¸ ë“±ë¡
PreloadManager.register('MonthView', () => import('@/components/calendar/MonthView'))
PreloadManager.register('WeekView', () => import('@/components/calendar/WeekView'))
PreloadManager.register('DayView', () => import('@/components/calendar/DayView'))
PreloadManager.register('ListView', () => import('@/components/calendar/ListView'))
PreloadManager.register('EventEditor', () => import('@/components/events/EventEditor'))
PreloadManager.register('ProjectManager', () => import('@/components/projects/ProjectManager'))

// ì§€ëŠ¥ì  í”„ë¦¬ë¡œë”© í›…
export const useIntelligentPreload = (currentView: string) => {
  const [preloadStatus, setPreloadStatus] = useState<Record<string, boolean>>({})
  
  useEffect(() => {
    const preloadStrategy = {
      'month': ['WeekView', 'DayView'],
      'week': ['MonthView', 'DayView'],
      'day': ['WeekView', 'MonthView'],
      'list': ['MonthView'],
    }
    
    const componentsToPreload = preloadStrategy[currentView as keyof typeof preloadStrategy] || []
    
    if (componentsToPreload.length > 0) {
      // ì‚¬ìš©ìê°€ idle ìƒíƒœì¼ ë•Œ í”„ë¦¬ë¡œë“œ
      const preloadTimer = setTimeout(async () => {
        const results = await PreloadManager.preloadBatch(componentsToPreload)
        const status: Record<string, boolean> = {}
        componentsToPreload.forEach((name, index) => {
          status[name] = results[index]
        })
        setPreloadStatus(status)
      }, 1000) // 1ì´ˆ í›„ í”„ë¦¬ë¡œë“œ ì‹œì‘
      
      return () => clearTimeout(preloadTimer)
    }
  }, [currentView])
  
  return preloadStatus
}
```

### 3. ê°€ìƒ ìŠ¤í¬ë¡¤ë§ ì‹œìŠ¤í…œ

**ì£¼ìš” íŒŒì¼**: `src/components/common/VirtualScrolling.tsx`

```typescript
// src/components/common/VirtualScrolling.tsx
import React, { useMemo, useCallback, useRef, useEffect, useState } from 'react'
import { FixedSizeList as List, VariableSizeList, areEqual } from 'react-window'
import { FixedSizeGrid as Grid } from 'react-window'

interface VirtualListProps<T> {
  items: T[]
  height: number
  itemHeight: number | ((index: number) => number)
  renderItem: (item: T, index: number, style: React.CSSProperties) => React.ReactNode
  overscan?: number
  className?: string
  onScroll?: (scrollTop: number) => void
}

// ê³ ì • í¬ê¸° ê°€ìƒ ë¦¬ìŠ¤íŠ¸
export const VirtualList = <T,>({
  items,
  height,
  itemHeight,
  renderItem,
  overscan = 5,
  className,
  onScroll,
}: VirtualListProps<T>) => {
  const listRef = useRef<any>(null)
  
  const ItemRenderer = useCallback(({ index, style }: { index: number, style: React.CSSProperties }) => {
    const item = items[index]
    return renderItem(item, index, style)
  }, [items, renderItem])
  
  const MemoizedItemRenderer = React.memo(ItemRenderer, areEqual)
  
  const handleScroll = useCallback(({ scrollTop }: { scrollTop: number }) => {
    onScroll?.(scrollTop)
  }, [onScroll])
  
  return (
    <div className={className}>
      {typeof itemHeight === 'number' ? (
        <List
          ref={listRef}
          height={height}
          itemCount={items.length}
          itemSize={itemHeight}
          overscanCount={overscan}
          onScroll={handleScroll}
        >
          {MemoizedItemRenderer}
        </List>
      ) : (
        <VariableSizeList
          ref={listRef}
          height={height}
          itemCount={items.length}
          itemSize={itemHeight}
          overscanCount={overscan}
          onScroll={handleScroll}
        >
          {MemoizedItemRenderer}
        </VariableSizeList>
      )}
    </div>
  )
}

// ê°€ë³€ í¬ê¸° ê°€ìƒ ë¦¬ìŠ¤íŠ¸
export const DynamicVirtualList = <T,>({
  items,
  height,
  estimatedItemHeight = 50,
  renderItem,
  overscan = 5,
  className,
}: {
  items: T[]
  height: number
  estimatedItemHeight?: number
  renderItem: (item: T, index: number, style: React.CSSProperties) => React.ReactNode
  overscan?: number
  className?: string
}) => {
  const listRef = useRef<VariableSizeList>(null)
  const itemSizes = useRef<Map<number, number>>(new Map())
  
  const getItemSize = useCallback((index: number) => {
    return itemSizes.current.get(index) ?? estimatedItemHeight
  }, [estimatedItemHeight])
  
  const ItemRenderer = useCallback(({ index, style }: { index: number, style: React.CSSProperties }) => {
    const item = items[index]
    
    return (
      <div
        style={style}
        ref={(el) => {
          if (el) {
            const height = el.getBoundingClientRect().height
            if (height !== itemSizes.current.get(index)) {
              itemSizes.current.set(index, height)
              listRef.current?.resetAfterIndex(index)
            }
          }
        }}
      >
        {renderItem(item, index, style)}
      </div>
    )
  }, [items, renderItem])
  
  const MemoizedItemRenderer = React.memo(ItemRenderer, areEqual)
  
  return (
    <div className={className}>
      <VariableSizeList
        ref={listRef}
        height={height}
        itemCount={items.length}
        itemSize={getItemSize}
        overscanCount={overscan}
      >
        {MemoizedItemRenderer}
      </VariableSizeList>
    </div>
  )
}

// ìº˜ë¦°ë” ì´ë²¤íŠ¸ ê°€ìƒ ë¦¬ìŠ¤íŠ¸
interface CalendarEvent {
  id: string
  title: string
  date: Date
  duration: number
  projectId: number
}

export const VirtualEventList: React.FC<{
  events: CalendarEvent[]
  height: number
  onEventClick: (event: CalendarEvent) => void
}> = ({ events, height, onEventClick }) => {
  const renderEvent = useCallback((event: CalendarEvent, index: number, style: React.CSSProperties) => (
    <div 
      key={event.id}
      style={style}
      className="flex items-center p-3 border-b border-border hover:bg-accent cursor-pointer transition-colors"
      onClick={() => onEventClick(event)}
    >
      <div className="flex-1 min-w-0">
        <h4 className="font-medium text-foreground truncate">{event.title}</h4>
        <p className="text-sm text-muted-foreground">
          {event.date.toLocaleDateString()} â€¢ {event.duration}ë¶„
        </p>
      </div>
      <div 
        className="w-3 h-3 rounded-full ml-3"
        style={{ backgroundColor: `var(--project-color-${event.projectId})` }}
      />
    </div>
  ), [onEventClick])
  
  return (
    <VirtualList
      items={events}
      height={height}
      itemHeight={70}
      renderItem={renderEvent}
      className="border border-border rounded-md overflow-hidden"
    />
  )
}

// ë¬´í•œ ìŠ¤í¬ë¡¤ ê°€ìƒ ë¦¬ìŠ¤íŠ¸
export const InfiniteVirtualList = <T,>({
  items,
  height,
  itemHeight,
  renderItem,
  hasNextPage,
  loadNextPage,
  loading,
}: VirtualListProps<T> & {
  hasNextPage: boolean
  loadNextPage: () => Promise<void>
  loading: boolean
}) => {
  const [isLoadingMore, setIsLoadingMore] = useState(false)
  
  const handleScroll = useCallback(async (scrollTop: number, scrollHeight: number, clientHeight: number) => {
    // ìŠ¤í¬ë¡¤ì´ 90% ì§€ì ì— ë„ë‹¬í•˜ë©´ ë‹¤ìŒ í˜ì´ì§€ ë¡œë“œ
    const scrollPercentage = (scrollTop + clientHeight) / scrollHeight
    
    if (scrollPercentage > 0.9 && hasNextPage && !loading && !isLoadingMore) {
      setIsLoadingMore(true)
      try {
        await loadNextPage()
      } finally {
        setIsLoadingMore(false)
      }
    }
  }, [hasNextPage, loading, isLoadingMore, loadNextPage])
  
  const ItemRenderer = useCallback(({ index, style }: { index: number, style: React.CSSProperties }) => {
    const item = items[index]
    
    // ë¡œë”© ì•„ì´í…œ ë Œë”ë§
    if (index === items.length && (isLoadingMore || loading)) {
      return (
        <div style={style} className="flex items-center justify-center p-4">
          <div className="w-6 h-6 border-2 border-primary border-t-transparent rounded-full animate-spin" />
          <span className="ml-2 text-muted-foreground">ë¡œë”© ì¤‘...</span>
        </div>
      )
    }
    
    return renderItem(item, index, style)
  }, [items, renderItem, isLoadingMore, loading])
  
  const itemCount = items.length + (hasNextPage ? 1 : 0)
  
  return (
    <List
      height={height}
      itemCount={itemCount}
      itemSize={typeof itemHeight === 'number' ? itemHeight : 50}
      onScroll={({ scrollTop, scrollHeight, clientHeight }) => {
        handleScroll(scrollTop, scrollHeight, clientHeight)
      }}
    >
      {ItemRenderer}
    </List>
  )
}
```

### 4. ë©”ëª¨ë¦¬ ìµœì í™” ì‹œìŠ¤í…œ

**ì£¼ìš” íŒŒì¼**: `src/lib/performance/memory-optimization.ts`

```typescript
// src/lib/performance/memory-optimization.ts
import { useRef, useEffect, useCallback } from 'react'

// ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§
export class MemoryMonitor {
  private static instance: MemoryMonitor
  private intervalId: number | null = null
  private callbacks: ((memoryInfo: MemoryInfo) => void)[] = []
  
  static getInstance(): MemoryMonitor {
    if (!this.instance) {
      this.instance = new MemoryMonitor()
    }
    return this.instance
  }
  
  startMonitoring(interval = 5000) {
    if (this.intervalId) {
      clearInterval(this.intervalId)
    }
    
    this.intervalId = window.setInterval(() => {
      if ('memory' in performance) {
        const memoryInfo = (performance as any).memory as MemoryInfo
        this.callbacks.forEach(callback => callback(memoryInfo))
        
        // ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì´ ì„ê³„ì¹˜ë¥¼ ì´ˆê³¼í•˜ë©´ ê²½ê³ 
        const usedMB = memoryInfo.usedJSHeapSize / (1024 * 1024)
        const limitMB = memoryInfo.jsHeapSizeLimit / (1024 * 1024)
        const usagePercentage = (usedMB / limitMB) * 100
        
        if (usagePercentage > 80) {
          console.warn(`ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ë†’ìŒ: ${usedMB.toFixed(2)}MB (${usagePercentage.toFixed(1)}%)`)
          this.emitMemoryWarning(memoryInfo)
        }
      }
    }, interval)
  }
  
  stopMonitoring() {
    if (this.intervalId) {
      clearInterval(this.intervalId)
      this.intervalId = null
    }
  }
  
  onMemoryUpdate(callback: (memoryInfo: MemoryInfo) => void) {
    this.callbacks.push(callback)
    
    return () => {
      const index = this.callbacks.indexOf(callback)
      if (index > -1) {
        this.callbacks.splice(index, 1)
      }
    }
  }
  
  private emitMemoryWarning(memoryInfo: MemoryInfo) {
    const event = new CustomEvent('memory-warning', { detail: memoryInfo })
    window.dispatchEvent(event)
  }
  
  getCurrentMemoryInfo(): MemoryInfo | null {
    if ('memory' in performance) {
      return (performance as any).memory as MemoryInfo
    }
    return null
  }
}

// ìë™ ë©”ëª¨ë¦¬ ì •ë¦¬ í›…
export const useMemoryCleanup = () => {
  const cleanupTasks = useRef<(() => void)[]>([])
  
  const addCleanupTask = useCallback((task: () => void) => {
    cleanupTasks.current.push(task)
  }, [])
  
  const runCleanup = useCallback(() => {
    cleanupTasks.current.forEach(task => {
      try {
        task()
      } catch (error) {
        console.error('Cleanup task failed:', error)
      }
    })
    cleanupTasks.current = []
  }, [])
  
  useEffect(() => {
    return runCleanup
  }, [runCleanup])
  
  return { addCleanupTask, runCleanup }
}

// ë©”ëª¨ë¦¬ ë¦¬í¬ ê°ì§€
export const useMemoryLeakDetector = (componentName: string) => {
  const mountTime = useRef(Date.now())
  const initialMemory = useRef<number>(0)
  
  useEffect(() => {
    if ('memory' in performance) {
      const memoryInfo = (performance as any).memory as MemoryInfo
      initialMemory.current = memoryInfo.usedJSHeapSize
    }
    
    return () => {
      if ('memory' in performance) {
        const memoryInfo = (performance as any).memory as MemoryInfo
        const memoryDiff = memoryInfo.usedJSHeapSize - initialMemory.current
        const lifetimeMs = Date.now() - mountTime.current
        
        // ì»´í¬ë„ŒíŠ¸ê°€ 1MB ì´ìƒì˜ ë©”ëª¨ë¦¬ë¥¼ ì§€ì†ì ìœ¼ë¡œ ì‚¬ìš©í•˜ê³  ìˆë‹¤ë©´ ê²½ê³ 
        if (memoryDiff > 1024 * 1024 && lifetimeMs > 10000) {
          console.warn(
            `Potential memory leak in ${componentName}: +${(memoryDiff / (1024 * 1024)).toFixed(2)}MB over ${lifetimeMs}ms`
          )
        }
      }
    }
  }, [componentName])
}

// ëŒ€ìš©ëŸ‰ ë°ì´í„° ì²­í¬ ì²˜ë¦¬
export class DataChunkProcessor {
  static processInChunks<T, R>(
    data: T[],
    processor: (chunk: T[]) => R[],
    chunkSize = 1000,
    delay = 0
  ): Promise<R[]> {
    return new Promise((resolve) => {
      const results: R[] = []
      let index = 0
      
      const processChunk = () => {
        const chunk = data.slice(index, index + chunkSize)
        if (chunk.length === 0) {
          resolve(results)
          return
        }
        
        try {
          const chunkResults = processor(chunk)
          results.push(...chunkResults)
        } catch (error) {
          console.error('Chunk processing error:', error)
        }
        
        index += chunkSize
        
        if (delay > 0) {
          setTimeout(processChunk, delay)
        } else {
          // ë‹¤ìŒ í”„ë ˆì„ì—ì„œ ì²˜ë¦¬í•˜ì—¬ UI ë¸”ë¡œí‚¹ ë°©ì§€
          requestAnimationFrame(processChunk)
        }
      }
      
      processChunk()
    })
  }
}

// ë©”ëª¨ë¦¬ íš¨ìœ¨ì ì¸ ì´ë²¤íŠ¸ ë§¤ë‹ˆì €
export class MemoryEfficientEventManager {
  private listeners = new WeakMap<EventTarget, Map<string, Set<EventListener>>>()
  
  addEventListener(
    target: EventTarget,
    type: string,
    listener: EventListener,
    options?: AddEventListenerOptions
  ) {
    if (!this.listeners.has(target)) {
      this.listeners.set(target, new Map())
    }
    
    const targetListeners = this.listeners.get(target)!
    
    if (!targetListeners.has(type)) {
      targetListeners.set(type, new Set())
    }
    
    targetListeners.get(type)!.add(listener)
    target.addEventListener(type, listener, options)
  }
  
  removeEventListener(target: EventTarget, type: string, listener: EventListener) {
    const targetListeners = this.listeners.get(target)
    if (!targetListeners) return
    
    const typeListeners = targetListeners.get(type)
    if (!typeListeners) return
    
    typeListeners.delete(listener)
    target.removeEventListener(type, listener)
    
    if (typeListeners.size === 0) {
      targetListeners.delete(type)
    }
    
    if (targetListeners.size === 0) {
      this.listeners.delete(target)
    }
  }
  
  removeAllListeners(target: EventTarget) {
    const targetListeners = this.listeners.get(target)
    if (!targetListeners) return
    
    for (const [type, listeners] of targetListeners) {
      for (const listener of listeners) {
        target.removeEventListener(type, listener)
      }
    }
    
    this.listeners.delete(target)
  }
}
```

### 5. ì„±ëŠ¥ í”„ë¡œíŒŒì¼ë§ ë„êµ¬

**ì£¼ìš” íŒŒì¼**: `src/components/dev/PerformanceProfiler.tsx`

```typescript
// src/components/dev/PerformanceProfiler.tsx
import React, { useState, useEffect } from 'react'
import { WebVitalsMonitor } from '@/lib/performance/web-vitals'
import { MemoryMonitor } from '@/lib/performance/memory-optimization'

interface PerformanceData {
  webVitals: {
    lcp?: number
    fid?: number
    cls?: number
    fcp?: number
    tti?: number
  }
  memory?: MemoryInfo
  renderTime?: number
  componentCounts?: Record<string, number>
}

export const PerformanceProfiler: React.FC = () => {
  const [performanceData, setPerformanceData] = useState<PerformanceData>({
    webVitals: {},
  })
  const [isVisible, setIsVisible] = useState(false)
  
  useEffect(() => {
    if (process.env.NODE_ENV !== 'development') return
    
    // Web Vitals ëª¨ë‹ˆí„°ë§
    WebVitalsMonitor.onMetric((metric, value) => {
      setPerformanceData(prev => ({
        ...prev,
        webVitals: {
          ...prev.webVitals,
          [metric]: value,
        },
      }))
    })
    
    // ë©”ëª¨ë¦¬ ëª¨ë‹ˆí„°ë§
    const memoryMonitor = MemoryMonitor.getInstance()
    const unsubscribeMemory = memoryMonitor.onMemoryUpdate((memoryInfo) => {
      setPerformanceData(prev => ({
        ...prev,
        memory: memoryInfo,
      }))
    })
    
    memoryMonitor.startMonitoring()
    
    // í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤ë¡œ í”„ë¡œíŒŒì¼ëŸ¬ í† ê¸€
    const handleKeyPress = (event: KeyboardEvent) => {
      if (event.ctrlKey && event.shiftKey && event.key === 'P') {
        setIsVisible(prev => !prev)
      }
    }
    
    window.addEventListener('keydown', handleKeyPress)
    
    return () => {
      unsubscribeMemory()
      memoryMonitor.stopMonitoring()
      window.removeEventListener('keydown', handleKeyPress)
    }
  }, [])
  
  if (!isVisible || process.env.NODE_ENV !== 'development') {
    return null
  }
  
  const { webVitals, memory } = performanceData
  const score = WebVitalsMonitor.getScore()
  
  return (
    <div className="fixed bottom-4 right-4 bg-card border border-border rounded-lg shadow-lg p-4 max-w-sm z-50">
      <div className="flex items-center justify-between mb-3">
        <h3 className="font-semibold text-sm">Performance Monitor</h3>
        <div className={`px-2 py-1 rounded text-xs font-bold ${
          score.grade === 'A' ? 'bg-green-100 text-green-800' :
          score.grade === 'B' ? 'bg-blue-100 text-blue-800' :
          score.grade === 'C' ? 'bg-yellow-100 text-yellow-800' :
          'bg-red-100 text-red-800'
        }`}>
          {score.grade} ({score.score})
        </div>
      </div>
      
      {/* Web Vitals */}
      <div className="space-y-2 mb-4">
        <h4 className="text-xs font-medium text-muted-foreground">Core Web Vitals</h4>
        {Object.entries(webVitals).map(([metric, value]) => (
          <div key={metric} className="flex justify-between text-xs">
            <span className="font-mono uppercase">{metric}:</span>
            <span className={`font-mono ${
              metric === 'lcp' && value > 2500 ? 'text-red-600' :
              metric === 'fid' && value > 100 ? 'text-red-600' :
              metric === 'cls' && value > 0.1 ? 'text-red-600' :
              metric === 'fcp' && value > 1800 ? 'text-red-600' :
              metric === 'tti' && value > 3800 ? 'text-red-600' :
              'text-green-600'
            }`}>
              {metric === 'cls' ? value?.toFixed(3) : `${value?.toFixed(0)}ms`}
            </span>
          </div>
        ))}
      </div>
      
      {/* Memory Usage */}
      {memory && (
        <div className="space-y-2 mb-4">
          <h4 className="text-xs font-medium text-muted-foreground">Memory Usage</h4>
          <div className="flex justify-between text-xs">
            <span>Used:</span>
            <span className="font-mono">
              {(memory.usedJSHeapSize / (1024 * 1024)).toFixed(1)}MB
            </span>
          </div>
          <div className="flex justify-between text-xs">
            <span>Total:</span>
            <span className="font-mono">
              {(memory.totalJSHeapSize / (1024 * 1024)).toFixed(1)}MB
            </span>
          </div>
          <div className="w-full bg-muted rounded-full h-2">
            <div
              className="bg-primary rounded-full h-2 transition-all duration-300"
              style={{
                width: `${(memory.usedJSHeapSize / memory.jsHeapSizeLimit) * 100}%`
              }}
            />
          </div>
        </div>
      )}
      
      {/* Actions */}
      <div className="flex space-x-2">
        <button
          onClick={() => {
            if ('gc' in window) {
              (window as any).gc()
            } else {
              console.log('Manual GC not available')
            }
          }}
          className="px-2 py-1 bg-muted hover:bg-accent rounded text-xs"
        >
          GC
        </button>
        <button
          onClick={() => {
            const report = WebVitalsMonitor.getMetrics()
            console.table(report)
          }}
          className="px-2 py-1 bg-muted hover:bg-accent rounded text-xs"
        >
          Log
        </button>
        <button
          onClick={() => setIsVisible(false)}
          className="px-2 py-1 bg-muted hover:bg-accent rounded text-xs"
        >
          Hide
        </button>
      </div>
      
      <div className="mt-2 text-xs text-muted-foreground">
        Press Ctrl+Shift+P to toggle
      </div>
    </div>
  )
}

// React DevTools Profiler í†µí•©
export const withProfiler = <P extends object>(
  Component: React.ComponentType<P>,
  id?: string
) => {
  const WrappedComponent = (props: P) => {
    const componentId = id || Component.displayName || Component.name || 'Anonymous'
    
    const handleRender = useCallback(
      (id: string, phase: 'mount' | 'update', actualDuration: number) => {
        if (process.env.NODE_ENV === 'development') {
          console.log(`[Profiler] ${id} (${phase}): ${actualDuration.toFixed(2)}ms`)
        }
        
        // ì„±ëŠ¥ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
        if (actualDuration > 16) { // 60fps ê¸°ì¤€
          console.warn(`[Performance] Slow render: ${id} took ${actualDuration.toFixed(2)}ms`)
        }
      },
      []
    )
    
    return (
      <React.Profiler id={componentId} onRender={handleRender}>
        <Component {...props} />
      </React.Profiler>
    )
  }
  
  WrappedComponent.displayName = `withProfiler(${Component.displayName || Component.name})`
  
  return WrappedComponent
}
```

---

## ğŸ¨ UX ë””ìì¸ ê³ ë ¤ì‚¬í•­

### ì„±ëŠ¥ ì²´ê° ìµœì í™”
- **ìŠ¤ì¼ˆë ˆí†¤ ë¡œë”©**: ì‹¤ì œ ì½˜í…ì¸  êµ¬ì¡°ì™€ ìœ ì‚¬í•œ ìŠ¤ì¼ˆë ˆí†¤ìœ¼ë¡œ ë¡œë”© ì¸ì‹ ê°œì„ 
- **í”„ë¡œê·¸ë ˆì‹œë¸Œ ë¡œë”©**: ì¤‘ìš”í•œ ì½˜í…ì¸ ë¶€í„° ì ì§„ì  ë¡œë”©
- **ë‚™ê´€ì  ì—…ë°ì´íŠ¸**: ì‚¬ìš©ì ì•¡ì…˜ì— ì¦‰ì‹œ ë°˜ì‘í•˜ëŠ” UI ì—…ë°ì´íŠ¸

### ì„±ëŠ¥ ì €í•˜ ì‹œ ëŒ€ì‘
- **ì„±ëŠ¥ ê²½ê³  í‘œì‹œ**: ê°œë°œ í™˜ê²½ì—ì„œ ì„±ëŠ¥ ë¬¸ì œ ì‹¤ì‹œê°„ ì•Œë¦¼
- **ìë™ ìµœì í™”**: ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ë†’ì„ ë•Œ ìë™ ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ ì œì•ˆ
- **ì‚¬ìš©ì í”¼ë“œë°±**: ì„±ëŠ¥ ë¬¸ì œ ë°œìƒ ì‹œ ì‚¬ìš©ìì—ê²Œ ì¹œí™”ì  ì•ˆë‚´

### ì ‘ê·¼ì„± ê³ ë ¤
- **ìŠ¤í¬ë¦° ë¦¬ë”**: ê°€ìƒ ìŠ¤í¬ë¡¤ë§ì—ì„œë„ ì ‘ê·¼ì„± ìœ ì§€
- **í‚¤ë³´ë“œ ë„¤ë¹„ê²Œì´ì…˜**: ëª¨ë“  ìµœì í™”ëœ ì»´í¬ë„ŒíŠ¸ì—ì„œ í‚¤ë³´ë“œ ì ‘ê·¼ì„± ë³´ì¥
- **ëª¨ì…˜ ì„¤ì • ì¤€ìˆ˜**: prefers-reduced-motionì— ë”°ë¥¸ ì• ë‹ˆë©”ì´ì…˜ ì¡°ì ˆ

---

## âš¡ ì„±ëŠ¥ ìµœì í™”

### ë Œë”ë§ ì„±ëŠ¥
- **React.memo**: ë¶ˆí•„ìš”í•œ ë¦¬ë Œë”ë§ ë°©ì§€
- **useMemo/useCallback**: ê°’ë¹„ì‹¼ ê³„ì‚° ë° í•¨ìˆ˜ ë©”ëª¨ì´ì œì´ì…˜
- **ì½”ë“œ ìŠ¤í”Œë¦¬íŒ…**: ë¼ìš°íŠ¸ ë° ì»´í¬ë„ŒíŠ¸ ë‹¨ìœ„ ì§€ì—° ë¡œë”©

### ë©”ëª¨ë¦¬ ê´€ë¦¬
- **ê°€ìƒ ìŠ¤í¬ë¡¤ë§**: DOM ë…¸ë“œ ìˆ˜ ìµœì†Œí™”ë¡œ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ê°ì†Œ
- **ìë™ ì •ë¦¬**: ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë° íƒ€ì´ë¨¸ ì •ë¦¬
- **WeakMap í™œìš©**: ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ ì¹œí™”ì  ë°ì´í„° êµ¬ì¡° ì‚¬ìš©

### ë„¤íŠ¸ì›Œí¬ ìµœì í™”
- **ì§€ëŠ¥ì  í”„ë¦¬ë¡œë”©**: ì‚¬ìš©ì í–‰ë™ íŒ¨í„´ ê¸°ë°˜ ì»´í¬ë„ŒíŠ¸ ë¯¸ë¦¬ ë¡œë”©
- **ìš”ì²­ ì¤‘ë³µ ì œê±°**: ë™ì¼í•œ API ìš”ì²­ ìºì‹± ë° ì¤‘ë³µ ë°©ì§€
- **ë°°ì¹˜ ì²˜ë¦¬**: ì—¬ëŸ¬ ìš”ì²­ì„ ë°°ì¹˜ë¡œ ë¬¶ì–´ì„œ ë„¤íŠ¸ì›Œí¬ ì˜¤ë²„í—¤ë“œ ê°ì†Œ

---

## ğŸ§ª Definition of Done

### Core Web Vitals ë‹¬ì„± ìš”êµ¬ì‚¬í•­
- [ ] LCP (Largest Contentful Paint) < 2.5ì´ˆ
- [ ] FID (First Input Delay) < 100ms
- [ ] CLS (Cumulative Layout Shift) < 0.1
- [ ] FCP (First Contentful Paint) < 1.8ì´ˆ
- [ ] TTI (Time to Interactive) < 3.8ì´ˆ

### ì‘ë‹µì„± ì„±ëŠ¥ ìš”êµ¬ì‚¬í•­
- [ ] ìº˜ë¦°ë” ë·° ì „í™˜ ì‹œê°„ < 150ms
- [ ] ì‚¬ìš©ì ì¸í„°ë™ì…˜ ì‘ë‹µ ì‹œê°„ < 100ms
- [ ] ëª¨ë“  ì• ë‹ˆë©”ì´ì…˜ 60fps ìœ ì§€
- [ ] ìŠ¤í¬ë¡¤ ì„±ëŠ¥ ìµœì í™” (jank 0ê°œ)

### ë©”ëª¨ë¦¬ íš¨ìœ¨ì„± ìš”êµ¬ì‚¬í•­
- [ ] 1000+ ì´ë²¤íŠ¸ ë Œë”ë§ ì‹œ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ < 50MB ì¦ê°€
- [ ] ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ 0ê±´ (24ì‹œê°„ ì‚¬ìš© í…ŒìŠ¤íŠ¸)
- [ ] ê°€ìƒ ìŠ¤í¬ë¡¤ë§ìœ¼ë¡œ DOM ë…¸ë“œ ìˆ˜ < 100ê°œ ìœ ì§€
- [ ] ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ ì™„ì „í•œ ë¦¬ì†ŒìŠ¤ ì •ë¦¬

### ëª¨ë‹ˆí„°ë§ ë° ë¶„ì„ ìš”êµ¬ì‚¬í•­
- [ ] ì‹¤ì‹œê°„ Web Vitals ëª¨ë‹ˆí„°ë§ êµ¬í˜„
- [ ] ì„±ëŠ¥ ê²½ê³  ì‹œìŠ¤í…œ (ì„ê³„ì¹˜ ì´ˆê³¼ ì‹œ ì•Œë¦¼)
- [ ] ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì¶”ì  ë° ëˆ„ìˆ˜ ê°ì§€
- [ ] ê°œë°œ í™˜ê²½ ì„±ëŠ¥ í”„ë¡œíŒŒì¼ëŸ¬ ë„êµ¬

### ì½”ë“œ í’ˆì§ˆ ìš”êµ¬ì‚¬í•­
- [ ] ëª¨ë“  ìµœì í™” ì½”ë“œì˜ TypeScript íƒ€ì… ì•ˆì „ì„±
- [ ] Jest ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ > 80%
- [ ] ì„±ëŠ¥ íšŒê·€ ë°©ì§€ë¥¼ ìœ„í•œ ë²¤ì¹˜ë§ˆí¬ í…ŒìŠ¤íŠ¸
- [ ] ì½”ë“œ ìŠ¤í”Œë¦¬íŒ… ë° ì§€ì—° ë¡œë”© ì—ëŸ¬ í•¸ë“¤ë§

---

## ğŸ“š ê´€ë ¨ ë¬¸ì„œ

- [08-runtime-performance.md](../ui-architecture/08-runtime-performance.md) - ëŸ°íƒ€ì„ ì„±ëŠ¥ ì•„í‚¤í…ì²˜
- [Story 2.18: Build & Bundle Optimization](./2.18.build-bundle-optimization.md) - ë¹Œë“œ ìµœì í™”
- [Story 2.5: Performance Optimization](./2.5.performance-optimization.md) - ê¸°ì¡´ ì„±ëŠ¥ ìµœì í™”
- [Story 2.12: Observability & Monitoring](./2.12.observability-monitoring.md) - ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ

---

## ğŸ“ˆ ì„±ê³µ ì§€í‘œ

### ì„±ëŠ¥ ì§€í‘œ
- **Core Web Vitals ì ìˆ˜**: ëª¨ë“  ì§€í‘œ Good ë“±ê¸‰ ë‹¬ì„± (95th percentile)
- **Lighthouse ì„±ëŠ¥ ì ìˆ˜**: > 90ì  ìœ ì§€
- **ì‚¬ìš©ì ì²´ê° ë¡œë”© ì†ë„**: í‰ê·  ì´ˆê¸° ë¡œë”© ì‹œê°„ < 3ì´ˆ
- **ì¸í„°ë™ì…˜ ì§€ì—°**: í‰ê·  ì‘ë‹µ ì‹œê°„ < 50ms

### ì‚¬ìš©ì ê²½í—˜ ì§€í‘œ
- **ì´íƒˆë¥  ê°ì†Œ**: ë¡œë”© ì‹œê°„ ê°œì„ ìœ¼ë¡œ ì´íƒˆë¥  20% ê°ì†Œ
- **ì‚¬ìš©ì ë§Œì¡±ë„**: ì„±ëŠ¥ ê´€ë ¨ ì‚¬ìš©ì ë¶ˆë§Œ < 5%
- **ì¬ë°©ë¬¸ìœ¨**: ë¹ ë¥¸ ì„±ëŠ¥ìœ¼ë¡œ ì¬ë°©ë¬¸ìœ¨ 15% ì¦ê°€
- **ëª¨ë°”ì¼ ì‚¬ìš©ì„±**: ëª¨ë°”ì¼ì—ì„œ ì„±ëŠ¥ ì €í•˜ < 10%

### ê¸°ìˆ ì  ì§€í‘œ
- **ë©”ëª¨ë¦¬ íš¨ìœ¨ì„±**: ì¥ì‹œê°„ ì‚¬ìš© ì‹œ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì¦ê°€ < 10MB/hour
- **CPU ì‚¬ìš©ë¥ **: í‰ê·  CPU ì‚¬ìš©ë¥  < 20%
- **ë°°í„°ë¦¬ ì†Œëª¨**: ëª¨ë°”ì¼ ë””ë°”ì´ìŠ¤ ë°°í„°ë¦¬ ì˜í–¥ë„ ìµœì†Œí™”
- **ì—ëŸ¬ìœ¨**: ì„±ëŠ¥ ìµœì í™” ê´€ë ¨ ì—ëŸ¬ < 0.1%

### ê°œë°œ ìƒì‚°ì„± ì§€í‘œ
- **ì„±ëŠ¥ ë””ë²„ê¹… ì‹œê°„**: ì„±ëŠ¥ ë¬¸ì œ ì‹ë³„ ë° í•´ê²° ì‹œê°„ 50% ë‹¨ì¶•
- **ê°œë°œ í™˜ê²½ ì„±ëŠ¥**: ë¡œì»¬ ê°œë°œ ì„œë²„ ì‘ë‹µ ì‹œê°„ < 500ms
- **ë¹Œë“œ ì‹œê°„**: ì„±ëŠ¥ ìµœì í™” ì ìš© í›„ì—ë„ ë¹Œë“œ ì‹œê°„ ì¦ê°€ < 20%
- **í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ì‹œê°„**: ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ í¬í•¨ ì „ì²´ í…ŒìŠ¤íŠ¸ ì‹œê°„ < 5ë¶„